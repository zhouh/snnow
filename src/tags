!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
$	tags	/^Classifier	depparser\/Classifier.h	\/^class Classifier {$\/;"	c	language:C++$/;"	m	language:C++	class:__anon1::__anon2::Classifier	file:	access:private
$	tags	/^Classifier::Classifier	depparser\/Classifier.cpp	\/^Classifier::Classifier() {$\/;"	f	language:C++	class:Classifier	signature:()$/;"	m	language:C++	class:__anon1	file:	access:private
$	tags	/^Classifier::~Classifier	depparser\/Classifier.cpp	\/^Classifier::~Classifier() {$\/;"	f	language:C++	class:Classifier	signature:()$/;"	m	language:C++	class:__anon1::__anon2	file:	access:private
$	tags	/^Depparser	depparser\/Depparser.cpp	\/^Depparser::Depparser(bool bTrain) {$\/;"	f	language:C++	class:Depparser	signature:(bool bTrain)$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3	file:	access:private
$	tags	/^Info	include\/mshadow\/extension\/swapaxis.h	\/^  typedef ExpInfo<SrcExp> Info;$\/;"	t	language:C++$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, 1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
$	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
$	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
$	tags	/^UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^a1	include\/mshadow\/extension\/swapaxis.h	\/^  static const int a1 = dimsrc - m_a1;$\/;"	m	language:C++	struct:mshadow::expr::Plan	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
$	tags	/^expr	include\/mshadow\/extension\/unpack_patch2col.h	\/^namespace expr {$\/;"	n	language:C++	namespace:mshadow$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^i_channel_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_channel_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^i_height_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_height_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^i_width_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_width_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^img_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  const SrcExp &img_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^imshape	include\/mshadow\/extension\/unpack_patch2col.h	\/^    Shape<srcdim> imshape = ShapeCheck<srcdim, SrcExp>::Check(img_);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^mshadow	include\/mshadow\/io.h	\/^namespace mshadow {$\/;"	n	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
$	tags	/^mshadow::utils::IStream::Read	include\/mshadow\/io.h	\/^  virtual size_t Read(void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
$	tags	/^mshadow::utils::IStream::Write	include\/mshadow\/io.h	\/^  virtual void Write(const void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
$	tags	/^num	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t num = imshape.ProdShape(0, srcdim - 3);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^o_height	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_height = (i_height_ - psize_y) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^o_width	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_width  = (i_width_  - psize_x) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^psize_x_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_x_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^psize_y_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_y_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^pstride_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t pstride_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^swapaxis	include\/mshadow\/extension\/swapaxis.h	\/^swapaxis(const Exp<SrcExp, DType, etype> &src) {$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src)$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
$	tags	/^unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
$	tags	/^~Depparser	depparser\/Depparser.cpp	\/^Depparser::~Depparser() {$\/;"	f	language:C++	class:Depparser	signature:()$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4	file:	access:private
A	thirdparty/mshadow/guide/exp-template/README.md	/^    - Besides element-wise expressions, we also want to support sugars such as ```A = dot(B.T(), C)```,  again, lazy evaluation is used and no extra memory is allocated.$/;"	v	language:C++
Abort	include/mshadow-ps/thread_util.h	/^  inline void Abort(int max_nthread = 1) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(int max_nthread = 1)
AlignedFree	include/mshadow/sse-inl.h	/^inline void AlignedFree(void *ptr) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(void *ptr)
AlignedFree	include/mshadow/tensor_cpu-inl.h	/^  sse2::AlignedFree(dptr);$/;"	p	language:C++	class:mshadow::sse2	signature:(dptr)
AlignedMallocPitch	include/mshadow/sse-inl.h	/^inline void* AlignedMallocPitch(size_t *out_pitch,$/;"	f	language:C++	namespace:mshadow::sse2	signature:(size_t *out_pitch, size_t lspace, size_t num_line)
AllocByShape	include/mshadow/tensor_container.h	/^  inline void AllocByShape(const Shape<dimension>& shape) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:private	signature:(const Shape<dimension>& shape)
AllocHost	include/mshadow/tensor_cpu-inl.h	/^inline void AllocHost(Tensor<cpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
AllocHost_	include/mshadow/tensor_cpu-inl.h	/^inline void *AllocHost_(size_t size);$/;"	p	language:C++	namespace:mshadow	signature:(size_t size)
AllocHost_	include/mshadow/tensor_cpu-inl.h	/^inline void *AllocHost_<cpu>(size_t size) {$/;"	f	language:C++	namespace:mshadow	signature:(size_t size)
AllocHost_	include/mshadow/tensor_cpu-inl.h	/^inline void *AllocHost_<gpu>(size_t size) {$/;"	f	language:C++	namespace:mshadow	signature:(size_t size)
AllocSpace	include/mshadow/tensor.h	/^inline void AllocSpace(Tensor<cpu, dim, DType> *obj,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj, bool pad = MSHADOW_ALLOC_PAD)
AllocSpace	include/mshadow/tensor.h	/^inline void AllocSpace(Tensor<gpu, dim, DType> *obj,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> *obj, bool pad = MSHADOW_ALLOC_PAD)
AllocSpace	include/mshadow/tensor_cpu-inl.h	/^inline void AllocSpace(Tensor<cpu, dim, DType> *obj, bool pad) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj, bool pad)
Allocate	include/Pool.cpp	/^void * CPool::Allocate (size_t size)$/;"	f	language:C++	class:CPool	signature:(size_t size)
Allocate	include/Pool.h	/^	void * Allocate( size_t size );$/;"	p	language:C++	class:CPool	access:public	signature:( size_t size )
Allreduce	include/mshadow-ps/ps_rabit-inl.h	/^        rabit::Allreduce<rabit::op::Sum>$/;"	p	language:C++	class:mshadow::ps::RabitModel::rabit	signature:(tsk.data.dptr_, tsk.data.MSize())
AlphaBLAS	include/mshadow/base.h	/^  inline static default_real_t AlphaBLAS(void) { return -1.0f; }$/;"	f	language:C++	struct:mshadow::sv::minusto	access:public	signature:(void)
AlphaBLAS	include/mshadow/base.h	/^  inline static default_real_t AlphaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::plusto	access:public	signature:(void)
AlphaBLAS	include/mshadow/base.h	/^  inline static default_real_t AlphaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::saveto	access:public	signature:(void)
ApplyUpdate	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    inline static void ApplyUpdate(mshadow::Stream<xpu> *stream, void *arg) {$/;"	f	language:C++	struct:NNet::UpdateEntry	access:public	signature:(mshadow::Stream<xpu> *stream, void *arg)
Assert	include/mshadow-ps/ps_dist-inl.h	/^    utils::Assert(data[0].CheckContiguous(), "data must be contiguous");$/;"	p	language:C++	class:mshadow::ps::DistModel::utils	signature:(data[0].CheckContiguous(), Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^          utils::Assert(e.req.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.req.size() == devices.size(), Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^          utils::Assert(e.wait.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.wait.size() == devices.size(), Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^        utils::Assert(destroy_signal, "abort but not destroy");$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(destroy_signal, Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^      utils::Assert(data.CheckContiguous(), "Init");$/;"	p	language:C++	class:mshadow::ps::LocalModel::PushEntry::utils	signature:(data.CheckContiguous(), Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^      utils::Assert(w.nwait >= 0, "boundary check");$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(w.nwait >= 0, Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^    utils::Assert(e.req.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.req.size() == devices.size(), Ó)
Assert	include/mshadow-ps/ps_local-inl.h	/^    utils::Assert(e.wait.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.wait.size() == devices.size(), Ó)
Assert	include/mshadow-ps/ps_rabit-inl.h	/^        utils::Assert(destroy_reduce_thread_, "abort but not destroy");$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(destroy_reduce_thread_, Ó)
Assert	include/mshadow-ps/ps_rabit-inl.h	/^    utils::Assert(data[0].CheckContiguous(), "data must be contiguous");$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(data[0].CheckContiguous(), Ó)
Assert	include/mshadow-ps/thread_util.h	/^      utils::Assert(fqueue_.size() != 0, "Queue.Pop");$/;"	p	language:C++	class:mshadow::utils::ThreadPQueue::utils	signature:(fqueue_.size() != 0, Ó)
Assert	include/mshadow-ps/thread_util.h	/^      utils::Assert(pqueue_.size() != 0, "Queue.Pop");$/;"	p	language:C++	class:mshadow::utils::ThreadPQueue::utils	signature:(pqueue_.size() != 0, Ó)
Assert	include/mshadow/utils.h	/^inline void Assert(bool exp, const char *fmt, ...) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(bool exp, const char *fmt, ...)
BASIS	thirdparty/mshadow/LICENSE	/^distributed under the License is distributed on an "AS IS" BASIS,$/;"	v	language:C++
BLASEngine	include/mshadow/dot_engine-inl.h	/^struct BLASEngine;$/;"	x	language:C++
BLASEngine	include/mshadow/dot_engine-inl.h	/^struct BLASEngine<cpu> {$/;"	s	language:C++	namespace:mshadow::expr
BLASEngine	include/mshadow/dot_engine-inl.h	/^struct BLASEngine<gpu> {$/;"	s	language:C++	namespace:mshadow::expr
BLOCK_SIZE	include/Pool.h	/^	const static size_t BLOCK_SIZE = 40960; $/;"	m	language:C++	class:CPool	access:private
BUF_LEN	depparser/Config.cpp	/^	const int BUF_LEN = 256;$/;"	l	language:C++
Backprop	depparser/Depparser.cpp	/^						nets[round - 1]->Backprop(grads);$/;"	p	language:C++	file:	signature:(grads)
Backprop	include/NNet.h	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) {$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
Backprop	thirdparty/mshadow/guide/README.md	/^void Backprop(Tensor<xpu, 2> gradin,$/;"	f	language:C++	signature:(Tensor<xpu, 2> gradin, const Tensor<xpu, 2> &gradout, const Tensor<xpu, 2> &netweight)
Backprop	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^      net->Backprop(pred);$/;"	p	language:C++	file:	signature:(pred)
Backprop	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
Backprop	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) {$/;"	f	language:C++	class:ConvNet	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
Backprop	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^      net->Backprop(pred);$/;"	p	language:C++	file:	signature:(pred)
Backprop	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
Backprop	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) {$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
Backprop	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^        nets[tid]->Backprop(pred);$/;"	p	language:C++	file:	signature:(pred)
Backprop	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t> &gradout) {$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t> &gradout)
Backprop	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
BetaBLAS	include/mshadow/base.h	/^  inline static default_real_t BetaBLAS(void) { return 0.0f; }$/;"	f	language:C++	struct:mshadow::sv::saveto	access:public	signature:(void)
BetaBLAS	include/mshadow/base.h	/^  inline static default_real_t BetaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::minusto	access:public	signature:(void)
BetaBLAS	include/mshadow/base.h	/^  inline static default_real_t BetaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::plusto	access:public	signature:(void)
BinaryMapExp	include/mshadow/expression.h	/^  explicit BinaryMapExp(const TA &lhs, const TB &rhs)$/;"	f	language:C++	struct:mshadow::expr::BinaryMapExp	access:public	signature:(const TA &lhs, const TB &rhs)
BinaryMapExp	include/mshadow/expression.h	/^struct BinaryMapExp: public Exp<BinaryMapExp<OP, TA, TB, DType, etype>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
Broadcast	include/mshadow-ps/ps_local-inl.h	/^            wait_cond.Broadcast();$/;"	p	language:C++	signature:()
Broadcast	include/mshadow-ps/thread.h	/^  inline void Broadcast(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
Broadcast1DExp	include/mshadow/extension/broadcast.h	/^  Broadcast1DExp(const SrcExp &src, Shape<dimdst> shape)$/;"	f	language:C++	struct:mshadow::expr::Broadcast1DExp	access:public	signature:(const SrcExp &src, Shape<dimdst> shape)
Broadcast1DExp	include/mshadow/extension/broadcast.h	/^struct Broadcast1DExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
BuildPath	depparser/Config.cpp	/^BuildPath()$/;"	f	language:C++	class:CConfig	signature:()
BuildPath	depparser/Config.h	/^	static string BuildPath();$/;"	p	language:C++	class:CConfig	access:public	signature:()
CConfig	depparser/Config.h	/^class CConfig$/;"	c	language:C++
CConfig::BuildPath	depparser/Config.cpp	/^BuildPath()$/;"	f	language:C++	class:CConfig	signature:()
CConfig::BuildPath	depparser/Config.h	/^	static string BuildPath();$/;"	p	language:C++	class:CConfig	access:public	signature:()
CConfig::LoadConfig	depparser/Config.cpp	/^bool CConfig::LoadConfig(const char *pszPath)$/;"	f	language:C++	class:CConfig	signature:(const char *pszPath)
CConfig::LoadConfig	depparser/Config.h	/^	static bool LoadConfig(const char *pszPath);$/;"	p	language:C++	class:CConfig	access:public	signature:(const char *pszPath)
CConfig::ReadConfig	depparser/Config.cpp	/^ReadConfig(const char * pszPath)$/;"	f	language:C++	class:CConfig	signature:(const char * pszPath)
CConfig::ReadConfig	depparser/Config.h	/^	static bool ReadConfig(const char *pszPath);$/;"	p	language:C++	class:CConfig	access:public	signature:(const char *pszPath)
CConfig::SaveConfig	depparser/Config.cpp	/^bool CConfig::SaveConfig(const char *pszPath)$/;"	f	language:C++	class:CConfig	signature:(const char *pszPath)
CConfig::SaveConfig	depparser/Config.h	/^	static bool SaveConfig(const char *pszPath);$/;"	p	language:C++	class:CConfig	access:public	signature:(const char *pszPath)
CConfig::bBPRateLinearDecay	depparser/Config.cpp	/^			CConfig::bBPRateLinearDecay = string(pVal) == string("true");$/;"	m	language:C++	class:CConfig	file:
CConfig::bBPRateLinearDecay	depparser/Config.cpp	/^bool  CConfig::bBPRateLinearDecay = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bConvert	depparser/Config.cpp	/^bool	CConfig::bConvert = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bDropOut	depparser/Config.cpp	/^			CConfig::bDropOut = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
CConfig::bDropOut	depparser/Config.cpp	/^bool	CConfig::bDropOut = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bDropOut	depparser/Config.h	/^	static bool	 bDropOut;$/;"	m	language:C++	class:CConfig	access:public
CConfig::bHiddenOnly	depparser/Config.cpp	/^			CConfig::bHiddenOnly = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
CConfig::bHiddenOnly	depparser/Config.cpp	/^bool	CConfig::bHiddenOnly = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bLoadDBN	depparser/Config.cpp	/^			CConfig::bLoadDBN = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
CConfig::bLoadDBN	depparser/Config.cpp	/^bool	CConfig::bLoadDBN = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bNormalizeEmbedding	depparser/Config.cpp	/^bool  CConfig::bNormalizeEmbedding = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bSmall	depparser/Config.cpp	/^			CConfig::bSmall = string(pVal) == string("true");$/;"	m	language:C++	class:CConfig	file:
CConfig::bSmall	depparser/Config.cpp	/^bool  CConfig::bSmall    = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::bWithHidden	depparser/Config.cpp	/^			CConfig::bWithHidden = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
CConfig::bWithHidden	depparser/Config.cpp	/^bool	CConfig::bWithHidden = false;$/;"	m	language:C++	class:CConfig	file:
CConfig::fBPRate	depparser/Config.cpp	/^			CConfig::fBPRate = atof(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::fBPRate	depparser/Config.cpp	/^double  CConfig::fBPRate = 0.1;$/;"	m	language:C++	class:CConfig	file:
CConfig::fBPRate	depparser/Config.h	/^	static double fBPRate;$/;"	m	language:C++	class:CConfig	access:public
CConfig::fFinalMom	depparser/Config.cpp	/^			CConfig::fFinalMom = atof(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::fFinalMom	depparser/Config.cpp	/^double  CConfig::fFinalMom = 0.5;$/;"	m	language:C++	class:CConfig	file:
CConfig::fInitMom	depparser/Config.cpp	/^			CConfig::fInitMom = atof(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::fInitMom	depparser/Config.cpp	/^double  CConfig::fInitMom = 0.5;$/;"	m	language:C++	class:CConfig	file:
CConfig::fInitRange	depparser/Config.h	/^	static double fInitRange;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nBatchNum	depparser/Config.cpp	/^			CConfig::nBatchNum = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nBatchNum	depparser/Config.cpp	/^int		CConfig::nBatchNum = 100;$/;"	m	language:C++	class:CConfig	file:
CConfig::nBatchSize	depparser/Config.cpp	/^			CConfig::nBatchSize = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nBatchSize	depparser/Config.cpp	/^int 	CConfig::nBatchSize = 100;$/;"	m	language:C++	class:CConfig	file:
CConfig::nBatchSize	depparser/Config.h	/^	static int nBatchSize;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nBeamSize	depparser/Config.h	/^	static int nBeamSize;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nEmbeddingDim	depparser/Config.cpp	/^            CConfig::nEmbeddingDim = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nEmbeddingDim	depparser/Config.cpp	/^int     CConfig::nEmbeddingDim;$/;"	m	language:C++	class:CConfig	file:
CConfig::nEmbeddingDim	depparser/Config.h	/^    static int nEmbeddingDim;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nFeatureNum	depparser/Config.h	/^    static int nFeatureNum;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nHiddenSize	depparser/Config.h	/^	static int nHiddenSize;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nLabelNum	depparser/Config.h	/^	static int nLabelNum;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nLeft	depparser/Config.cpp	/^			CConfig::nLeft = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nLeft	depparser/Config.cpp	/^int		CConfig::nLeft = 3;$/;"	m	language:C++	class:CConfig	file:
CConfig::nRight	depparser/Config.cpp	/^			CConfig::nRight = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nRight	depparser/Config.cpp	/^int		CConfig::nRight = 3;$/;"	m	language:C++	class:CConfig	file:
CConfig::nRound	depparser/Config.cpp	/^			CConfig::nRound = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nRound	depparser/Config.cpp	/^int		CConfig::nRound		 = -1;$/;"	m	language:C++	class:CConfig	file:
CConfig::nRound	depparser/Config.h	/^	static int nRound;$/;"	m	language:C++	class:CConfig	access:public
CConfig::nThread	depparser/Config.cpp	/^			CConfig::nThread = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
CConfig::nThread	depparser/Config.cpp	/^int		CConfig::nThread = 3;$/;"	m	language:C++	class:CConfig	file:
CConfig::nThread	depparser/Config.h	/^	static int nThread;$/;"	m	language:C++	class:CConfig	access:public
CConfig::strCorpus	depparser/Config.cpp	/^			CConfig::strCorpus = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strDBNPath	depparser/Config.cpp	/^			CConfig::strDBNPath = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strEmbeddingPath	depparser/Config.cpp	/^			CConfig::strEmbeddingPath = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strEmbeddingPath	depparser/Config.h	/^	static string strEmbeddingPath;$/;"	m	language:C++	class:CConfig	access:public
CConfig::strErrorType	depparser/Config.cpp	/^			CConfig::strErrorType = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strErrorType	depparser/Config.cpp	/^	path + "_err"+ CConfig::strErrorType;$/;"	m	language:C++	class:CConfig	file:
CConfig::strLogPrefix	depparser/Config.cpp	/^			CConfig::strLogPrefix = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strRBMPrefix	depparser/Config.cpp	/^			CConfig::strRBMPrefix = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strTestPath	depparser/Config.cpp	/^			CConfig::strTestPath = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strTestPath	depparser/Config.h	/^	static string strTestPath;$/;"	m	language:C++	class:CConfig	access:public
CConfig::strTrainPath	depparser/Config.cpp	/^			CConfig::strTrainPath = pVal;$/;"	m	language:C++	class:CConfig	file:
CConfig::strTrainPath	depparser/Config.h	/^	static string strTrainPath;$/;"	m	language:C++	class:CConfig	access:public
CConfig::strdevPath	depparser/Config.h	/^	static string strdevPath;$/;"	m	language:C++	class:CConfig	access:public
CConfig::vHiddenSize	depparser/Config.cpp	/^vector<int> CConfig::vHiddenSize;$/;"	m	language:C++	class:CConfig	file:
CConfig::vHiddenSize	depparser/Config.h	/^	static vector<int>  vHiddenSize;$/;"	m	language:C++	class:CConfig	access:public
CConfig::vHiddenType	depparser/Config.cpp	/^vector<string> CConfig::vHiddenType;$/;"	m	language:C++	class:CConfig	file:
CHECK_NOTNULL	include/mshadow-ps/ps_dist-inl.h	/^         CHECK_NOTNULL(shared_model_));$/;"	p	language:C++	signature:(shared_model_)
CPU	thirdparty/mshadow/guide/README.md	/^``` Tensor<cpu,2>``` means a two dimensional tensor in CPU, while ``` Tensor<gpu,3>``` means three dimensional tensor in GPU.$/;"	v	language:C++
CPool	include/Pool.h	/^	CPool(void):pCurBlock(NULL), totalSize(0){}$/;"	f	language:C++	class:CPool	access:public	signature:(void)
CPool	include/Pool.h	/^class CPool$/;"	c	language:C++
CPool::Allocate	include/Pool.cpp	/^void * CPool::Allocate (size_t size)$/;"	f	language:C++	class:CPool	signature:(size_t size)
CPool::Allocate	include/Pool.h	/^	void * Allocate( size_t size );$/;"	p	language:C++	class:CPool	access:public	signature:( size_t size )
CPool::BLOCK_SIZE	include/Pool.h	/^	const static size_t BLOCK_SIZE = 40960; $/;"	m	language:C++	class:CPool	access:private
CPool::CPool	include/Pool.h	/^	CPool(void):pCurBlock(NULL), totalSize(0){}$/;"	f	language:C++	class:CPool	access:public	signature:(void)
CPool::Free	include/Pool.cpp	/^void CPool::Free()$/;"	f	language:C++	class:CPool	signature:()
CPool::Free	include/Pool.h	/^	void Free();$/;"	p	language:C++	class:CPool	access:public	signature:()
CPool::Recycle	include/Pool.cpp	/^void CPool::Recycle()$/;"	f	language:C++	class:CPool	signature:()
CPool::Recycle	include/Pool.h	/^	void Recycle();$/;"	p	language:C++	class:CPool	access:public	signature:()
CPool::SBlock	include/Pool.h	/^	struct SBlock$/;"	s	language:C++	class:CPool	access:private
CPool::SBlock::m_nBlkSize	include/Pool.h	/^		size_t m_nBlkSize, m_nUsed;$/;"	m	language:C++	struct:CPool::SBlock	access:public
CPool::SBlock::m_nUsed	include/Pool.h	/^		size_t m_nBlkSize, m_nUsed;$/;"	m	language:C++	struct:CPool::SBlock	access:public
CPool::SBlock::m_pData	include/Pool.h	/^		char *m_pData;$/;"	m	language:C++	struct:CPool::SBlock	access:public
CPool::ShowSize	include/Pool.h	/^	void ShowSize(){fprintf(stderr, "Pool Size %lu k\\n", totalSize >> 10);}$/;"	f	language:C++	class:CPool	access:public	signature:()
CPool::Test	include/Pool.h	/^	void Test();$/;"	p	language:C++	class:CPool	access:public	signature:()
CPool::allocSize	include/Pool.h	/^		size_t allocSize = size > BLOCK_SIZE ? size : BLOCK_SIZE;$/;"	l	language:C++
CPool::allocateBlock	include/Pool.h	/^	SBlock * allocateBlock( size_t size )$/;"	f	language:C++	class:CPool	access:private	signature:( size_t size )
CPool::end	include/Pool.h	/^	list<SBlock *>::iterator it, end;$/;"	m	language:C++	class:CPool	access:private
CPool::it	include/Pool.h	/^	list<SBlock *>::iterator it, end;$/;"	m	language:C++	class:CPool	access:private
CPool::m_listFree	include/Pool.h	/^	list<SBlock *> m_listUsed, m_listFree;$/;"	m	language:C++	class:CPool	access:private
CPool::m_listUsed	include/Pool.h	/^	list<SBlock *> m_listUsed, m_listFree;$/;"	m	language:C++	class:CPool	access:private
CPool::pBlock	include/Pool.h	/^		SBlock * pBlock = (SBlock *)std::malloc( allocSize + sizeof( SBlock ) );$/;"	l	language:C++
CPool::pCurBlock	include/Pool.h	/^	SBlock * pCurBlock;$/;"	m	language:C++	class:CPool	access:private
CPool::totalSize	include/Pool.h	/^	size_t   totalSize;$/;"	m	language:C++	class:CPool	access:private
CPool::~CPool	include/Pool.cpp	/^CPool::~CPool(void)$/;"	f	language:C++	class:CPool	signature:(void)
CPool::~CPool	include/Pool.h	/^	~CPool(void);$/;"	p	language:C++	class:CPool	access:public	signature:(void)
CUDA	thirdparty/mshadow/make/README.md	/^you can compile mshadow without CUDA, and specify your own choice of BLAS.$/;"	v	language:C++
CallbackFunction	include/mshadow-ps/mshadow_ps.h	/^  typedef void (CallbackFunction) (Stream<xpu> *stream, void *arg);$/;"	t	language:C++	class:mshadow::ps::ISharedModel	access:public
CallbackFunction	include/mshadow-ps/ps_local-inl.h	/^  CallbackFunction;$/;"	t	language:C++	class:mshadow::ps::LocalModel	access:public
ChannelPoolingExp	include/mshadow/extension/channel_pool.h	/^  ChannelPoolingExp(const SrcExp &src, index_t nsize, index_t stride, index_t pad)$/;"	f	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public	signature:(const SrcExp &src, index_t nsize, index_t stride, index_t pad)
ChannelPoolingExp	include/mshadow/extension/channel_pool.h	/^struct ChannelPoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
ChannelUnpoolingExp	include/mshadow/extension/channel_unpool.h	/^  ChannelUnpoolingExp(const SrcExp &data_src,$/;"	f	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public	signature:(const SrcExp &data_src, const SrcExp &data_pooled, const SrcExp &grad_pooled, index_t nsize, index_t kstride, index_t pad)
ChannelUnpoolingExp	include/mshadow/extension/channel_unpool.h	/^struct ChannelUnpoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
Check	include/mshadow-ps/ps_local-inl.h	/^        utils::Check(e.data[0][0].shape_ == tsk.data.shape_,$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.data[0][0].shape_ == tsk.data.shape_, Ó)
Check	include/mshadow-ps/ps_local-inl.h	/^    utils::Check(devices.size() != 0,$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(devices.size() != 0, Ó)
Check	include/mshadow-ps/ps_local-inl.h	/^    utils::Check(init_end == 0,$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(init_end == 0, Ó)
Check	include/mshadow-ps/ps_rabit-inl.h	/^        utils::Check(disable_allreduce_ == 0,$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(disable_allreduce_ == 0, Ó)
Check	include/mshadow-ps/ps_rabit-inl.h	/^        utils::Check(key == tsk.key, "Allreduce not concensus");$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(key == tsk.key, Ó)
Check	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  utils::Check(dst.shape_ == src.shape_, "Softmax: shape mismatch");$/;"	p	language:C++	class:mshadow::cuda::utils	file:	signature:(dst.shape_ == src.shape_, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(dst.size(0) == lhs.size(0) && dst.size(1) == rhs.size(0),$/;"	p	language:C++	class:mshadow::expr::DotEngine::utils	signature:(dst.size(0) == lhs.size(0) && dst.size(1) == rhs.size(0), Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(dst.size(0) == sleft[0] && dst.size(1) == sright[1] \\$/;"	p	language:C++	class:mshadow::expr::DotEngine::utils	signature:(dst.size(0) == sleft[0] && dst.size(1) == sright[1] \ && sleft[1] == sright[0] , Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(dst.size(0) == sright[1] && lhs.size(0) == sright[0],$/;"	p	language:C++	class:mshadow::expr::DotEngine::utils	signature:(dst.size(0) == sright[1] && lhs.size(0) == sright[0], Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Dgemm fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Dgemv fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Dger fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Sgemm fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Sgemv fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Sger fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/expr_engine-inl.h	/^  Check(const BinaryMapExp<OP, TA, TB, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &t)
Check	include/mshadow/expr_engine-inl.h	/^  Check(const MakeTensorExp<T, SrcExp, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const MakeTensorExp<T, SrcExp, dim, DType> &t)
Check	include/mshadow/expr_engine-inl.h	/^  Check(const TypecastExp<DstDType, SrcDType, EType, etype> &exp) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const TypecastExp<DstDType, SrcDType, EType, etype> &exp)
Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const E &t);$/;"	p	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const E &t)
Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const ScalarExp<DType> &exp) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const ScalarExp<DType> &exp)
Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const Tensor<Device, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const Tensor<Device, dim, DType> &t)
Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const TransposeExp<E, DType> &e) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const TransposeExp<E, DType> &e)
Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const UnaryMapExp<OP, TA, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const UnaryMapExp<OP, TA, DType, etype> &t)
Check	include/mshadow/extension/channel_pool.h	/^    utils::Check(this->shape_[srcdim - 3] >= nsize_,$/;"	p	language:C++	class:mshadow::expr::ChannelPoolingExp::utils	signature:(this->shape_[srcdim - 3] >= nsize_, Ó)
Check	include/mshadow/extension/channel_unpool.h	/^      utils::Check(pshape[k] == sshape[k],$/;"	p	language:C++	class:mshadow::expr::ChannelUnpoolingExp::utils	signature:(pshape[k] == sshape[k], Ó)
Check	include/mshadow/extension/channel_unpool.h	/^    utils::Check(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled),$/;"	p	language:C++	class:mshadow::expr::ChannelUnpoolingExp::utils	signature:(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled), Ó)
Check	include/mshadow/extension/concat.h	/^        utils::Check(sshape1[i] == sshape2[i],$/;"	p	language:C++	class:mshadow::expr::ConcatExp::utils	signature:(sshape1[i] == sshape2[i], Ó)
Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 1] >= cshape[1] + start_width,$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 1] >= cshape[1] + start_width, Ó)
Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 1] >= cshape[1],$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 1] >= cshape[1], Ó)
Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 2] >= cshape[0] + start_height,$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 2] >= cshape[0] + start_height, Ó)
Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 2] >= cshape[0],$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 2] >= cshape[0], Ó)
Check	include/mshadow/extension/pack_col2patch.h	/^    utils::Check(sshape[0] == psize_y * psize_x * imshape[dstdim - 3],$/;"	p	language:C++	class:mshadow::expr::PackColToPatchXExp::utils	signature:(sshape[0] == psize_y * psize_x * imshape[dstdim - 3], Ó)
Check	include/mshadow/extension/pack_col2patch.h	/^    utils::Check(sshape[1] == o_height * o_width *$/;"	p	language:C++	class:mshadow::expr::PackColToPatchXExp::utils	signature:(sshape[1] == o_height * o_width * imshape.ProdShape(0, dstdim - 3), Ó)
Check	include/mshadow/extension/reshape.h	/^    utils::Check(ishape.Size() == shape.Size(), "reshape size must match");$/;"	p	language:C++	class:mshadow::expr::ReshapeExp::utils	signature:(ishape.Size() == shape.Size(), Ó)
Check	include/mshadow/extension/spatial_unpool.h	/^      utils::Check(pshape[k] == sshape[k],$/;"	p	language:C++	class:mshadow::expr::UnPoolingExp::utils	signature:(pshape[k] == sshape[k], Ó)
Check	include/mshadow/extension/spatial_unpool.h	/^    utils::Check(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled),$/;"	p	language:C++	class:mshadow::expr::UnPoolingExp::utils	signature:(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled), Ó)
Check	include/mshadow/io.h	/^    utils::Check(fi.Read(dst[i].dptr_, sizeof(DType) * dst.size(1)) != 0,$/;"	p	language:C++	class:mshadow::utils	signature:(fi.Read(dst[i].dptr_, sizeof(DType) * dst.size(1)) != 0, Ó)
Check	include/mshadow/io.h	/^    utils::Check(shape == dst_->shape_,$/;"	p	language:C++	class:mshadow::utils	signature:(shape == dst_->shape_, Ó)
Check	include/mshadow/io.h	/^    utils::Check(tmp.shape == dst->shape_,$/;"	p	language:C++	class:mshadow::utils	signature:(tmp.shape == dst->shape_, Ó)
Check	include/mshadow/io.h	/^  utils::Check(fi.Read(&shape, sizeof(shape)) != 0, "mshadow::LoadBinary");$/;"	p	language:C++	class:mshadow::utils	signature:(fi.Read(&shape, sizeof(shape)) != 0, Ó)
Check	include/mshadow/random.h	/^    utils::Check(status == CURAND_STATUS_SUCCESS, "CURAND Gen Uniform failed");$/;"	p	language:C++	class:mshadow::Random::utils	signature:(status == CURAND_STATUS_SUCCESS, Ó)
Check	include/mshadow/random.h	/^    utils::Check(status == CURAND_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::Random::utils	signature:(status == CURAND_STATUS_SUCCESS, Ó)
Check	include/mshadow/random.h	/^    utils::Check(status == VSL_STATUS_OK,$/;"	p	language:C++	class:mshadow::Random::utils	signature:(status == VSL_STATUS_OK, Ó)
Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const BinaryMapExp<OP, TA, TB, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &t)
Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const E &exp) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const E &exp)
Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const ScalarExp<DType> &exp) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const ScalarExp<DType> &exp)
Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const Tensor<cpu, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const Tensor<cpu, dim, DType> &t)
Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const UnaryMapExp<OP, TA, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const UnaryMapExp<OP, TA, DType, etype> &t)
Check	include/mshadow/stream_gpu-inl.h	/^      utils::Check(err == CUBLAS_STATUS_SUCCESS, "Destory cublas handle failed");$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/stream_gpu-inl.h	/^      utils::Check(err == CUDNN_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUDNN_STATUS_SUCCESS, Ó)
Check	include/mshadow/stream_gpu-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "Create cublas handle failed");$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
Check	include/mshadow/stream_gpu-inl.h	/^    utils::Check(err == CUDNN_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUDNN_STATUS_SUCCESS, Ó)
Check	include/mshadow/stream_gpu-inl.h	/^    utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
Check	include/mshadow/stream_gpu-inl.h	/^  utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
Check	include/mshadow/tensor_blob.h	/^    utils::Check(Device::kDevMask == dev_mask_ && DataType<DType>::kFlag == type_flag_,$/;"	p	language:C++	class:mshadow::TBlob::utils	signature:(Device::kDevMask == dev_mask_ && DataType<DType>::kFlag == type_flag_, Ó)
Check	include/mshadow/tensor_blob.h	/^    utils::Check(dim == ndim_,$/;"	p	language:C++	class:mshadow::TShape::utils	signature:(dim == ndim_, Ó)
Check	include/mshadow/tensor_blob.h	/^    utils::Check(this->CheckContiguous(), "TBlob.get_reshape: must be contiguous");$/;"	p	language:C++	class:mshadow::TBlob::utils	signature:(this->CheckContiguous(), Ó)
Check	include/mshadow/tensor_blob.h	/^    utils::Check(this->shape_.Size() == shape.Size(),$/;"	p	language:C++	class:mshadow::TBlob::utils	signature:(this->shape_.Size() == shape.Size(), Ó)
Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(_dst.shape_ == _src.shape_, "Copy:shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(_dst.shape_ == _src.shape_, Ó)
Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(dst.shape_ == energy.shape_, "Softmax: shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(dst.shape_ == energy.shape_, Ó)
Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(eshape[0] == 0 || eshape == dshape,$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[0] == 0 || eshape == dshape, Ó)
Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(eshape[1] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[1] == dshape[0], Ó)
Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(eshape[dimkeep] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[dimkeep] == dshape[0], Ó)
Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(lhs.shape_ == rhs.shape_, "VDot: shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(lhs.shape_ == rhs.shape_, Ó)
Check	include/mshadow/tensor_gpu-inl.h	/^    utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(_dst.shape_ == _src.shape_, "Copy:shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(_dst.shape_ == _src.shape_, Ó)
Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(eshape[0] == 0 || eshape == dshape,$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[0] == 0 || eshape == dshape, Ó)
Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(eshape[1] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[1] == dshape[0], Ó)
Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(eshape[dimkeep] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[dimkeep] == dshape[0], Ó)
Check	include/mshadow/utils.h	/^inline void Check(bool exp, const char *fmt, ...) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(bool exp, const char *fmt, ...)
CheckAlign	include/mshadow/sse-inl.h	/^inline bool CheckAlign(size_t pitch) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(size_t pitch)
CheckAlign	include/mshadow/sse-inl.h	/^inline bool CheckAlign(void *ptr) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(void *ptr)
CheckContiguous	include/mshadow/tensor.h	/^  MSHADOW_XINLINE bool CheckContiguous(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
CheckContiguous	include/mshadow/tensor_blob.h	/^  inline bool CheckContiguous(void) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(void) const
CheckIdle	include/mshadow/stream_gpu-inl.h	/^  inline bool CheckIdle(void) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
CheckIdle	include/mshadow/tensor.h	/^  inline bool CheckIdle(void) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
CheckLaunchParam	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void CheckLaunchParam(dim3 dimGrid, dim3 dimBlock, const char *estr = "") {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(dim3 dimGrid, dim3 dimBlock, const char *estr = Ó)
CheckWeight	include/mshadow-ps/mshadow_ps.h	/^  inline void CheckWeight(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid)
CheckWeight_	include/mshadow-ps/mshadow_ps.h	/^  virtual void CheckWeight_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
CheckWeight_	include/mshadow-ps/ps_local-inl.h	/^  virtual void CheckWeight_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
Classifier	depparser/Classifier.cpp	/^Classifier::Classifier() {$/;"	f	language:C++	class:Classifier	signature:()
Classifier	depparser/Classifier.h	/^	Classifier();$/;"	p	language:C++	class:Classifier	access:public	signature:()
Classifier	depparser/Classifier.h	/^class Classifier {$/;"	c	language:C++
Classifier	tags	/^Classifier	depparser\/Classifier.h	\/^class Classifier {$\/;"	c	language:C++$/;"	c	language:C++	class:__anon1::__anon2	file:	access:private
Classifier::Classifier	depparser/Classifier.cpp	/^Classifier::Classifier() {$/;"	f	language:C++	class:Classifier	signature:()
Classifier::Classifier	depparser/Classifier.h	/^	Classifier();$/;"	p	language:C++	class:Classifier	access:public	signature:()
Classifier::~Classifier	depparser/Classifier.cpp	/^Classifier::~Classifier() {$/;"	f	language:C++	class:Classifier	signature:()
Classifier::~Classifier	depparser/Classifier.h	/^	virtual ~Classifier();$/;"	p	language:C++	class:Classifier	access:public	signature:()
ConcatExp	include/mshadow/extension/concat.h	/^  ConcatExp(const LhsExp &src1, const RhsExp &src2) : src1_(src1), src2_(src2) {$/;"	f	language:C++	struct:mshadow::expr::ConcatExp	access:public	signature:(const LhsExp &src1, const RhsExp &src2)
ConcatExp	include/mshadow/extension/concat.h	/^struct ConcatExp : public TRValue<ConcatExp<LhsExp, RhsExp,$/;"	s	language:C++	namespace:mshadow::expr	inherits:TRValue
ConditionVariable	include/mshadow-ps/thread.h	/^  friend class ConditionVariable;$/;"	x	language:C++
ConditionVariable	include/mshadow-ps/thread.h	/^class ConditionVariable {$/;"	c	language:C++	namespace:mshadow::utils
ConvBackWard	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  inline static void ConvBackWard(const Tensor<xpu, 4, real_t> &out,$/;"	f	language:C++	class:ConvNet	file:	access:private	signature:(const Tensor<xpu, 4, real_t> &out, const Tensor<xpu, 2, real_t> &kernel, Tensor<xpu, 2, real_t> &g_kernel, Tensor<xpu, 4, real_t> &in, int ksize, int kstride, TensorContainer<xpu, 2, real_t> &tmp_col, TensorContainer<xpu, 2, real_t> &tmp_dst)
ConvForward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  inline static void ConvForward(const Tensor<xpu, 4, real_t> &in,$/;"	f	language:C++	class:ConvNet	file:	access:private	signature:(const Tensor<xpu, 4, real_t> &in, const Tensor<xpu, 2, real_t> &kernel, Tensor<xpu, 4, real_t> &out, int ksize, int kstride, TensorContainer<xpu, 2, real_t> &tmp_col, TensorContainer<xpu, 2, real_t> &tmp_dst)
ConvNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  ConvNet(int batch_size, int insize, int nchannel, int ksize, int kstride, int psize, int num_out)$/;"	f	language:C++	class:ConvNet	access:public	signature:(int batch_size, int insize, int nchannel, int ksize, int kstride, int psize, int num_out)
ConvNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^class ConvNet : public INNet {$/;"	c	language:C++	file:	inherits:INNet
ConvNet::Backprop	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) {$/;"	f	language:C++	class:ConvNet	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
ConvNet::ConvBackWard	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  inline static void ConvBackWard(const Tensor<xpu, 4, real_t> &out,$/;"	f	language:C++	class:ConvNet	file:	access:private	signature:(const Tensor<xpu, 4, real_t> &out, const Tensor<xpu, 2, real_t> &kernel, Tensor<xpu, 2, real_t> &g_kernel, Tensor<xpu, 4, real_t> &in, int ksize, int kstride, TensorContainer<xpu, 2, real_t> &tmp_col, TensorContainer<xpu, 2, real_t> &tmp_dst)
ConvNet::ConvForward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  inline static void ConvForward(const Tensor<xpu, 4, real_t> &in,$/;"	f	language:C++	class:ConvNet	file:	access:private	signature:(const Tensor<xpu, 4, real_t> &in, const Tensor<xpu, 2, real_t> &kernel, Tensor<xpu, 4, real_t> &out, int ksize, int kstride, TensorContainer<xpu, 2, real_t> &tmp_col, TensorContainer<xpu, 2, real_t> &tmp_dst)
ConvNet::ConvNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  ConvNet(int batch_size, int insize, int nchannel, int ksize, int kstride, int psize, int num_out)$/;"	f	language:C++	class:ConvNet	access:public	signature:(int batch_size, int insize, int nchannel, int ksize, int kstride, int psize, int num_out)
ConvNet::Forward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Forward(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch) {$/;"	f	language:C++	class:ConvNet	access:public	signature:(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
ConvNet::Ki2h	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Ki2h.Resize(Shape2(nchannel, ksize*ksize));  g_Ki2h.Resize(Ki2h.shape_);$/;"	p	language:C++	file:	signature:(Ki2h.shape_)
ConvNet::Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Wh2o.Resize(Shape2(nflat.size(1), num_out));   g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(Wh2o.shape_)
ConvNet::Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    hbias.Resize(Shape1(nchannel)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(hbias.shape_)
ConvNet::Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	file:	signature:(nhidden.shape_)
ConvNet::Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npoolbak.Resize(npool.shape_);$/;"	p	language:C++	file:	signature:(npool.shape_)
ConvNet::Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    obias.Resize(Shape1(num_out));  g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(obias.shape_)
ConvNet::Shape1	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    hbias.Resize(Shape1(nchannel)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(nchannel)
ConvNet::Shape1	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    obias.Resize(Shape1(num_out));  g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(num_out)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Ki2h.Resize(Shape2(nchannel, ksize*ksize));  g_Ki2h.Resize(Ki2h.shape_);$/;"	p	language:C++	file:	signature:(nchannel, ksize*ksize)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Wh2o.Resize(Shape2(nflat.size(1), num_out));   g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(nflat.size(1), num_out)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nflat.Resize(Shape2(batch_size, npool.size(1)*npool.size(2)*npool.size(3)));$/;"	p	language:C++	file:	signature:(batch_size, npool.size(1)*npool.size(2)*npool.size(3))
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_col.Resize(Shape2(in.size(1) * ksize * ksize,$/;"	p	language:C++	file:	signature:(in.size(1) * ksize * ksize, nbatch * oheight * owidth)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_col.Resize(Shape2(in.size(1)*ksize*ksize, nbatch*oheight*owidth));$/;"	p	language:C++	file:	signature:(in.size(1)*ksize*ksize, nbatch*oheight*owidth)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_dst.Resize(Shape2(nchannel, nbatch * oheight * owidth));$/;"	p	language:C++	file:	signature:(nchannel, nbatch * oheight * owidth)
ConvNet::Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_dst.Resize(Shape2(nchannel, nbatch*oheight*owidth));$/;"	p	language:C++	file:	signature:(nchannel, nbatch*oheight*owidth)
ConvNet::Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhidden.Resize(Shape4(batch_size, nchannel, (insize - ksize)\/kstride+1, (insize -ksize)\/kstride+1));$/;"	p	language:C++	file:	signature:(batch_size, nchannel, (insize - ksize)/kstride+1, (insize -ksize)/kstride+1)
ConvNet::Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    ninput.Resize(Shape4(batch_size, 1, insize, insize));$/;"	p	language:C++	file:	signature:(batch_size, 1, insize, insize)
ConvNet::Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npool.Resize(Shape4(batch_size, nchannel, (nhidden.size(2)+1-psize)\/psize, (nhidden.size(3)+1-psize)\/psize));$/;"	p	language:C++	file:	signature:(batch_size, nchannel, (nhidden.size(2)+1-psize)/psize, (nhidden.size(3)+1-psize)/psize)
ConvNet::Update	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Update(void) {$/;"	f	language:C++	class:ConvNet	access:public	signature:(void)
ConvNet::Wh2o	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::batch_size	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
ConvNet::eta	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    const float eta = 0.1;$/;"	l	language:C++
ConvNet::g_Ki2h	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::g_Wh2o	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::g_hbias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::g_obias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::hbias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::ksize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize, kstride, psize;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::kstride	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize, kstride, psize;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::nbatch	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t nbatch   = in.size(0);$/;"	l	language:C++
ConvNet::nchannel	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t nchannel = out.size(1);$/;"	l	language:C++
ConvNet::nflat	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> nflat, nout;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::nhidden	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::nhiddenbak	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::ninput	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::nout	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> nflat, nout;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::npool	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::npoolbak	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::obias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::oheight	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t oheight  = (in.size(2) - ksize)\/kstride + 1;$/;"	l	language:C++
ConvNet::owidth	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t owidth   = (in.size(3) - ksize)\/kstride + 1;$/;"	l	language:C++
ConvNet::psize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize, kstride, psize;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::rnd	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Ki2h.set_stream(stream);  g_Ki2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Wh2o.set_stream(stream);   g_Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    hbias.set_stream(stream); g_hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nflat.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhidden.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    ninput.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nout.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npool.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npoolbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    obias.set_stream(stream);  g_obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_col.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_dst.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
ConvNet::stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Stream<xpu> *stream = NewStream<xpu>();$/;"	l	language:C++
ConvNet::tmp_col	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> tmp_col, tmp_dst;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::tmp_dst	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> tmp_col, tmp_dst;$/;"	m	language:C++	class:ConvNet	file:	access:private
ConvNet::wd	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    const float wd = 0.00001;$/;"	l	language:C++
ConvNet::~ConvNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual ~ConvNet() {}$/;"	f	language:C++	class:ConvNet	access:public	signature:()
Copy	include/mshadow-ps/ps_local-inl.h	/^    mshadow::Copy(e.weight, data, &s);$/;"	p	language:C++	class:mshadow::ps::LocalModel::mshadow	signature:(e.weight, data, &s)
Copy	include/mshadow-ps/ps_local-inl.h	/^    mshadow::Copy(tmp, data, &s);$/;"	p	language:C++	class:mshadow::ps::LocalModel::mshadow	signature:(tmp, data, &s)
Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<cpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> dst, const Tensor<cpu, dim, DType> &src, Stream<cpu> *stream = NULL)
Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<cpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream = NULL)
Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<cpu, dim, DType> &src, Stream<gpu> *stream = NULL)
Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream = NULL)
Copy	include/mshadow/tensor_cpu-inl.h	/^inline void Copy(Tensor<cpu, dim, DType> _dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> _dst, const Tensor<cpu, dim, DType> &_src, Stream<cpu> *stream)
Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<A, dim, DType> _dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<A, dim, DType> _dst, Tensor<B, dim, DType> _src, cudaMemcpyKind kind, Stream<gpu> *stream)
Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<cpu, dim, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream)
Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<cpu, dim, DType> &src, Stream<gpu> *stream)
Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream)
Copy	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::Copy(tmp, ts);$/;"	p	language:C++	class:mshadow	signature:(tmp, ts)
CopyFrom	include/mshadow/tensor_blob.h	/^  inline void CopyFrom(RandomAccessIterator begin,$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(RandomAccessIterator begin, RandomAccessIterator end)
CreateBlasHandle	include/mshadow/stream_gpu-inl.h	/^    st->CreateBlasHandle();$/;"	p	language:C++	signature:()
CreateBlasHandle	include/mshadow/stream_gpu-inl.h	/^  inline void CreateBlasHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
CreateBlasHandle	include/mshadow/tensor.h	/^  inline void CreateBlasHandle() {}$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
CreateDnnHandle	include/mshadow/stream_gpu-inl.h	/^    st->CreateDnnHandle();$/;"	p	language:C++	signature:()
CreateDnnHandle	include/mshadow/stream_gpu-inl.h	/^  inline void CreateDnnHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
CreateModelUpdater	include/mshadow-ps/mshadow_ps.h	/^IModelUpdater<DType> *CreateModelUpdater(void);$/;"	p	language:C++	namespace:mshadow::ps	signature:(void)
CreateModelUpdater	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^IModelUpdater<DType> *CreateModelUpdater(void) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(void)
CreateModelUpdater	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^IModelUpdater<float> *CreateModelUpdater(void) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(void)
CreateModelUpdater	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^IModelUpdater<float> *CreateModelUpdater(void) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(void)
CreateServerNode	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum.cpp	/^int CreateServerNode(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
CreateSharedModel	include/mshadow-ps/mshadow_ps.h	/^inline ISharedModel<xpu, DType> *CreateSharedModel(const char *type) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(const char *type)
CroppingExp	include/mshadow/extension/crop.h	/^  explicit CroppingExp(const SrcExp &src, Shape<2> cshape)$/;"	f	language:C++	struct:mshadow::expr::CroppingExp	access:public	signature:(const SrcExp &src, Shape<2> cshape)
CroppingExp	include/mshadow/extension/crop.h	/^  explicit CroppingExp(const SrcExp &src, Shape<2> cshape,$/;"	f	language:C++	struct:mshadow::expr::CroppingExp	access:public	signature:(const SrcExp &src, Shape<2> cshape, index_t start_height, index_t start_width)
CroppingExp	include/mshadow/extension/crop.h	/^struct CroppingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
DEPPARSER_ARC_STANDARD_STATE_H	depparser/State.h	9;"	d	language:C++
DEPPARSER_CLASSIFIER_H_	depparser/Classifier.h	9;"	d	language:C++
DEPPARSER_DEPACTION_H_	depparser/DepAction.h	9;"	d	language:C++
DEPPARSER_DEPPARSER_H_	depparser/Depparser.h	9;"	d	language:C++
DEPPARSER_DEPTREENODE_H_	depparser/DepTreeNode.h	9;"	d	language:C++
DEPPARSER_DEPTREE_H_	depparser/DepTree.h	9;"	d	language:C++
DEPPARSER_EXAMPLE_H_	depparser/Example.h	9;"	d	language:C++
DEPPARSER_GLOBALEXAMPLE_H_	depparser/GlobalExample.h	9;"	d	language:C++
DEP_OFFSET	depparser/Depparser.cpp	/^	int DEP_OFFSET = 36;$/;"	l	language:C++
DType	include/mshadow/sse-inl.h	/^  typedef __m128 DType;$/;"	t	language:C++	struct:mshadow::sse2::FVec	access:public
DType	include/mshadow/sse-inl.h	/^  typedef __m128d DType;$/;"	t	language:C++	struct:mshadow::sse2::FVec	access:public
DType	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
DType	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
DType	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
DType	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
DType	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
DType	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
DType	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
DType	tags	/^unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
DataType	include/mshadow/tensor_blob.h	/^struct DataType;$/;"	x	language:C++
DataType	include/mshadow/tensor_blob.h	/^struct DataType<double> {$/;"	s	language:C++	namespace:mshadow
DataType	include/mshadow/tensor_blob.h	/^struct DataType<float> {$/;"	s	language:C++	namespace:mshadow
DecodeUnlabeledAction	depparser/DepAction.h	/^DecodeUnlabeledAction(const unsigned & action) {$/;"	f	language:C++	signature:(const unsigned & action)
DeleteStream	include/mshadow/stream_gpu-inl.h	/^inline void DeleteStream<gpu>(Stream<gpu> *stream) {$/;"	f	language:C++	namespace:mshadow	signature:(Stream<gpu> *stream)
DeleteStream	include/mshadow/tensor.h	/^inline void DeleteStream(Stream<Device> *stream);$/;"	p	language:C++	namespace:mshadow	signature:(Stream<Device> *stream)
DeleteStream	include/mshadow/tensor_cpu-inl.h	/^inline void DeleteStream<cpu>(Stream<cpu> *stream) {$/;"	f	language:C++	namespace:mshadow	signature:(Stream<cpu> *stream)
DeleteStream	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  mshadow::DeleteStream(stream);$/;"	p	language:C++	class:mshadow	file:	signature:(stream)
DeleteStream	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::DeleteStream(stream);$/;"	p	language:C++	class:mshadow	signature:(stream)
DeleteStream	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::DeleteStream(stream);$/;"	p	language:C++	class:mshadow	signature:(stream)
DeleteStream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::DeleteStream(stream);$/;"	p	language:C++	class:NNet::mshadow	file:	signature:(stream)
DepParseInput	depparser/DepTree.h	/^typedef std::vector<std::pair<std::string, std::string>> DepParseInput;$/;"	t	language:C++
DepTree	depparser/DepTree.h	/^	DepTree(){$/;"	f	language:C++	class:DepTree	access:public	signature:()
DepTree	depparser/DepTree.h	/^	DepTree(DepParseInput input){$/;"	f	language:C++	class:DepTree	access:public	signature:(DepParseInput input)
DepTree	depparser/DepTree.h	/^class DepTree{$/;"	c	language:C++
DepTree::DepTree	depparser/DepTree.h	/^	DepTree(){$/;"	f	language:C++	class:DepTree	access:public	signature:()
DepTree::DepTree	depparser/DepTree.h	/^	DepTree(DepParseInput input){$/;"	f	language:C++	class:DepTree	access:public	signature:(DepParseInput input)
DepTree::node	depparser/DepTree.h	/^			is >> node;$/;"	l	language:C++
DepTree::node	depparser/DepTree.h	/^		DepTreeNode node();$/;"	p	language:C++	signature:()
DepTree::node	depparser/DepTree.h	/^		DepTreeNode node(root, root);$/;"	p	language:C++	signature:(root, root)
DepTree::node	depparser/DepTree.h	/^		is >> node;$/;"	l	language:C++
DepTree::nodes	depparser/DepTree.h	/^			os << nodes[i];$/;"	l	language:C++
DepTree::nodes	depparser/DepTree.h	/^	std::vector<DepTreeNode> nodes;$/;"	m	language:C++	class:DepTree	access:private
DepTree::operator <<	depparser/DepTree.h	/^	inline std::ostream & operator << (std::ostream &os, const DepTree &tree) {$/;"	f	language:C++	class:DepTree	access:public	signature:(std::ostream &os, const DepTree &tree)
DepTree::operator >>	depparser/DepTree.h	/^	inline std::istream & operator >> (std::istream &is, DepTree &tree) {$/;"	f	language:C++	class:DepTree	access:public	signature:(std::istream &is, DepTree &tree)
DepTree::push_back	depparser/DepTree.h	/^			nodes.push_back(node);$/;"	p	language:C++	signature:(node)
DepTree::push_back	depparser/DepTree.h	/^		nodes.push_back(node);$/;"	p	language:C++	signature:(node)
DepTree::push_back	depparser/DepTree.h	/^		nodes.push_back(rootnode);$/;"	p	language:C++	signature:(rootnode)
DepTree::rootnode	depparser/DepTree.h	/^		DepTreeNode rootnode(root, root);$/;"	p	language:C++	signature:(root, root)
DepTree::setHead	depparser/DepTree.h	/^	inline void setHead(int child, int head){ nodes[child].head = head; }$/;"	f	language:C++	class:DepTree	access:public	signature:(int child, int head)
DepTree::setLabel	depparser/DepTree.h	/^	inline void setLabel(int child, std::string label){ nodes[child].label = label; }$/;"	f	language:C++	class:DepTree	access:public	signature:(int child, std::string label)
DepTree::size	depparser/DepTree.h	/^	int size;$/;"	m	language:C++	class:DepTree	access:public
DepTree::std::endl	depparser/DepTree.h	/^		os << std::endl;$/;"	m	language:C++	class:DepTree::std
DepTree::~DepTree	depparser/DepTree.h	/^	~DepTree(){}$/;"	f	language:C++	class:DepTree	access:public	signature:()
DepTreeNode	depparser/DepTreeNode.h	/^	DepTreeNode() {head = -1;}$/;"	f	language:C++	class:DepTreeNode	access:public	signature:()
DepTreeNode	depparser/DepTreeNode.h	/^	DepTreeNode(std::string w, std::string t){$/;"	f	language:C++	class:DepTreeNode	access:public	signature:(std::string w, std::string t)
DepTreeNode	depparser/DepTreeNode.h	/^class DepTreeNode {$/;"	c	language:C++
DepTreeNode::DepTreeNode	depparser/DepTreeNode.h	/^	DepTreeNode() {head = -1;}$/;"	f	language:C++	class:DepTreeNode	access:public	signature:()
DepTreeNode::DepTreeNode	depparser/DepTreeNode.h	/^	DepTreeNode(std::string w, std::string t){$/;"	f	language:C++	class:DepTreeNode	access:public	signature:(std::string w, std::string t)
DepTreeNode::head	depparser/DepTreeNode.h	/^	int head;$/;"	m	language:C++	class:DepTreeNode	access:public
DepTreeNode::iss_id	depparser/DepTreeNode.h	/^	   std::istringstream iss_id(line);$/;"	p	language:C++	signature:(line)
DepTreeNode::label	depparser/DepTreeNode.h	/^	std::string label;$/;"	m	language:C++	class:DepTreeNode	access:public
DepTreeNode::line	depparser/DepTreeNode.h	/^	   std::string line;$/;"	l	language:C++
DepTreeNode::operator <<	depparser/DepTreeNode.h	/^	inline std::ostream & operator << (std::ostream &os, const DepTreeNode &node) {$/;"	f	language:C++	class:DepTreeNode	access:public	signature:(std::ostream &os, const DepTreeNode &node)
DepTreeNode::operator >>	depparser/DepTreeNode.h	/^	inline std::istream & operator >> (std::istream &is, DepTreeNode &node) {$/;"	f	language:C++	class:DepTreeNode	access:public	signature:(std::istream &is, DepTreeNode &node)
DepTreeNode::tag	depparser/DepTreeNode.h	/^	std::string tag;$/;"	m	language:C++	class:DepTreeNode	access:public
DepTreeNode::word	depparser/DepTreeNode.h	/^	std::string word;$/;"	m	language:C++	class:DepTreeNode	access:public
DepTreeNode::~DepTreeNode	depparser/DepTreeNode.h	/^	virtual ~DepTreeNode(){}$/;"	f	language:C++	class:DepTreeNode	access:public	signature:()
Depparser	depparser/Depparser.cpp	/^Depparser::Depparser(bool bTrain) {$/;"	f	language:C++	class:Depparser	signature:(bool bTrain)
Depparser	depparser/Depparser.h	/^	Depparser();$/;"	p	language:C++	class:Depparser	access:public	signature:()
Depparser	depparser/Depparser.h	/^	Depparser(bool bTrain);$/;"	p	language:C++	class:Depparser	access:public	signature:(bool bTrain)
Depparser	depparser/Depparser.h	/^class Depparser {$/;"	c	language:C++
Depparser::Depparser	depparser/Depparser.cpp	/^Depparser::Depparser(bool bTrain) {$/;"	f	language:C++	class:Depparser	signature:(bool bTrain)
Depparser::Depparser	depparser/Depparser.h	/^	Depparser();$/;"	p	language:C++	class:Depparser	access:public	signature:()
Depparser::Depparser	depparser/Depparser.h	/^	Depparser(bool bTrain);$/;"	p	language:C++	class:Depparser	access:public	signature:(bool bTrain)
Depparser::bEarlyUpdate	depparser/Depparser.h	/^	bool bEarlyUpdate = true;$/;"	m	language:C++	class:Depparser	access:private
Depparser::beamSize	depparser/Depparser.h	/^	int beamSize;$/;"	m	language:C++	class:Depparser	access:private
Depparser::depLabels	depparser/Depparser.h	/^	Dict depLabels;$/;"	m	language:C++	class:Depparser	access:private
Depparser::featureExtract	depparser/Depparser.cpp	/^void Depparser::featureExtract(State* state, std::vector<int>& wordIndexCache,$/;"	f	language:C++	class:Depparser	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector<int> & features)
Depparser::featureExtract	depparser/Depparser.h	/^	void featureExtract(State* state, std::vector<int>& wordIndexCache,$/;"	p	language:C++	class:Depparser	access:public	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector<int>& features)
Depparser::featureNum	depparser/Depparser.h	/^	static int featureNum = 48;$/;"	m	language:C++	class:Depparser	access:private
Depparser::gExamples	depparser/Depparser.h	/^	std::vector<GlobalExample> gExamples;$/;"	m	language:C++	class:Depparser	access:private
Depparser::generateTrainingExamples	depparser/Depparser.cpp	/^void Depparser::generateTrainingExamples(std::vector<DepParseInput> inputs,$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
Depparser::generateTrainingExamples	depparser/Depparser.h	/^	void generateTrainingExamples(std::vector<DepParseInput> inputs,$/;"	p	language:C++	class:Depparser	access:private	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
Depparser::getDictionaries	depparser/Depparser.cpp	/^void Depparser::getDictionaries(std::vector<DepTree> goldTrees) {$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepTree> goldTrees)
Depparser::getDictionaries	depparser/Depparser.h	/^	void getDictionaries(std::vector<DepTree> goldTrees);$/;"	p	language:C++	class:Depparser	access:private	signature:(std::vector<DepTree> goldTrees)
Depparser::getInputBatch	depparser/Depparser.cpp	/^void Depparser::getInputBatch(State* state, std::vector<int>& wordIndexCache,$/;"	f	language:C++	class:Depparser	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector<std::vector<int> >& featvecs)
Depparser::getInputBatch	depparser/Depparser.h	/^	void getInputBatch(State* state, std::vector<int>& wordIndexCache,$/;"	p	language:C++	class:Depparser	access:private	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector< std::vector<int> >& features)
Depparser::getLabel	depparser/Depparser.h	/^	inline int getLabel(std::string s) {$/;"	f	language:C++	class:Depparser	access:private	signature:(std::string s)
Depparser::getLabelIndex	depparser/Depparser.h	/^	inline int getLabelIndex(int index, State* state){$/;"	f	language:C++	class:Depparser	access:private	signature:(int index, State* state)
Depparser::getTag	depparser/Depparser.h	/^	inline int getTag(std::string s) {$/;"	f	language:C++	class:Depparser	access:private	signature:(std::string s)
Depparser::getTagIndex	depparser/Depparser.h	/^	inline int getTagIndex(int index, std::vector<int> list){$/;"	f	language:C++	class:Depparser	access:private	signature:(int index, std::vector<int> list)
Depparser::getWord	depparser/Depparser.h	/^	inline int getWord(std::string s) {$/;"	f	language:C++	class:Depparser	access:private	signature:(std::string s)
Depparser::getWordIndex	depparser/Depparser.h	/^	inline int getWordIndex(int index, std::vector<int> list){$/;"	f	language:C++	class:Depparser	access:private	signature:(int index, std::vector<int> list)
Depparser::got	depparser/Depparser.h	/^		auto got = labelMap.find(s);$/;"	l	language:C++
Depparser::got	depparser/Depparser.h	/^		auto got = tagMap.find(s);$/;"	l	language:C++
Depparser::got	depparser/Depparser.h	/^		auto got = wordMap.find(s);$/;"	l	language:C++
Depparser::init	depparser/Depparser.cpp	/^void Depparser::init(std::vector<DepParseInput> inputs,$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
Depparser::init	depparser/Depparser.h	/^	void init(std::vector<DepParseInput> inputs,$/;"	p	language:C++	class:Depparser	access:public	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
Depparser::insertBeam	depparser/Depparser.h	/^	inline int insertBeam(const CScoredTransition& transition, CScoredTransition* beamTransitsint,$/;"	f	language:C++	class:Depparser	access:private	signature:(const CScoredTransition& transition, CScoredTransition* beamTransitsint, int currentBeamSize = beamSize)
Depparser::knowLabels	depparser/Depparser.h	/^	std::vector<std::string> knowLabels;$/;"	m	language:C++	class:Depparser	access:private
Depparser::knowTags	depparser/Depparser.h	/^	std::vector<std::string> knowTags;$/;"	m	language:C++	class:Depparser	access:private
Depparser::knowWords	depparser/Depparser.h	/^	std::vector<std::string> knowWords;$/;"	m	language:C++	class:Depparser	access:private
Depparser::labelMap	depparser/Depparser.h	/^	std::unordered_map<std::string, int> labelMap;$/;"	m	language:C++	class:Depparser	access:private
Depparser::labelNullIdx	depparser/Depparser.h	/^	static int labelNullIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::labelNum	depparser/Depparser.h	/^	const int labelNum;$/;"	m	language:C++	class:Depparser	access:private
Depparser::m_bTrain	depparser/Depparser.h	/^	bool m_bTrain;$/;"	m	language:C++	class:Depparser	access:private
Depparser::parse	depparser/Depparser.cpp	/^void Depparser::parse(std::vector<DepParseInput> inputs) {$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs)
Depparser::parse	depparser/Depparser.h	/^	void parse(std::vector<DepParseInput> inputs);$/;"	p	language:C++	class:Depparser	access:public	signature:(std::vector<DepParseInput> inputs)
Depparser::std::pop_heap	depparser/Depparser.h	/^		      std::pop_heap(beamTransitsint, beamTransitsint + beamSize,$/;"	p	language:C++	class:Depparser::std	signature:(beamTransitsint, beamTransitsint + beamSize, ScoredTransitionMore)
Depparser::std::push_heap	depparser/Depparser.h	/^		      std::push_heap(beamTransitsint, beamTransitsint+ beamSize,$/;"	p	language:C++	class:Depparser::std	signature:(beamTransitsint, beamTransitsint+ beamSize, ScoredTransitionMore)
Depparser::std::push_heap	depparser/Depparser.h	/^		std::push_heap(currentBeamSize,$/;"	p	language:C++	class:Depparser::std	signature:(currentBeamSize, currentBeamSize + currentBeamSize + 1, ScoredTransitionMore)
Depparser::tagMap	depparser/Depparser.h	/^	std::unordered_map<std::string, int> tagMap;$/;"	m	language:C++	class:Depparser	access:private
Depparser::tagNullIdx	depparser/Depparser.h	/^	static int tagNullIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::tagRootIdx	depparser/Depparser.h	/^	static int tagRootIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::tagUnkIdx	depparser/Depparser.h	/^	static int tagUnkIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::train	depparser/Depparser.cpp	/^void Depparser::train(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees,$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees, std::vector<DepParseInput> devInputs, std::vector<DepTree> devTrees)
Depparser::train	depparser/Depparser.h	/^	void train(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees,$/;"	p	language:C++	class:Depparser	access:public	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees, std::vector<DepParseInput> devInputs, std::vector<DepTree> devTrees)
Depparser::wordMap	depparser/Depparser.h	/^	std::unordered_map<std::string, int> wordMap;$/;"	m	language:C++	class:Depparser	access:private
Depparser::wordNullIdx	depparser/Depparser.h	/^	static int wordNullIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::wordRootIdx	depparser/Depparser.h	/^	static int wordRootIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::wordUnkIdx	depparser/Depparser.h	/^	static int wordUnkIdx;$/;"	m	language:C++	class:Depparser	access:private
Depparser::~Depparser	depparser/Depparser.cpp	/^Depparser::~Depparser() {$/;"	f	language:C++	class:Depparser	signature:()
Depparser::~Depparser	depparser/Depparser.h	/^	virtual ~Depparser();$/;"	p	language:C++	class:Depparser	access:public	signature:()
DestoryBlasHandle	include/mshadow/stream_gpu-inl.h	/^  inline void DestoryBlasHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
DestoryBlasHandle	include/mshadow/stream_gpu-inl.h	/^  stream->DestoryBlasHandle();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^        pull_queues[i].Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^        push_queues[i].Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^      pull_map.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^      push_lock.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^      push_map.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^      request_lock.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^      wait_cond.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^      wait_lock.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_local-inl.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(void)
Destroy	include/mshadow-ps/ps_rabit-inl.h	/^      reduce_queue_.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/ps_rabit-inl.h	/^    Parent::Destroy();$/;"	p	language:C++	class:mshadow::ps::RabitModel::Parent	signature:()
Destroy	include/mshadow-ps/thread.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
Destroy	include/mshadow-ps/thread.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
Destroy	include/mshadow-ps/thread.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(void)
Destroy	include/mshadow-ps/thread_util.h	/^    counter_.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/thread_util.h	/^    lock_.Destroy();$/;"	p	language:C++	signature:()
Destroy	include/mshadow-ps/thread_util.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(void)
Destroy	include/mshadow-ps/thread_util.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(void)
DestroyDnnHandle	include/mshadow/stream_gpu-inl.h	/^  inline void DestroyDnnHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
DestroyDnnHandle	include/mshadow/stream_gpu-inl.h	/^  stream->DestroyDnnHandle();$/;"	p	language:C++	signature:()
Dict	include/Dict.h	/^	Dict(){$/;"	f	language:C++	class:Dict	access:public	signature:()
Dict	include/Dict.h	/^	Dict(std::vector<std::string> wordlist){$/;"	f	language:C++	class:Dict	access:public	signature:(std::vector<std::string> wordlist)
Dict	include/Dict.h	/^class Dict {$/;"	c	language:C++
Dict::Dict	include/Dict.h	/^	Dict(){$/;"	f	language:C++	class:Dict	access:public	signature:()
Dict::Dict	include/Dict.h	/^	Dict(std::vector<std::string> wordlist){$/;"	f	language:C++	class:Dict	access:public	signature:(std::vector<std::string> wordlist)
Dict::Size	include/Dict.h	/^	inline int Size(){$/;"	f	language:C++	class:Dict	access:public	signature:()
Dict::clear	include/Dict.h	/^		map.clear();$/;"	p	language:C++	signature:()
Dict::getIndex	include/Dict.h	/^	inline int getIndex(string word){$/;"	f	language:C++	class:Dict	access:public	signature:(string word)
Dict::getWord	include/Dict.h	/^	inline string getWord(int index){$/;"	f	language:C++	class:Dict	access:public	signature:(int index)
Dict::got	include/Dict.h	/^		auto got = map.find(word);$/;"	l	language:C++
Dict::index	include/Dict.h	/^		int index = 0;$/;"	l	language:C++
Dict::load	include/Dict.h	/^	void load(vector<string> wordlist){$/;"	f	language:C++	class:Dict	access:public	signature:(vector<string> wordlist)
Dict::map	include/Dict.h	/^	unordered_map<string, int> map;$/;"	m	language:C++	class:Dict	access:private
Dict::words	include/Dict.h	/^	vector<string> words;$/;"	m	language:C++	class:Dict	access:private
Dict::~Dict	include/Dict.h	/^	virtual ~Dict(){};$/;"	f	language:C++	class:Dict	access:public	signature:()
DistModel	include/mshadow-ps/ps_dist-inl.h	/^class DistModel : public LocalModel<xpu, DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:LocalModel
DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine {$/;"	s	language:C++	namespace:mshadow::expr
DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine<SV, xpu, 1, 1, 2, false, transpose_right, DType> {$/;"	s	language:C++	namespace:mshadow::expr
DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine<SV, xpu, 2, 1, 1, true, false, DType> {$/;"	s	language:C++	namespace:mshadow::expr
DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine<SV, xpu, 2, 2, 2, transpose_left, transpose_right, DType> {$/;"	s	language:C++	namespace:mshadow::expr
DotExp	include/mshadow/expression.h	/^  explicit DotExp(const TA &lhs, const TB &rhs, DType scale)$/;"	f	language:C++	struct:mshadow::expr::DotExp	access:public	signature:(const TA &lhs, const TB &rhs, DType scale)
DotExp	include/mshadow/expression.h	/^struct DotExp: public Exp<DotExp<TA, TB, ltrans, rtrans, DType>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
EShape	include/mshadow/tensor_cpu-inl.h	/^  typedef Shape<expr::ExpInfo<E>::kDim> EShape;$/;"	t	language:C++
EShape	include/mshadow/tensor_gpu-inl.h	/^  typedef Shape<expr::ExpInfo<E>::kDim> EShape;$/;"	t	language:C++
EncodeAction	depparser/DepAction.h	/^EncodeAction(const StackActions & action,$/;"	f	language:C++	signature:(const StackActions & action, const int & label = 0)
Entry	include/mshadow-ps/thread_util.h	/^      pqueue_.push(Entry(data, priority));$/;"	p	language:C++	signature:(data, priority)
Entry	include/mshadow-ps/thread_util.h	/^    Entry(const DType &data, int priority)$/;"	f	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public	signature:(const DType &data, int priority)
Entry	include/mshadow-ps/thread_util.h	/^  struct Entry {$/;"	s	language:C++	class:mshadow::utils::ThreadPQueue	access:private
Error	include/mshadow/utils.h	/^inline void Error(const char *fmt, ...) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(const char *fmt, ...)
Error_All_Tensor_in_Exp_Must_Have_Same_Type	include/mshadow/expr_engine-inl.h	/^  inline static void Error_All_Tensor_in_Exp_Must_Have_Same_Type(void) {}$/;"	f	language:C++	struct:mshadow::expr::TypeCheckPass	access:public	signature:(void)
Error_All_Tensor_in_Exp_Must_Have_Same_Type	include/mshadow/tensor_cpu-inl.h	/^      ::Error_All_Tensor_in_Exp_Must_Have_Same_Type();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Error_All_Tensor_in_Exp_Must_Have_Same_Type	include/mshadow/tensor_gpu-inl.h	/^      ::Error_All_Tensor_in_Exp_Must_Have_Same_Type();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/expr_engine-inl.h	/^  inline static void Error_Expression_Does_Not_Meet_Dimension_Req(void) {}$/;"	f	language:C++	struct:mshadow::expr::TypeCheckPass	access:public	signature:(void)
Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/concat.h	/^      ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/pack_col2patch.h	/^      ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/reduceto1d.h	/^        ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::ExpComplexEngine::TypeCheckPass	signature:()
Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/reduceto1d.h	/^      ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Error_TypeCheck_Not_Pass_For_Reduce_Exp	include/mshadow/expr_engine-inl.h	/^  inline static void Error_TypeCheck_Not_Pass_For_Reduce_Exp(void) {}$/;"	f	language:C++	struct:mshadow::expr::TypeCheckPass	access:public	signature:(void)
Error_TypeCheck_Not_Pass_For_Reduce_Exp	include/mshadow/tensor_cpu-inl.h	/^      ::Error_TypeCheck_Not_Pass_For_Reduce_Exp();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Error_TypeCheck_Not_Pass_For_Reduce_Exp	include/mshadow/tensor_gpu-inl.h	/^      ::Error_TypeCheck_Not_Pass_For_Reduce_Exp();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
Eval	include/mshadow/dot_engine-inl.h	/^                DType>::Eval(dst, lhs.FlatTo2D(), rhs.FlatTo2D(), scale);$/;"	p	language:C++	class:mshadow::expr::DotEngine::DotEngine	signature:(dst, lhs.FlatTo2D(), rhs.FlatTo2D(), scale)
Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<Device, ddim, DType> *p_dst,$/;"	p	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<Device, ddim, DType> *p_dst, const Tensor<Device, ldim, DType> &lhs, const Tensor<Device, rdim, DType> &rhs, DType scale)
Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<xpu, 1, DType> *p_dst,$/;"	f	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<xpu, 1, DType> *p_dst, const Tensor<xpu, 1, DType> &lhs, const Tensor<xpu, 2, DType> &rhs, DType scale)
Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<xpu, 2, DType> *p_dst,$/;"	f	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<xpu, 2, DType> *p_dst, const Tensor<xpu, 1, DType> &lhs, const Tensor<xpu, 1, DType> &rhs, DType scale)
Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<xpu, 2, DType> *p_dst,$/;"	f	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<xpu, 2, DType> *p_dst, const Tensor<xpu, 2, DType> &lhs, const Tensor<xpu, 2, DType> &rhs, DType scale)
Eval	include/mshadow/expr_engine-inl.h	/^              ltrans, rtrans, DType>::Eval(dst, exp.lhs_, exp.rhs_, exp.scale_);$/;"	p	language:C++	class:mshadow::expr::ExpComplexEngine::DotEngine	signature:(dst, exp.lhs_, exp.rhs_, exp.scale_)
Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const;$/;"	p	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DstDType Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE const DType &Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst, const E &exp);$/;"	p	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(RV *dst, const E &exp)
Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kChainer> &exp)
Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kComplex> &exp)
Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kMapper> &exp)
Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kRValue> &exp)
Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(Tensor<Device, dim, DType> *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(Tensor<Device, dim, DType> *dst, const DotExp<Tensor<Device, ldim, DType>, Tensor<Device, rdim, DType>, ltrans, rtrans, DType> &exp)
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::divto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::divto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::minusto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::minusto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::multo, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::multo, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::plusto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::plusto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::saveto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
Eval	include/mshadow/expression.h	/^    ExpEngine<sv::saveto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
Eval	include/mshadow/extension/channel_pool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/channel_unpool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/extension/crop.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/mirror.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/pack_col2patch.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/pad.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/reduceto1d.h	/^  inline static void Eval(Tensor<Device, 1, DType> *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(Tensor<Device, 1, DType> *dst, const ReduceTo1DExp<SrcExp, DType, Reducer, 1> &exp)
Eval	include/mshadow/extension/reduceto1d.h	/^  inline static void Eval(Tensor<Device, 1, DType> *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(Tensor<Device, 1, DType> *dst, const ReduceTo1DExp<SrcExp, DType, Reducer, m_dimkeep> &exp)
Eval	include/mshadow/extension/reshape.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/extension/spatial_pool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/spatial_unpool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/swapaxis.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/extension/swapaxis.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t x) const
Eval	include/mshadow/extension/unpack_patch2col.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
Eval	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
Eval	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE DType Eval(index_t y, index_t x) const;$/;"	p	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
Eval	tags	/^Eval	include\/mshadow\/extension\/swapaxis.h	\/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const$/;"	f	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	access:public	signature:(index_t i, index_t j) const
Eval	tags	/^Eval	include\/mshadow\/extension\/swapaxis.h	\/^  MSHADOW_XINLINE DType Eval(index_t i, index_t x) const {$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t x) const$/;"	f	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	access:public	signature:(index_t i, index_t x) const
Eval	tags	/^Eval	include\/mshadow\/extension\/unpack_patch2col.h	\/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const$/;"	f	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	access:public	signature:(index_t i, index_t j) const
EvalSSE	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE sse2::FVec<DType> EvalSSE(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
EvalSSE	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE sse2::FVec<DType> EvalSSE(index_t y, index_t x) const;$/;"	p	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
Example	depparser/Example.h	/^	Example(std::vector<int> &f, std::vector<int> &l){$/;"	f	language:C++	class:Example	access:public	signature:(std::vector<int> &f, std::vector<int> &l)
Example	depparser/Example.h	/^class Example {$/;"	c	language:C++
Example::Example	depparser/Example.h	/^	Example(std::vector<int> &f, std::vector<int> &l){$/;"	f	language:C++	class:Example	access:public	signature:(std::vector<int> &f, std::vector<int> &l)
Example::features	depparser/Example.h	/^	std::vector<int> features;$/;"	m	language:C++	class:Example	access:public
Example::labels	depparser/Example.h	/^	std::vector<int> labels;$/;"	m	language:C++	class:Example	access:public
Example::~Example	depparser/Example.h	/^	virtual ~Example(){$/;"	f	language:C++	class:Example	access:public	signature:()
ExampleSigmoid	thirdparty/mshadow/guide/README.md	/^void ExampleSigmoid(Tensor<xpu, 2> out, const Tensor<xpu, 2> &in) {$/;"	f	language:C++	signature:(Tensor<xpu, 2> out, const Tensor<xpu, 2> &in)
Exp	include/mshadow/expression.h	/^struct Exp {$/;"	s	language:C++	namespace:mshadow::expr
ExpComplexEngine	include/mshadow/expr_engine-inl.h	/^struct ExpComplexEngine {$/;"	s	language:C++	namespace:mshadow::expr
ExpComplexEngine	include/mshadow/expr_engine-inl.h	/^struct ExpComplexEngine<SV,$/;"	s	language:C++	namespace:mshadow::expr
ExpComplexEngine	include/mshadow/extension/reduceto1d.h	/^struct ExpComplexEngine<SV,$/;"	s	language:C++	namespace:mshadow::expr
ExpEngine	include/mshadow/expr_engine-inl.h	/^struct ExpEngine {$/;"	s	language:C++	namespace:mshadow::expr
ExpEngine	include/mshadow/expression.h	/^struct ExpEngine;$/;"	x	language:C++
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo< ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<MakeTensorExp<T, SrcExp, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<Tensor<Device, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<TransposeExp<E, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<TypecastExp<DstDType, SrcDType, EType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
F	include/mshadow/expr_scalar-inl.h	/^F(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
F	include/mshadow/expr_scalar-inl.h	/^F(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
F	include/mshadow/expression.h	/^F(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
F	include/mshadow/expression.h	/^F(const Exp<TA, DType, ta> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &src)
FVec	include/mshadow/sse-inl.h	/^  FVec(void) {}$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(void)
FVec	include/mshadow/sse-inl.h	/^  explicit FVec(DType data) : data_(data) {}$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(DType data)
FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const double &s) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const double &s)
FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const double *src) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const double *src)
FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const float &s) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const float &s)
FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const float *src) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const float *src)
FVec	include/mshadow/sse-inl.h	/^struct FVec {$/;"	s	language:C++	namespace:mshadow::sse2
FVec	include/mshadow/sse-inl.h	/^struct FVec<double> {$/;"	s	language:C++	namespace:mshadow::sse2
FVec	include/mshadow/sse-inl.h	/^struct FVec<float> {$/;"	s	language:C++	namespace:mshadow::sse2
FeatureEmbedding	include/FeatureEmbedding.h	/^	FeatureEmbedding(int featureNum, int embeddingSize, int beamSize){$/;"	f	language:C++	class:FeatureEmbedding	access:public	signature:(int featureNum, int embeddingSize, int beamSize)
FeatureEmbedding	include/FeatureEmbedding.h	/^class FeatureEmbedding {$/;"	c	language:C++
FeatureEmbedding::FeatureEmbedding	include/FeatureEmbedding.h	/^	FeatureEmbedding(int featureNum, int embeddingSize, int beamSize){$/;"	f	language:C++	class:FeatureEmbedding	access:public	signature:(int featureNum, int embeddingSize, int beamSize)
FeatureEmbedding::SampleGuassian	include/FeatureEmbedding.h	/^		rnd.SampleGuassian( featEmbeddings, 0, CConfig::fInitRange );$/;"	p	language:C++	signature:( featEmbeddings, 0, CConfig::fInitRange )
FeatureEmbedding::Shape2	include/FeatureEmbedding.h	/^		featEmbeddings.Resize( Shape2( featureNum, embeddingSize ) );$/;"	p	language:C++	signature:(featureNum, embeddingSize )
FeatureEmbedding::Shape2	include/FeatureEmbedding.h	/^		input.Resize( Shape2( beamSize, inputSize ) );$/;"	p	language:C++	signature:(beamSize, inputSize )
FeatureEmbedding::beamSize	include/FeatureEmbedding.h	/^	int beamSize;$/;"	m	language:C++	class:FeatureEmbedding	access:public
FeatureEmbedding::featEmbeddings	include/FeatureEmbedding.h	/^	TensorContainer<xpu,2> featEmbeddings;$/;"	m	language:C++	class:FeatureEmbedding	access:public
FeatureEmbedding::inputIndex	include/FeatureEmbedding.h	/^			int inputIndex = 0;$/;"	l	language:C++
FeatureEmbedding::inputSize	include/FeatureEmbedding.h	/^	int inputSize;$/;"	m	language:C++	class:FeatureEmbedding	access:public
FeatureEmbedding::returnInput	include/FeatureEmbedding.h	/^	void returnInput(std::vector< std::vector<int> >& featVecs, TensorContainer<xpu, 2>& input){$/;"	f	language:C++	class:FeatureEmbedding	access:public	signature:(std::vector< std::vector<int> >& featVecs, TensorContainer<xpu, 2>& input)
FeatureEmbedding::rnd	include/FeatureEmbedding.h	/^	Random<xpu> rnd;$/;"	m	language:C++	class:FeatureEmbedding	access:public
FeatureEmbedding::~FeatureEmbedding	include/FeatureEmbedding.h	/^	virtual ~FeatureEmbedding(){$/;"	f	language:C++	class:FeatureEmbedding	access:public	signature:()
Finalize	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  rabit::Finalize();$/;"	p	language:C++	class:rabit	signature:()
FlatTo2D	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape<2> FlatTo2D(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
FlatTo2D	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor<Device, 2, DType> FlatTo2D(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
FlatTo2D	include/mshadow/tensor_blob.h	/^  inline Shape<2> FlatTo2D(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
FlatTo2D	include/mshadow/tensor_blob.h	/^  inline Tensor<Device, 2, DType> FlatTo2D(Stream<Device> *stream = NULL) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(Stream<Device> *stream = NULL) const
FlatTo2D	include/mshadow/tensor_gpu-inl.h	/^                       dshape.FlatTo2D(),$/;"	p	language:C++	signature:()
Forward	depparser/Depparser.cpp	/^					net->Forward(input, pred);$/;"	p	language:C++	file:	signature:(input, pred)
Forward	include/NNet.h	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch,$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
Forward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^      net->Forward(xtest.Slice(j, j + batch_size), pred);$/;"	p	language:C++	file:	signature:(xtest.Slice(j, j + batch_size), pred)
Forward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^      net->Forward(xtrain.Slice(j, j + batch_size), pred);$/;"	p	language:C++	file:	signature:(xtrain.Slice(j, j + batch_size), pred)
Forward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Forward(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
Forward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Forward(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch) {$/;"	f	language:C++	class:ConvNet	access:public	signature:(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
Forward	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^      net->Forward(xtest.Slice(j, j + batch_size), pred);$/;"	p	language:C++	file:	signature:(xtest.Slice(j, j + batch_size), pred)
Forward	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^      net->Forward(xtrain.Slice(j, j + batch_size), pred);$/;"	p	language:C++	file:	signature:(xtrain.Slice(j, j + batch_size), pred)
Forward	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
Forward	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch,$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
Forward	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^        nets[tid]->Forward(xtest.Slice(j + tid * step, j + (tid + 1) * step), pred);$/;"	p	language:C++	file:	signature:(xtest.Slice(j + tid * step, j + (tid + 1) * step), pred)
Forward	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^        nets[tid]->Forward(xtrain.Slice(j + tid * step, j + (tid + 1) * step), pred);$/;"	p	language:C++	file:	signature:(xtrain.Slice(j + tid * step, j + (tid + 1) * step), pred)
Forward	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t> &inbatch,$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t> &inbatch, Tensor<cpu, 2, real_t> &oubatch)
Forward	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch,$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
Free	include/Pool.cpp	/^void CPool::Free()$/;"	f	language:C++	class:CPool	signature:()
Free	include/Pool.h	/^	void Free();$/;"	p	language:C++	class:CPool	access:public	signature:()
FreeHost	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost(Tensor<cpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
FreeHost_	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost_(void * dptr);$/;"	p	language:C++	namespace:mshadow	signature:(void * dptr)
FreeHost_	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost_<cpu>(void *dptr) {$/;"	f	language:C++	namespace:mshadow	signature:(void *dptr)
FreeHost_	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost_<gpu>(void *dptr) {$/;"	f	language:C++	namespace:mshadow	signature:(void *dptr)
FreeSpace	include/mshadow/tensor.h	/^inline void FreeSpace(Tensor<cpu, dim, DType> *obj);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
FreeSpace	include/mshadow/tensor.h	/^inline void FreeSpace(Tensor<gpu, dim, DType> *obj);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> *obj)
FreeSpace	include/mshadow/tensor_container.h	/^  inline void FreeSpace(void) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:private	signature:(void)
FreeSpace	include/mshadow/tensor_cpu-inl.h	/^inline void FreeSpace(Tensor<cpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
FreeSpace	include/mshadow/tensor_gpu-inl.h	/^inline void FreeSpace(Tensor<gpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> *obj)
GPU	thirdparty/mshadow/guide/README.md	/^* For ```Tensor<gpu, k>```, the space need to lie in GPU, created by ```cudaMallocPitch```$/;"	v	language:C++
GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(double *dptr, index_t size, double mu, double sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, index_t size, double mu, double sigma)
GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(double *dptr, size_t size, double mu, double sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, size_t size, double mu, double sigma)
GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(float *dptr, index_t size, float mu, float sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, index_t size, float mu, float sigma)
GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(float *dptr, size_t size, float mu, float sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, size_t size, float mu, float sigma)
GenGaussianX	include/mshadow/random.h	/^  inline void GenGaussianX(DType *dptr, index_t size, DType mu, DType sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(DType *dptr, index_t size, DType mu, DType sigma)
GenUniform	include/mshadow/random.h	/^  inline void GenUniform(double *dptr, index_t size, double a, double b) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, index_t size, double a, double b)
GenUniform	include/mshadow/random.h	/^  inline void GenUniform(double *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, size_t size)
GenUniform	include/mshadow/random.h	/^  inline void GenUniform(float *dptr, index_t size, float a, float b) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, index_t size, float a, float b)
GenUniform	include/mshadow/random.h	/^  inline void GenUniform(float *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, size_t size)
Get	include/mshadow-ps/thread_util.h	/^  inline TValue *Get(int key) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(int key)
Get	include/mshadow/expr_engine-inl.h	/^  inline static Stream<Device> *Get(const E &t);$/;"	p	language:C++	struct:mshadow::expr::StreamInfo	access:public	signature:(const E &t)
Get	include/mshadow/expr_engine-inl.h	/^  inline static Stream<Device> *Get(const Tensor<Device, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::StreamInfo	access:public	signature:(const Tensor<Device, dim, DType> &t)
GetAlignStride	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline index_t GetAlignStride(index_t xsize) { $/;"	f	language:C++	namespace:mshadow::cuda	signature:(index_t xsize)
GetBlasHandle	include/mshadow/stream_gpu-inl.h	/^  inline static cublasHandle_t GetBlasHandle(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(Stream<gpu> *stream)
GetDnnHandle	include/mshadow/stream_gpu-inl.h	/^  inline static cudnnHandle_t GetDnnHandle(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(Stream<gpu> *stream)
GetRef	include/mshadow-ps/thread_util.h	/^  inline TValue &GetRef(int key) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(int key)
GetShape	include/mshadow/dot_engine-inl.h	/^inline static Shape<2> GetShape(const Shape<2> &shape, bool transpose) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Shape<2> &shape, bool transpose)
GetStream	include/mshadow/stream_gpu-inl.h	/^  inline static cudaStream_t GetStream(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(Stream<gpu> *stream)
GetT	include/mshadow/dot_engine-inl.h	/^  inline static CBLAS_TRANSPOSE GetT(bool t) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(bool t)
GetT	include/mshadow/dot_engine-inl.h	/^  inline static cublasOperation_t GetT(bool t) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(bool t)
GetWorkIndex	include/mshadow-ps/ps_local-inl.h	/^  inline int GetWorkIndex(int devid) const {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(int devid) const
GlobalExample	depparser/GlobalExample.h	/^	GlobalExample(){}$/;"	f	language:C++	class:GlobalExample	access:public	signature:()
GlobalExample	depparser/GlobalExample.h	/^	GlobalExample(std::vector<Example>& es, std::vector<int>& acts){$/;"	f	language:C++	class:GlobalExample	access:public	signature:(std::vector<Example>& es, std::vector<int>& acts)
GlobalExample	depparser/GlobalExample.h	/^class GlobalExample {$/;"	c	language:C++
GlobalExample::GlobalExample	depparser/GlobalExample.h	/^	GlobalExample(){}$/;"	f	language:C++	class:GlobalExample	access:public	signature:()
GlobalExample::GlobalExample	depparser/GlobalExample.h	/^	GlobalExample(std::vector<Example>& es, std::vector<int>& acts){$/;"	f	language:C++	class:GlobalExample	access:public	signature:(std::vector<Example>& es, std::vector<int>& acts)
GlobalExample::examples	depparser/GlobalExample.h	/^	std::vector<Example> examples;$/;"	m	language:C++	class:GlobalExample	access:public
GlobalExample::goldActs	depparser/GlobalExample.h	/^	std::vector<int> goldActs;$/;"	m	language:C++	class:GlobalExample	access:public
GlobalExample::setParas	depparser/GlobalExample.h	/^	inline void setParas(std::vector<Example> & es, std::vector<int>& acts,$/;"	f	language:C++	class:GlobalExample	access:public	signature:(std::vector<Example> & es, std::vector<int>& acts, std::vector<int> & wIdx, std::vector<int> & tIdx)
GlobalExample::tagIdx	depparser/GlobalExample.h	/^	std::vector<int> tagIdx;$/;"	m	language:C++	class:GlobalExample	access:public
GlobalExample::wordIdx	depparser/GlobalExample.h	/^	std::vector<int> wordIdx;$/;"	m	language:C++	class:GlobalExample	access:public
GlobalExample::~GlobalExample	depparser/GlobalExample.h	/^	virtual ~GlobalExample();$/;"	p	language:C++	class:GlobalExample	access:public	signature:()
HandleAssertError	include/mshadow/utils.h	/^inline void HandleAssertError(const char *msg) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(const char *msg)
HandleAssertError	include/mshadow/utils.h	/^void HandleAssertError(const char *msg);$/;"	p	language:C++	namespace:mshadow::utils	signature:(const char *msg)
HandleCheckError	include/mshadow/utils.h	/^inline void HandleCheckError(const char *msg) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(const char *msg)
HandleCheckError	include/mshadow/utils.h	/^void HandleCheckError(const char *msg);$/;"	p	language:C++	namespace:mshadow::utils	signature:(const char *msg)
HandlePrint	include/mshadow/utils.h	/^void HandlePrint(const char *msg);$/;"	p	language:C++	namespace:mshadow::utils	signature:(const char *msg)
HandlePushFinish	include/mshadow-ps/ps_dist-inl.h	/^  virtual void HandlePushFinish(Tensor<cpu, 3, DType> data,$/;"	f	language:C++	class:mshadow::ps::DistModel	access:protected	signature:(Tensor<cpu, 3, DType> data, int key)
HandlePushFinish	include/mshadow-ps/ps_local-inl.h	/^  virtual void HandlePushFinish(Tensor<cpu, 3, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 3, DType> data, int key)
HandlePushFinish	include/mshadow-ps/ps_rabit-inl.h	/^  virtual void HandlePushFinish(Tensor<cpu, 3, DType> data,$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(Tensor<cpu, 3, DType> data, int key)
HandleReduceFinish	include/mshadow-ps/ps_local-inl.h	/^  inline void HandleReduceFinish(Tensor<cpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 2, DType> data, int key)
HandleState	include/mshadow/stream_gpu-inl.h	/^  enum HandleState {$/;"	g	language:C++	struct:mshadow::Stream	access:public
IDIdx	depparser/Depparser.cpp	/^	int IDIdx = 0;$/;"	l	language:C++
IModelUpdater	include/mshadow-ps/mshadow_ps.h	/^class IModelUpdater {$/;"	c	language:C++	namespace:mshadow::ps
INCLUDE_DICT_H_	include/Dict.h	9;"	d	language:C++
INCLUDE_FEATUREEMBEDDING_H_	include/FeatureEmbedding.h	9;"	d	language:C++
INNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^class INNet{$/;"	c	language:C++	file:
INNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^class INNet{$/;"	c	language:C++	file:
INNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^class INNet{$/;"	c	language:C++	file:
INNet::Backprop	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
INNet::Backprop	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
INNet::Backprop	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
INNet::Forward	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Forward(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 4, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
INNet::Forward	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
INNet::Forward	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch,$/;"	p	language:C++	class:INNet	file:	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
INNet::Update	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Update(void) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(void)
INNet::Update	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Update(void) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(void)
INNet::~INNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual ~INNet() {}$/;"	f	language:C++	class:INNet	access:public	signature:()
INNet::~INNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual ~INNet() {}$/;"	f	language:C++	class:INNet	access:public	signature:()
INNet::~INNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual ~INNet() {}$/;"	f	language:C++	class:INNet	access:public	signature:()
ISharedModel	include/mshadow-ps/mshadow_ps.h	/^class ISharedModel {$/;"	c	language:C++	namespace:mshadow::ps
IStream	include/mshadow/io.h	/^class IStream {$/;"	c	language:C++	namespace:mshadow::utils
Info	include/mshadow/extension/swapaxis.h	/^  typedef ExpInfo<SrcExp> Info;$/;"	t	language:C++
Info	tags	/^Info	include\/mshadow\/extension\/swapaxis.h	\/^  typedef ExpInfo<SrcExp> Info;$\/;"	t	language:C++$/;"	t	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
Init	include/mshadow-ps/mshadow_ps.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(void)
Init	include/mshadow-ps/mshadow_ps.h	/^  virtual void Init(const std::vector<int> &devices) {}$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(const std::vector<int> &devices)
Init	include/mshadow-ps/ps_dist-inl.h	/^    Parent::Init(devices);$/;"	p	language:C++	class:mshadow::ps::DistModel::Parent	signature:(devices)
Init	include/mshadow-ps/ps_dist-inl.h	/^  virtual void Init(const std::vector<int> &devices) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:public	signature:(const std::vector<int> &devices)
Init	include/mshadow-ps/ps_dist-inl.h	/^  void Init(int id, size_t size, DType* data) {$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:(int id, size_t size, DType* data)
Init	include/mshadow-ps/ps_local-inl.h	/^      e.Init(devices.size(), shape,$/;"	p	language:C++	signature:(devices.size(), shape, use_pin_memory != 0, update_on_server != 0 || test_on_server != 0)
Init	include/mshadow-ps/ps_local-inl.h	/^      pull_queues[i].Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^    inline void Init(int ndevice, Shape<2> shape,$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public	signature:(int ndevice, Shape<2> shape, bool pin_memory, bool need_weight)
Init	include/mshadow-ps/ps_local-inl.h	/^    pull_map.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^    pull_map.Init(key);$/;"	p	language:C++	signature:(key)
Init	include/mshadow-ps/ps_local-inl.h	/^    push_lock.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^    push_map.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^    push_map.Init(key);$/;"	p	language:C++	signature:(key)
Init	include/mshadow-ps/ps_local-inl.h	/^    request_lock.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^    wait_cond.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^    wait_lock.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/ps_local-inl.h	/^  virtual void Init(const std::vector<int> &devices) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(const std::vector<int> &devices)
Init	include/mshadow-ps/ps_rabit-inl.h	/^    Parent::Init(devices);$/;"	p	language:C++	class:mshadow::ps::RabitModel::Parent	signature:(devices)
Init	include/mshadow-ps/ps_rabit-inl.h	/^    reduce_queue_.Init(true);$/;"	p	language:C++	signature:(true)
Init	include/mshadow-ps/ps_rabit-inl.h	/^  virtual void Init(const std::vector<int> &devices) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(const std::vector<int> &devices)
Init	include/mshadow-ps/thread.h	/^  inline void Init(int init_val) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(int init_val)
Init	include/mshadow-ps/thread.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
Init	include/mshadow-ps/thread.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
Init	include/mshadow-ps/thread_util.h	/^    lock_.Init();$/;"	p	language:C++	signature:()
Init	include/mshadow-ps/thread_util.h	/^  inline void Init(bool use_fifo = false) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(bool use_fifo = false)
Init	include/mshadow-ps/thread_util.h	/^  inline void Init(int key) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(int key)
Init	include/mshadow-ps/thread_util.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(void)
Init	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->Init(devs);$/;"	p	language:C++	signature:(devs)
Init	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->Init(devs);$/;"	p	language:C++	signature:(devs)
Init	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  rabit::Init(argc, argv);$/;"	p	language:C++	class:rabit	signature:(argc, argv)
Init	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  ps->Init(devs);$/;"	p	language:C++	file:	signature:(devs)
InitCustomerServer	include/mshadow-ps/ps_dist-inl.h	/^  virtual void InitCustomerServer(void) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:protected	signature:(void)
InitCustomerServer	include/mshadow-ps/ps_local-inl.h	/^  virtual void InitCustomerServer(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(void)
InitKey	include/mshadow-ps/mshadow_ps.h	/^  inline void InitKey(Shape<dim> shape,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Shape<dim> shape, int key, int devid)
InitKey	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  ps->InitKey(data[0].shape_, 0, devid);$/;"	p	language:C++	file:	signature:(data[0].shape_, 0, devid)
InitKey	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  ps->InitKey(data[1].shape_, 1, devid);$/;"	p	language:C++	file:	signature:(data[1].shape_, 1, devid)
InitKey	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->InitKey(data[0].shape_, 0, devid);$/;"	p	language:C++	signature:(data[0].shape_, 0, devid)
InitKey	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->InitKey(data[1].shape_, 1, devid);$/;"	p	language:C++	signature:(data[1].shape_, 1, devid)
InitKey	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->InitKey(data[0].shape_, 0, devid);$/;"	p	language:C++	signature:(data[0].shape_, 0, devid)
InitKey	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->InitKey(data[1].shape_, 1, devid);$/;"	p	language:C++	signature:(data[1].shape_, 1, devid)
InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(Wh2o.shape_, 2, devid);$/;"	p	language:C++	file:	signature:(Wh2o.shape_, 2, devid)
InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(Wi2h.shape_, 0, devid);$/;"	p	language:C++	file:	signature:(Wi2h.shape_, 0, devid)
InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(hbias.shape_, 1, devid);$/;"	p	language:C++	file:	signature:(hbias.shape_, 1, devid)
InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(obias.shape_, 3, devid);$/;"	p	language:C++	file:	signature:(obias.shape_, 3, devid)
InitKey_	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitKey_(Shape<2> shape,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:protected	signature:(Shape<2> shape, int key, int devid)
InitKey_	include/mshadow-ps/ps_local-inl.h	/^  virtual void InitKey_(Shape<2> shape,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Shape<2> shape, int key, int devid)
InitModel	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitModel(int key, DType *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(int key, DType *dptr, size_t size)
InitModel	include/mshadow-ps/ps_dist-inl.h	/^    updater_->InitModel(id, data, size);$/;"	p	language:C++	signature:(id, data, size)
InitModel	include/mshadow-ps/ps_local-inl.h	/^      custom_server->InitModel(key, weight.dptr_, weight.MSize());$/;"	p	language:C++	signature:(key, weight.dptr_, weight.MSize())
InitModel_	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitModel_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
InitModel_	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  void InitModel_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::Updater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
InitPullMap	include/mshadow-ps/ps_local-inl.h	/^  inline void InitPullMap(int key) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(int key)
InitPushMap	include/mshadow-ps/ps_local-inl.h	/^  inline void InitPushMap(int key, Shape<2> shape) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(int key, Shape<2> shape)
InitTensorEngine	include/mshadow/tensor.h	/^inline void InitTensorEngine(int device_id = 0);$/;"	p	language:C++	namespace:mshadow	signature:(int device_id = 0)
InitTensorEngine	include/mshadow/tensor_cpu-inl.h	/^inline void InitTensorEngine<cpu>(int dev_id) {$/;"	f	language:C++	namespace:mshadow	signature:(int dev_id)
InitTensorEngine	include/mshadow/tensor_gpu-inl.h	/^inline void InitTensorEngine<gpu>(int dev_id) {$/;"	f	language:C++	namespace:mshadow	signature:(int dev_id)
InitTensorEngine	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::InitTensorEngine<xpu>(devid);$/;"	p	language:C++	class:mshadow	signature:(devid)
InitTensorEngine	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::InitTensorEngine<xpu>(devid);$/;"	p	language:C++	class:mshadow	signature:(devid)
InitTensorEngine	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::InitTensorEngine<xpu>(devs[i]);$/;"	p	language:C++	class:mshadow	file:	signature:(devs[i])
InitUpdater	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitUpdater(int rank, int argc, char *argv[]) {}$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(int rank, int argc, char *argv[])
InvokeLambda_	include/mshadow-ps/mshadow_ps.h	/^  inline static void InvokeLambda_(Stream<xpu> *stream, void *fun) {$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:private	signature:(Stream<xpu> *stream, void *fun)
Join	include/mshadow-ps/ps_local-inl.h	/^        thread_pull_handler[i].Join();$/;"	p	language:C++	signature:()
Join	include/mshadow-ps/ps_local-inl.h	/^        thread_push_handler[i].Join();$/;"	p	language:C++	signature:()
Join	include/mshadow-ps/ps_rabit-inl.h	/^      thread_reduce_handler_.Join();$/;"	p	language:C++	signature:()
Join	include/mshadow-ps/thread.h	/^  inline int Join(void) {$/;"	f	language:C++	class:mshadow::utils::Thread	access:public	signature:(void)
KIND	thirdparty/mshadow/LICENSE	/^WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.$/;"	v	language:C++
Ki2h	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
License	thirdparty/mshadow/LICENSE	/^Licensed under the Apache License, Version 2.0 (the "License");$/;"	v	language:C++
LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi,  \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst, bool pre_alloc)
LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi, \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst_, bool pre_alloc)
LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi, \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<gpu, dim, DType> *dst, bool pre_alloc)
LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi, \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<gpu, dim, DType> *dst, bool pre_alloc)
LoadBinary	include/mshadow/tensor_container.h	/^    mshadow::LoadBinary(fi, &tmp, false);$/;"	p	language:C++	class:mshadow::TensorContainer::mshadow	signature:(fi, &tmp, false)
LoadBinary	include/mshadow/tensor_container.h	/^  inline void LoadBinary(TStream &fi) { \/\/ NOLINT(*)$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(TStream &fi)
LoadConfig	depparser/Config.cpp	/^bool CConfig::LoadConfig(const char *pszPath)$/;"	f	language:C++	class:CConfig	signature:(const char *pszPath)
LoadConfig	depparser/Config.h	/^	static bool LoadConfig(const char *pszPath);$/;"	p	language:C++	class:CConfig	access:public	signature:(const char *pszPath)
LoadMNIST	thirdparty/mshadow/guide/neuralnet/util.h	/^inline void LoadMNIST(const char *path_img, const char *path_label,$/;"	f	language:C++	signature:(const char *path_img, const char *path_label, std::vector<int> &ylabel, TensorContainer<cpu, 2, real_t> &xdata, bool do_shuffle)
LocalModel	include/mshadow-ps/ps_local-inl.h	/^  LocalModel(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(void)
LocalModel	include/mshadow-ps/ps_local-inl.h	/^class LocalModel : public ISharedModel<xpu, DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:ISharedModel
LocalOp	include/mshadow-ps/ps_local-inl.h	/^  enum LocalOp {$/;"	g	language:C++	class:mshadow::ps::LocalModel	access:protected
Lock	include/mshadow-ps/ps_local-inl.h	/^          wait_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/ps_local-inl.h	/^        push_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/ps_local-inl.h	/^        request_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/ps_local-inl.h	/^      wait_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/ps_local-inl.h	/^    push_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/ps_local-inl.h	/^    request_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/ps_local-inl.h	/^    wait_lock.Lock();$/;"	p	language:C++	signature:()
Lock	include/mshadow-ps/thread.h	/^  inline void Lock(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
Lock	include/mshadow-ps/thread_util.h	/^    lock_.Lock();$/;"	p	language:C++	signature:()
LowerAlign	include/mshadow/sse-inl.h	/^inline index_t LowerAlign(index_t size, size_t fsize) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(index_t size, size_t fsize)
MAX_POOL_SIZE	include/Pool.cpp	4;"	d	language:C++	file:
MAX_SENTENCE_SIZE	depparser/State.h	11;"	d	language:C++
MSHADOW_ALLOC_PAD	include/mshadow/base.h	30;"	d	language:C++
MSHADOW_BASE_H_	include/mshadow/base.h	9;"	d	language:C++
MSHADOW_CINLINE	include/mshadow/base.h	153;"	d	language:C++
MSHADOW_CONSTEXPR	include/mshadow/base.h	157;"	d	language:C++
MSHADOW_CONSTEXPR	include/mshadow/base.h	159;"	d	language:C++
MSHADOW_CUDA_REDUCE_CUH_	include/mshadow/cuda/reduce.cuh	8;"	d	language:C++	file:
MSHADOW_CUDA_TENSOR_GPU_INL_CUH_	include/mshadow/cuda/tensor_gpu-inl.cuh	8;"	d	language:C++	file:
MSHADOW_DEFAULT_DTYPE	include/mshadow/base.h	169;"	d	language:C++
MSHADOW_DIST_PS	include/mshadow-ps/mshadow_ps.h	21;"	d	language:C++
MSHADOW_DOT_ENGINE_INL_H_	include/mshadow/dot_engine-inl.h	8;"	d	language:C++
MSHADOW_EXPRESSION_H_	include/mshadow/expression.h	8;"	d	language:C++
MSHADOW_EXPR_ENGINE_INL_H_	include/mshadow/expr_engine-inl.h	8;"	d	language:C++
MSHADOW_EXPR_SCALAR_INL_H_	include/mshadow/expr_scalar-inl.h	12;"	d	language:C++
MSHADOW_EXPR_SCALAR_INL_H_	include/mshadow/expr_scalar-inl.h	14;"	d	language:C++
MSHADOW_EXTENSION_BROADCAST_H_	include/mshadow/extension/broadcast.h	8;"	d	language:C++
MSHADOW_EXTENSION_CHANNEL_POOL_H_	include/mshadow/extension/channel_pool.h	8;"	d	language:C++
MSHADOW_EXTENSION_CHANNEL_UNPOOL_H_	include/mshadow/extension/channel_unpool.h	8;"	d	language:C++
MSHADOW_EXTENSION_CONCAT_H_	include/mshadow/extension/concat.h	7;"	d	language:C++
MSHADOW_EXTENSION_CROP_H_	include/mshadow/extension/crop.h	8;"	d	language:C++
MSHADOW_EXTENSION_H_	include/mshadow/extension.h	9;"	d	language:C++
MSHADOW_EXTENSION_MIRROR_H_	include/mshadow/extension/mirror.h	8;"	d	language:C++
MSHADOW_EXTENSION_PACK_COL2PATCH_H_	include/mshadow/extension/pack_col2patch.h	8;"	d	language:C++
MSHADOW_EXTENSION_PAD_H_	include/mshadow/extension/pad.h	8;"	d	language:C++
MSHADOW_EXTENSION_REDUCETO1D_H_	include/mshadow/extension/reduceto1d.h	8;"	d	language:C++
MSHADOW_EXTENSION_RESHAPE_H_	include/mshadow/extension/reshape.h	8;"	d	language:C++
MSHADOW_EXTENSION_SPATIAL_POOL_H_	include/mshadow/extension/spatial_pool.h	8;"	d	language:C++
MSHADOW_EXTENSION_SPATIAL_UNPOOL_H_	include/mshadow/extension/spatial_unpool.h	8;"	d	language:C++
MSHADOW_EXTENSION_SWAPAXIS_H_	include/mshadow/extension/swapaxis.h	8;"	d	language:C++
MSHADOW_EXTENSION_UNPACK_PATCH2COL_H_	include/mshadow/extension/unpack_patch2col.h	8;"	d	language:C++
MSHADOW_FORCE_INLINE	include/mshadow/base.h	142;"	d	language:C++
MSHADOW_FORCE_INLINE	include/mshadow/base.h	145;"	d	language:C++
MSHADOW_FORCE_STREAM	include/mshadow/base.h	55;"	d	language:C++
MSHADOW_IN_CXX11	include/mshadow/base.h	93;"	d	language:C++
MSHADOW_IO_H_	include/mshadow/io.h	8;"	d	language:C++
MSHADOW_MIN_PAD_RATIO	include/mshadow/base.h	41;"	d	language:C++
MSHADOW_OLD_CUDA	include/mshadow/base.h	86;"	d	language:C++
MSHADOW_PS_DIST_INL_H_	include/mshadow-ps/ps_dist-inl.h	9;"	d	language:C++
MSHADOW_PS_H_	include/mshadow-ps/mshadow_ps.h	11;"	d	language:C++
MSHADOW_PS_LOCAL_INL_H_	include/mshadow-ps/ps_local-inl.h	9;"	d	language:C++
MSHADOW_PS_RABIT_INL_H_	include/mshadow-ps/ps_rabit-inl.h	9;"	d	language:C++
MSHADOW_PS_THREAD_H_	include/mshadow-ps/thread.h	9;"	d	language:C++
MSHADOW_PS_THREAD_UTIL_H_	include/mshadow-ps/thread_util.h	8;"	d	language:C++
MSHADOW_RABIT_PS	include/mshadow-ps/mshadow_ps.h	26;"	d	language:C++
MSHADOW_RANDOM_H_	include/mshadow/random.h	9;"	d	language:C++
MSHADOW_SCALAR_	include/mshadow/tensor.h	736;"	d	language:C++
MSHADOW_SCALAR_	include/mshadow/tensor.h	738;"	d	language:C++
MSHADOW_SCALAR_	include/mshadow/tensor.h	739;"	d	language:C++
MSHADOW_SCALAR_	include/mshadow/tensor.h	741;"	d	language:C++
MSHADOW_SCALAR_	include/mshadow/tensor.h	742;"	d	language:C++
MSHADOW_SCALAR_	include/mshadow/tensor.h	744;"	d	language:C++
MSHADOW_SSE_INL_H_	include/mshadow/sse-inl.h	8;"	d	language:C++
MSHADOW_STAND_ALONE	include/mshadow/base.h	26;"	d	language:C++
MSHADOW_STREAM_GPU_INL_H_	include/mshadow/stream_gpu-inl.h	8;"	d	language:C++
MSHADOW_TENSOR_BLOB_H_	include/mshadow/tensor_blob.h	10;"	d	language:C++
MSHADOW_TENSOR_CONTAINER_H_	include/mshadow/tensor_container.h	8;"	d	language:C++
MSHADOW_TENSOR_CPU_INL_H_	include/mshadow/tensor_cpu-inl.h	8;"	d	language:C++
MSHADOW_TENSOR_GPU_INL_H_	include/mshadow/tensor_gpu-inl.h	8;"	d	language:C++
MSHADOW_TENSOR_H_	include/mshadow/tensor.h	13;"	d	language:C++
MSHADOW_THREAD_PREFIX	include/mshadow-ps/thread.h	105;"	d	language:C++
MSHADOW_USE_CBLAS	include/mshadow/base.h	45;"	d	language:C++
MSHADOW_USE_CBLAS	include/mshadow/base.h	60;"	d	language:C++
MSHADOW_USE_CUDA	include/mshadow/base.h	47;"	d	language:C++
MSHADOW_USE_CUDA	include/mshadow/base.h	71;"	d	language:C++
MSHADOW_USE_CUDNN	include/mshadow/base.h	78;"	d	language:C++
MSHADOW_USE_MKL	include/mshadow/base.h	46;"	d	language:C++
MSHADOW_USE_MKL	include/mshadow/base.h	64;"	d	language:C++
MSHADOW_USE_NVML	include/mshadow/base.h	103;"	d	language:C++
MSHADOW_USE_SSE	include/mshadow/base.h	107;"	d	language:C++
MSHADOW_USE_SSE	include/mshadow/base.h	108;"	d	language:C++
MSHADOW_USE_SSE	include/mshadow/base.h	99;"	d	language:C++
MSHADOW_UTILS_H_	include/mshadow/utils.h	8;"	d	language:C++
MSHADOW_XINLINE	include/mshadow/base.h	148;"	d	language:C++
MSHADOW_XINLINE	include/mshadow/base.h	150;"	d	language:C++
MShadow	thirdparty/mshadow/make/README.md	/^Makefile Configuration of MShadow$/;"	v	language:C++
MShadowServerNode	include/mshadow-ps/ps_dist-inl.h	/^  MShadowServerNode(int argc, char *argv[]) {$/;"	f	language:C++	class:mshadow::ps::MShadowServerNode	access:public	signature:(int argc, char *argv[])
MShadowServerNode	include/mshadow-ps/ps_dist-inl.h	/^class MShadowServerNode {$/;"	c	language:C++	namespace:mshadow::ps
MSize	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key), weight.dptr_, weight.MSize(),$/;"	p	language:C++	signature:()
MSize	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key, -1, {ts}), sendrecv.dptr_, sendrecv.MSize(),$/;"	p	language:C++	signature:()
MSize	include/mshadow/tensor.h	/^  MSHADOW_XINLINE size_t MSize(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
MakeExp	include/mshadow/expression.h	/^MakeExp(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
MakeExp	include/mshadow/expression.h	/^MakeExp(const Exp<TA, DType, ta> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &src)
MakePlan	include/mshadow/cuda/tensor_gpu-inl.cuh	/^       expr::MakePlan(src),$/;"	p	language:C++	class:mshadow::cuda::expr	file:	signature:(src)
MakePlan	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      (expr::MakePlan(dst),$/;"	p	language:C++	file:	signature:(dst)
MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e);$/;"	p	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const MakeTensorExp<T, SrcExp, dim, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const MakeTensorExp<T, SrcExp, dim, DType> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const TransposeExp<T, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TransposeExp<T, DType> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const TypecastExp<DstDType, SrcDType, EType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TypecastExp<DstDType, SrcDType, EType, etype> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const UnaryMapExp<OP, TA, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const UnaryMapExp<OP, TA, DType, etype> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^inline Plan<ScalarExp<DType>, DType> MakePlan(const ScalarExp<DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<DType> &e)
MakePlan	include/mshadow/expr_engine-inl.h	/^inline Plan<T, DType> MakePlan(const RValueExp<T, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<T, DType> &e)
MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e);$/;"	p	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const MakeTensorExp<T, cpu, dim, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const MakeTensorExp<T, cpu, dim, DType> &e)
MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const UnaryMapExp<OP, TA, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const UnaryMapExp<OP, TA, DType, etype> &e)
MakeSSEPlan	include/mshadow/sse-inl.h	/^inline SSEPlan<ScalarExp<DType>, DType> MakeSSEPlan(const ScalarExp<DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<DType> &e)
MakeSSEPlan	include/mshadow/sse-inl.h	/^inline SSEPlan<T, DType> MakeSSEPlan(const RValueExp<T, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<T, DType> &e)
MakeTensorExp	include/mshadow/expr_engine-inl.h	/^struct MakeTensorExp$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
Map	include/NNet.h	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(real_t a)
Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a) {$/;"	f	language:C++	struct:mshadow::op::identity	access:public	signature:(DType a)
Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::div	access:public	signature:(DType a, DType b)
Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::minus	access:public	signature:(DType a, DType b)
Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::mul	access:public	signature:(DType a, DType b)
Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::plus	access:public	signature:(DType a, DType b)
Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::right	access:public	signature:(DType a, DType b)
Map	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE static FVec<double> Map(const FVec<double> &src) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<double> &src)
Map	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE static FVec<float> Map(const FVec<float> &src) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<float> &src)
Map	include/mshadow/sse-inl.h	/^  Map(const FVec<double> &lhs, const FVec<double> &rhs) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<double> &lhs, const FVec<double> &rhs)
Map	include/mshadow/sse-inl.h	/^  Map(const FVec<float> &lhs, const FVec<float> &rhs) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<float> &lhs, const FVec<float> &rhs)
Map	include/mshadow/tensor_cpu-inl.h	/^  MapExpCPUEngine<false, Saver, R, dim, DType, E, etype>::Map(dst, exp);$/;"	p	language:C++	class:mshadow::MapExpCPUEngine	signature:(dst, exp)
Map	include/mshadow/tensor_cpu-inl.h	/^  inline static void Map(TRValue<R, cpu, dim, DType> *dst,$/;"	f	language:C++	struct:mshadow::MapExpCPUEngine	access:public	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
Map	include/mshadow/tensor_cpu-inl.h	/^  inline static void Map(Tensor<cpu, dim, DType> *dst,$/;"	f	language:C++	struct:mshadow::MapExpCPUEngine	access:public	signature:(Tensor<cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
Map	thirdparty/mshadow/guide/README.md	/^  MSHADOW_XINLINE static float Map(float a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(float a)
Map	thirdparty/mshadow/guide/defop.cpp	/^  MSHADOW_XINLINE static DType Map(DType a) {$/;"	f	language:C++	struct:addone	access:public	signature:(DType a)
Map	thirdparty/mshadow/guide/defop.cpp	/^  MSHADOW_XINLINE static float Map(float a, float b) {$/;"	f	language:C++	struct:maxoftwo	access:public	signature:(float a, float b)
Map	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:relu	access:public	signature:(real_t a)
Map	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:relu_grad	access:public	signature:(real_t a)
Map	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(real_t a)
Map	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(real_t a)
MapExp	include/mshadow/tensor.h	/^inline void MapExp(TRValue<R, cpu, dim, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
MapExp	include/mshadow/tensor.h	/^inline void MapExp(TRValue<R, gpu, dim, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
MapExp	include/mshadow/tensor_cpu-inl.h	/^inline void MapExp(TRValue<R, cpu, dim, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
MapExp	include/mshadow/tensor_gpu-inl.h	/^inline void MapExp(TRValue<R, gpu, dim, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
MapExpCPUEngine	include/mshadow/tensor_cpu-inl.h	/^struct MapExpCPUEngine {$/;"	s	language:C++	namespace:mshadow
MapExpCPUEngine	include/mshadow/tensor_cpu-inl.h	/^struct MapExpCPUEngine<true, SV, Tensor<cpu, dim, DType>,$/;"	s	language:C++	namespace:mshadow
MapPlan	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void MapPlan(expr::Plan<DstExp, DType> dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(expr::Plan<DstExp, DType> dst, const expr::Plan<E, DType> &plan, Shape<2> dshape, cudaStream_t stream)
MapPlan	include/mshadow/tensor_cpu-inl.h	/^inline void MapPlan(TRValue<R, cpu, dim, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Plan<E, DType> &plan)
MapPlanKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapPlanKernel(DstPlan dst, index_t xstride,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, index_t xstride, Shape<2> dshape, const Plan exp)
MapPlanLargeKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapPlanLargeKernel(DstPlan dst, index_t xstride,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, index_t xstride, Shape<2> dshape, const Plan exp, int repeat)
MapPlanProc	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__device__ void MapPlanProc(DstPlan dst, index_t xstride,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, index_t xstride, Shape<2> dshape, const Plan exp, int block_idx)
MapRedKeepLowestKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapRedKeepLowestKernel(DstPlan dst, Plan plan,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, Plan plan, DType scale, Shape<2> eshape)
MapReduceKeepDim1	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void MapReduceKeepDim1(expr::Plan<DstExp, DType> dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(expr::Plan<DstExp, DType> dst, const expr::Plan<E, DType> &plan, DType scale, Shape<4> pshape, cudaStream_t stream)
MapReduceKeepDim1Kernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapReduceKeepDim1Kernel(DstPlan dst, Plan plan, DType scale, Shape<4> pshape) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, Plan plan, DType scale, Shape<4> pshape)
MapReduceKeepHighDim	include/mshadow/tensor.h	/^inline void MapReduceKeepHighDim(TRValue<R, cpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
MapReduceKeepHighDim	include/mshadow/tensor.h	/^inline void MapReduceKeepHighDim(TRValue<R, gpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
MapReduceKeepHighDim	include/mshadow/tensor_cpu-inl.h	/^inline void MapReduceKeepHighDim(TRValue<R, cpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
MapReduceKeepHighDim	include/mshadow/tensor_gpu-inl.h	/^inline void MapReduceKeepHighDim(TRValue<R, gpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
MapReduceKeepLowest	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void MapReduceKeepLowest(expr::Plan<DstExp, DType> dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(expr::Plan<DstExp, DType> dst, const expr::Plan<E, DType> &plan, DType scale, Shape<2> eshape, cudaStream_t stream)
MapReduceKeepLowest	include/mshadow/tensor.h	/^inline void MapReduceKeepLowest(TRValue<R, cpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
MapReduceKeepLowest	include/mshadow/tensor.h	/^inline void MapReduceKeepLowest(TRValue<R, gpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
MapReduceKeepLowest	include/mshadow/tensor_cpu-inl.h	/^inline void MapReduceKeepLowest(TRValue<R, cpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
MapReduceKeepLowest	include/mshadow/tensor_gpu-inl.h	/^inline void MapReduceKeepLowest(TRValue<R, gpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
MapSSEPlan	include/mshadow/sse-inl.h	/^inline void MapSSEPlan(Tensor<cpu, dim, DType> _dst,$/;"	f	language:C++	namespace:mshadow::expr	signature:(Tensor<cpu, dim, DType> _dst, const expr::SSEPlan<E, DType> &plan)
MaxIndex	include/NNet.h	/^inline int MaxIndex(Tensor<cpu, 1, real_t> pred) {$/;"	f	language:C++	signature:(Tensor<cpu, 1, real_t> pred)
MaxIndex	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^inline int MaxIndex(Tensor<cpu, 1, real_t> pred) {$/;"	f	language:C++	signature:(Tensor<cpu, 1, real_t> pred)
MaxIndex	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^inline int MaxIndex(Tensor<cpu, 1, real_t> pred) {$/;"	f	language:C++	signature:(Tensor<cpu, 1, real_t> pred)
MaxIndex	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^inline int MaxIndex(Tensor<cpu, 1, real_t> pred) {$/;"	f	language:C++	signature:(Tensor<cpu, 1, real_t> pred)
MemSize	include/mshadow/tensor.h	/^  MSHADOW_XINLINE size_t MemSize(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE DType MinValue(void);$/;"	p	language:C++	namespace:mshadow::red::limits	signature:(void)
MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE double MinValue<double>(void) {$/;"	f	language:C++	namespace:mshadow::red::limits	signature:(void)
MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE float MinValue<float>(void) {$/;"	f	language:C++	namespace:mshadow::red::limits	signature:(void)
MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE int MinValue<int>(void) {$/;"	f	language:C++	namespace:mshadow::red::limits	signature:(void)
MirroringExp	include/mshadow/extension/mirror.h	/^  explicit MirroringExp(const SrcExp &src) : src_(src) {$/;"	f	language:C++	struct:mshadow::expr::MirroringExp	access:public	signature:(const SrcExp &src)
MirroringExp	include/mshadow/extension/mirror.h	/^struct MirroringExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
Move	depparser/Depparser.cpp	/^							target->Move(transition.action);$/;"	p	language:C++	file:	signature:(transition.action)
Move	depparser/Depparser.cpp	/^			state->Move(goldAct);$/;"	p	language:C++	file:	signature:(goldAct)
Mutex	include/mshadow-ps/thread.h	/^class Mutex {$/;"	c	language:C++	namespace:mshadow::utils
MyRank	include/mshadow-ps/ps_dist-inl.h	/^    updater->InitUpdater(::ps::MyRank(), argc, argv);$/;"	p	language:C++	signature:()
NNet	include/NNet.h	/^  NNet(int batch_size, int num_in, int num_hidden, int num_out) : rnd(0) {$/;"	f	language:C++	class:NNet	access:public	signature:(int batch_size, int num_in, int num_hidden, int num_out)
NNet	include/NNet.h	/^class NNet{$/;"	c	language:C++
NNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  NNet(int batch_size, int num_in, int num_hidden, int num_out) : rnd(0) {$/;"	f	language:C++	class:NNet	access:public	signature:(int batch_size, int num_in, int num_hidden, int num_out)
NNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^class NNet : public INNet {$/;"	c	language:C++	file:	inherits:INNet
NNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  NNet(int batch_size, int num_in, int num_hidden, int num_out,$/;"	f	language:C++	class:NNet	access:public	signature:(int batch_size, int num_in, int num_hidden, int num_out, int devid, mshadow::ps::ISharedModel<xpu, real_t> *ps)
NNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^class NNet : public INNet {$/;"	c	language:C++	file:	inherits:INNet
NNet::Backprop	include/NNet.h	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) {$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
NNet::Backprop	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t>& gradout) {$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& gradout)
NNet::Backprop	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Backprop(const Tensor<cpu, 2, real_t> &gradout) {$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t> &gradout)
NNet::Forward	include/NNet.h	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch,$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
NNet::Forward	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t>& inbatch,$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t>& inbatch, Tensor<cpu, 2, real_t> &oubatch)
NNet::Forward	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual void Forward(const Tensor<cpu, 2, real_t> &inbatch,$/;"	f	language:C++	class:NNet	access:public	signature:(const Tensor<cpu, 2, real_t> &inbatch, Tensor<cpu, 2, real_t> &oubatch)
NNet::InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(Wh2o.shape_, 2, devid);$/;"	p	language:C++	file:	signature:(Wh2o.shape_, 2, devid)
NNet::InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(Wi2h.shape_, 0, devid);$/;"	p	language:C++	file:	signature:(Wi2h.shape_, 0, devid)
NNet::InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(hbias.shape_, 1, devid);$/;"	p	language:C++	file:	signature:(hbias.shape_, 1, devid)
NNet::InitKey	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->InitKey(obias.shape_, 3, devid);$/;"	p	language:C++	file:	signature:(obias.shape_, 3, devid)
NNet::NNet	include/NNet.h	/^  NNet(int batch_size, int num_in, int num_hidden, int num_out) : rnd(0) {$/;"	f	language:C++	class:NNet	access:public	signature:(int batch_size, int num_in, int num_hidden, int num_out)
NNet::NNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  NNet(int batch_size, int num_in, int num_hidden, int num_out) : rnd(0) {$/;"	f	language:C++	class:NNet	access:public	signature:(int batch_size, int num_in, int num_hidden, int num_out)
NNet::NNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  NNet(int batch_size, int num_in, int num_hidden, int num_out,$/;"	f	language:C++	class:NNet	access:public	signature:(int batch_size, int num_in, int num_hidden, int num_out, int devid, mshadow::ps::ISharedModel<xpu, real_t> *ps)
NNet::PullReq	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->PullReq(grad, data_key, devid, -data_key,$/;"	p	language:C++	file:	signature:(grad, data_key, devid, -data_key, UpdateEntry::ApplyUpdate, new UpdateEntry(weight.FlatTo2D(), grad.FlatTo2D(), dim == 1))
NNet::Push	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->Push(grad, data_key, devid, -data_key);$/;"	p	language:C++	file:	signature:(grad, data_key, devid, -data_key)
NNet::Resize	include/NNet.h	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	signature:(Wh2o.shape_)
NNet::Resize	include/NNet.h	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	signature:(Wi2h.shape_)
NNet::Resize	include/NNet.h	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	signature:(hbias.shape_)
NNet::Resize	include/NNet.h	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	signature:(nhidden.shape_)
NNet::Resize	include/NNet.h	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	signature:(obias.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(Wh2o.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(Wi2h.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(hbias.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	file:	signature:(nhidden.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(obias.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(Wh2o.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(Wi2h.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(hbias.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	file:	signature:(nhidden.shape_)
NNet::Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(obias.shape_)
NNet::Shape1	include/NNet.h	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	signature:(num_hidden)
NNet::Shape1	include/NNet.h	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	signature:(num_out)
NNet::Shape1	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(num_hidden)
NNet::Shape1	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(num_out)
NNet::Shape1	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(num_hidden)
NNet::Shape1	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(num_out)
NNet::Shape2	include/NNet.h	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	signature:(num_hidden, num_out)
NNet::Shape2	include/NNet.h	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	signature:(num_in, num_hidden)
NNet::Shape2	include/NNet.h	/^    nhidden.Resize(Shape2(batch_size, num_hidden));$/;"	p	language:C++	signature:(batch_size, num_hidden)
NNet::Shape2	include/NNet.h	/^    ninput.Resize(Shape2(batch_size, num_in));$/;"	p	language:C++	signature:(batch_size, num_in)
NNet::Shape2	include/NNet.h	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	signature:(batch_size, num_out)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(num_hidden, num_out)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(num_in, num_hidden)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhidden.Resize(Shape2(batch_size, num_hidden));$/;"	p	language:C++	file:	signature:(batch_size, num_hidden)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    ninput.Resize(Shape2(batch_size, num_in));$/;"	p	language:C++	file:	signature:(batch_size, num_in)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(num_hidden, num_out)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(num_in, num_hidden)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhidden.Resize(Shape2(batch_size, num_hidden));$/;"	p	language:C++	file:	signature:(batch_size, num_hidden)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ninput.Resize(Shape2(batch_size, num_in));$/;"	p	language:C++	file:	signature:(batch_size, num_in)
NNet::Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
NNet::SyncProc	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  inline void SyncProc(mshadow::Tensor<xpu, dim> weight,$/;"	f	language:C++	class:NNet	access:public	signature:(mshadow::Tensor<xpu, dim> weight, mshadow::Tensor<xpu, dim> grad, int data_key)
NNet::Update	include/NNet.h	/^  virtual void Update(void) {$/;"	f	language:C++	class:NNet	access:public	signature:(void)
NNet::Update	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Update(void) {$/;"	f	language:C++	class:NNet	access:public	signature:(void)
NNet::UpdateEntry	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  struct UpdateEntry {$/;"	s	language:C++	class:NNet	file:	access:public
NNet::UpdateEntry::ApplyUpdate	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    inline static void ApplyUpdate(mshadow::Stream<xpu> *stream, void *arg) {$/;"	f	language:C++	struct:NNet::UpdateEntry	access:public	signature:(mshadow::Stream<xpu> *stream, void *arg)
NNet::UpdateEntry::Update	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      e->Update(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::UpdateEntry::Update	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    inline void Update(mshadow::Stream<xpu> *stream) {$/;"	f	language:C++	struct:NNet::UpdateEntry	access:public	signature:(mshadow::Stream<xpu> *stream)
NNet::UpdateEntry::UpdateEntry	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    UpdateEntry(mshadow::Tensor<xpu, 2> weight,$/;"	f	language:C++	struct:NNet::UpdateEntry	access:public	signature:(mshadow::Tensor<xpu, 2> weight, mshadow::Tensor<xpu, 2> grad, bool is_bias)
NNet::UpdateEntry::e	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      UpdateEntry *e = static_cast<UpdateEntry*>(arg);$/;"	l	language:C++
NNet::UpdateEntry::eta	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      const float eta = 0.8;$/;"	l	language:C++
NNet::UpdateEntry::grad	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::Tensor<xpu, 2> grad;$/;"	m	language:C++	struct:NNet::UpdateEntry	file:	access:public
NNet::UpdateEntry::is_bias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    bool is_bias;$/;"	m	language:C++	struct:NNet::UpdateEntry	file:	access:public
NNet::UpdateEntry::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      weight.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::UpdateEntry::wd	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      const float wd = 0.00001;$/;"	l	language:C++
NNet::UpdateEntry::weight	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::Tensor<xpu, 2> weight;$/;"	m	language:C++	struct:NNet::UpdateEntry	file:	access:public
NNet::Wait	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    stream->Wait();$/;"	p	language:C++	file:	signature:()
NNet::Wh2o	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
NNet::Wh2o	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::Wh2o	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::Wi2h	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
NNet::Wi2h	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::Wi2h	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::batch_size	include/NNet.h	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
NNet::batch_size	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
NNet::batch_size	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
NNet::devid	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int devid;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::eta	include/NNet.h	/^    const float eta = 0.8;$/;"	l	language:C++
NNet::eta	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    const float eta = 0.8;$/;"	l	language:C++
NNet::g_Wh2o	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
NNet::g_Wh2o	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_Wh2o	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_Wi2h	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
NNet::g_Wi2h	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_Wi2h	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_hbias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
NNet::g_hbias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_hbias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_obias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
NNet::g_obias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::g_obias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::hbias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
NNet::hbias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::hbias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::init	depparser/Depparser.cpp	/^	NNet::init(beamSize, num_in, num_hidden, num_out);	\/\/init the static member in the neural net$/;"	p	language:C++	class:NNet	file:	signature:(beamSize, num_in, num_hidden, num_out)
NNet::mshadow::DeleteStream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::DeleteStream(stream);$/;"	p	language:C++	class:NNet::mshadow	file:	signature:(stream)
NNet::mshadow::SetDevice	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::SetDevice<xpu>(devid);$/;"	p	language:C++	class:NNet::mshadow	file:	signature:(devid)
NNet::nhidden	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
NNet::nhidden	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::nhidden	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::nhiddenbak	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
NNet::nhiddenbak	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::nhiddenbak	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::ninput	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
NNet::ninput	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::ninput	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::nout	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
NNet::nout	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::nout	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::obias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
NNet::obias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::obias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::ps	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  mshadow::ps::ISharedModel<xpu, real_t> *ps;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::rnd	include/NNet.h	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:NNet	access:private
NNet::rnd	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::rnd	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::set_stream	include/NNet.h	/^    Wh2o.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    Wi2h.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    g_Wh2o.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    g_Wi2h.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    g_hbias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    g_obias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    hbias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    nhidden.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    ninput.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    nout.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	include/NNet.h	/^    obias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhidden.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    ninput.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nout.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhidden.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ninput.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nout.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    rnd.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
NNet::stream	include/NNet.h	/^    Stream<xpu> *stream = NewStream<xpu>();$/;"	l	language:C++
NNet::stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Stream<xpu> *stream = NewStream<xpu>();$/;"	l	language:C++
NNet::stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  mshadow::Stream<xpu> *stream;$/;"	m	language:C++	class:NNet	file:	access:private
NNet::wd	include/NNet.h	/^    const float wd = 0.00001;$/;"	l	language:C++
NNet::wd	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    const float wd = 0.00001;$/;"	l	language:C++
NNet::~NNet	include/NNet.h	/^  virtual ~NNet() {}$/;"	f	language:C++	class:NNet	access:public	signature:()
NNet::~NNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual ~NNet() {}$/;"	f	language:C++	class:NNet	access:public	signature:()
NNet::~NNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual ~NNet() {$/;"	f	language:C++	class:NNet	access:public	signature:()
NOMINMAX	include/mshadow/base.h	13;"	d	language:C++
NewStream	include/mshadow/stream_gpu-inl.h	/^inline Stream<gpu> *NewStream<gpu>(bool create_blas_handle,$/;"	f	language:C++	namespace:mshadow	signature:(bool create_blas_handle, bool create_dnn_handle)
NewStream	include/mshadow/tensor.h	/^inline Stream<Device> *NewStream() {$/;"	f	language:C++	namespace:mshadow	signature:()
NewStream	include/mshadow/tensor.h	/^inline Stream<Device> *NewStream(bool create_blas_handle,$/;"	p	language:C++	namespace:mshadow	signature:(bool create_blas_handle, bool create_dnn_handle)
NewStream	include/mshadow/tensor_cpu-inl.h	/^inline Stream<cpu> *NewStream<cpu>(bool create_blas_handle,$/;"	f	language:C++	namespace:mshadow	signature:(bool create_blas_handle, bool create_dnn_handle)
NewTensor	include/mshadow/tensor.h	/^inline Tensor<Device, dim, DType> NewTensor(const Shape<dim> &shape,$/;"	p	language:C++	namespace:mshadow	signature:(const Shape<dim> &shape, DType initv, bool pad = MSHADOW_ALLOC_PAD, Stream<Device> *stream = NULL)
NewTensor	include/mshadow/tensor_cpu-inl.h	/^NewTensor(const Shape<dim> &shape, DType initv, bool pad, Stream<Device> *stream_) {$/;"	f	language:C++	namespace:mshadow	signature:(const Shape<dim> &shape, DType initv, bool pad, Stream<Device> *stream_)
NoHandle	include/mshadow/stream_gpu-inl.h	/^    NoHandle = 0,$/;"	e	language:C++	enum:mshadow::Stream::HandleState
OPType	include/mshadow/base.h	/^  typedef op::div OPType;$/;"	t	language:C++	struct:mshadow::sv::divto	access:public
OPType	include/mshadow/base.h	/^  typedef op::minus OPType;$/;"	t	language:C++	struct:mshadow::sv::minusto	access:public
OPType	include/mshadow/base.h	/^  typedef op::mul OPType;$/;"	t	language:C++	struct:mshadow::sv::multo	access:public
OPType	include/mshadow/base.h	/^  typedef op::plus OPType;$/;"	t	language:C++	struct:mshadow::sv::plusto	access:public
OPType	include/mshadow/base.h	/^  typedef op::right OPType;$/;"	t	language:C++	struct:mshadow::sv::saveto	access:public
OwnHandle	include/mshadow/stream_gpu-inl.h	/^    OwnHandle = 1,$/;"	e	language:C++	enum:mshadow::Stream::HandleState
POS_OFFSET	depparser/Depparser.cpp	/^	int POS_OFFSET = 18;$/;"	l	language:C++
PSServer	include/mshadow-ps/ps_dist-inl.h	/^    typedef ::ps::KVLayer<DType, UpdaterWrapper<DType> > PSServer;$/;"	t	language:C++
PackColToPatchXExp	include/mshadow/extension/pack_col2patch.h	/^  PackColToPatchXExp(const SrcExp &src, Shape<dstdim> imshape,$/;"	f	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public	signature:(const SrcExp &src, Shape<dstdim> imshape, index_t psize_y, index_t psize_x, index_t pstride)
PackColToPatchXExp	include/mshadow/extension/pack_col2patch.h	/^struct PackColToPatchXExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
PaddingExp	include/mshadow/extension/pad.h	/^  PaddingExp(const SrcExp &src, index_t pad_y, index_t pad_x)$/;"	f	language:C++	struct:mshadow::expr::PaddingExp	access:public	signature:(const SrcExp &src, index_t pad_y, index_t pad_x)
PaddingExp	include/mshadow/extension/pad.h	/^struct PaddingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
Parent	include/mshadow-ps/ps_dist-inl.h	/^  typedef LocalModel<xpu, DType> Parent;$/;"	t	language:C++	class:mshadow::ps::DistModel	access:public
Parent	include/mshadow-ps/ps_rabit-inl.h	/^  typedef LocalModel<xpu, DType> Parent;$/;"	t	language:C++	class:mshadow::ps::RabitModel	access:public
PartialGrad	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType PartialGrad(DType redres, DType redsrc) {$/;"	f	language:C++	struct:mshadow::red::maximum	access:public	signature:(DType redres, DType redsrc)
PartialGrad	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType PartialGrad(DType redres, DType redsrc) {$/;"	f	language:C++	struct:mshadow::red::sum	access:public	signature:(DType redres, DType redsrc)
Plan	include/mshadow/expr_engine-inl.h	/^  Plan(const Plan<SubType, DType> &src) : src_(src) {}$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const Plan<SubType, DType> &src)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(DType scalar) : scalar_(scalar) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(DType scalar)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<EType, DType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<EType, DType> &src)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<EType, SrcDType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<EType, SrcDType> &src)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<TA, DType> &lhs, const Plan<TB, DType> &rhs)$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<TA, DType> &lhs, const Plan<TB, DType> &rhs)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<TA, DType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<TA, DType> &src)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Tensor<Device, 1, DType> &t) : dptr_(t.dptr_) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Tensor<Device, 1, DType> &t)
Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Tensor<Device, dim, DType> &t)$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Tensor<Device, dim, DType> &t)
Plan	include/mshadow/expr_engine-inl.h	/^class Plan {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<BinaryMapExp<OP, TA, TB, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<ScalarExp<DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<Tensor<Device, 1, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<Tensor<Device, dim, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<TransposeExp<EType, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<TypecastExp<DstDType, SrcDType, EType, etype>, DstDType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^class Plan<UnaryMapExp<OP, TA, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
Plan	include/mshadow/expr_engine-inl.h	/^struct Plan<MakeTensorExp<SubType, SrcExp, dim, DType>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/channel_pool.h	/^  explicit Plan(const ChannelPoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ChannelPoolingExp<Reducer, SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/channel_pool.h	/^struct Plan<ChannelPoolingExp<Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/channel_unpool.h	/^  explicit Plan(const ChannelUnpoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ChannelUnpoolingExp<Reducer, SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/channel_unpool.h	/^struct Plan<ChannelUnpoolingExp<Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/concat.h	/^  explicit Plan(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, 1> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, 1> &e)
Plan	include/mshadow/extension/concat.h	/^  explicit Plan(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, dimsrc_m_cat> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, dimsrc_m_cat> &e)
Plan	include/mshadow/extension/concat.h	/^struct Plan<ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, 1>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/concat.h	/^struct Plan<ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, dimsrc_m_cat>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/crop.h	/^  explicit Plan(const CroppingExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const CroppingExp<SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/crop.h	/^struct Plan<CroppingExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/mirror.h	/^  explicit Plan(const MirroringExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const MirroringExp<SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/mirror.h	/^struct Plan<MirroringExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/pack_col2patch.h	/^  explicit Plan(const PackColToPatchXExp<SrcExp, DType, dstdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const PackColToPatchXExp<SrcExp, DType, dstdim> &e)
Plan	include/mshadow/extension/pack_col2patch.h	/^struct Plan<PackColToPatchXExp<SrcExp, DType, dstdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/pad.h	/^  explicit Plan(const PaddingExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const PaddingExp<SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/pad.h	/^struct Plan<PaddingExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/reshape.h	/^  explicit Plan(const ReshapeExp<SrcExp, DType, dimdst, 1> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ReshapeExp<SrcExp, DType, dimdst, 1> &e)
Plan	include/mshadow/extension/reshape.h	/^  explicit Plan(const ReshapeExp<SrcExp, DType, dimdst, dimsrc> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ReshapeExp<SrcExp, DType, dimdst, dimsrc> &e)
Plan	include/mshadow/extension/reshape.h	/^struct Plan<ReshapeExp<SrcExp, DType, dimdst, 1>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/reshape.h	/^struct Plan<ReshapeExp<SrcExp, DType, dimdst, dimsrc>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/spatial_pool.h	/^  explicit Plan(const PoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const PoolingExp<Reducer, SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/spatial_pool.h	/^struct Plan<PoolingExp< Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/spatial_unpool.h	/^  explicit Plan(const UnPoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnPoolingExp<Reducer, SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/spatial_unpool.h	/^struct Plan<UnPoolingExp<Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/swapaxis.h	/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)
Plan	include/mshadow/extension/swapaxis.h	/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)
Plan	include/mshadow/extension/swapaxis.h	/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, 1, a2>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/swapaxis.h	/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	include/mshadow/extension/unpack_patch2col.h	/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)
Plan	include/mshadow/extension/unpack_patch2col.h	/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
Plan	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	s	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
Plan	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	s	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
PoolingExp	include/mshadow/extension/spatial_pool.h	/^  PoolingExp(const SrcExp &src, Shape<2> pshape,$/;"	f	language:C++	struct:mshadow::expr::PoolingExp	access:public	signature:(const SrcExp &src, Shape<2> pshape, index_t ksize_y, index_t ksize_x, index_t kstride)
PoolingExp	include/mshadow/extension/spatial_pool.h	/^  PoolingExp(const SrcExp &src,$/;"	f	language:C++	struct:mshadow::expr::PoolingExp	access:public	signature:(const SrcExp &src, index_t ksize_y, index_t ksize_x, index_t kstride)
PoolingExp	include/mshadow/extension/spatial_pool.h	/^struct PoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
Pop	include/mshadow-ps/thread_util.h	/^  inline bool Pop(DType *data_out) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(DType *data_out)
Post	include/mshadow-ps/thread.h	/^  inline void Post(void) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(void)
Post	include/mshadow-ps/thread_util.h	/^      counter_.Post();$/;"	p	language:C++	signature:()
Post	include/mshadow-ps/thread_util.h	/^    counter_.Post();$/;"	p	language:C++	signature:()
Print	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^inline void Print(mshadow::Tensor<xpu, 2, float> ts) {$/;"	f	language:C++	signature:(mshadow::Tensor<xpu, 2, float> ts)
Print_	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^void Print_(mshadow::Tensor<mshadow::cpu, 2, float> ts) {$/;"	f	language:C++	signature:(mshadow::Tensor<mshadow::cpu, 2, float> ts)
ProdShape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t ProdShape(int dimstart, int dimend) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(int dimstart, int dimend) const
PullEntry	include/mshadow-ps/ps_local-inl.h	/^    PullEntry(void) {$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public	signature:(void)
PullEntry	include/mshadow-ps/ps_local-inl.h	/^  struct PullEntry {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
PullGlobalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PullGlobalThread(void *arg) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *arg)
PullHandlerGlobal	include/mshadow-ps/ps_local-inl.h	/^  inline void PullHandlerGlobal(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void)
PullHandlerLocal	include/mshadow-ps/ps_local-inl.h	/^  inline void PullHandlerLocal(size_t tid) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(size_t tid)
PullLocalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PullLocalThread(void *arg) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *arg)
PullProc	include/mshadow-ps/ps_local-inl.h	/^  inline void PullProc(utils::ThreadPQueue<std::pair<int, int> > *queue) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(utils::ThreadPQueue<std::pair<int, int> > *queue)
PullReady	include/mshadow-ps/ps_local-inl.h	/^  virtual void PullReady(Tensor<cpu, 2> data, int key) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 2> data, int key)
PullReq	include/mshadow-ps/mshadow_ps.h	/^  inline void PullReq(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid, int priority = 0, CallbackFunction callback = NULL, void *callback_arg = NULL)
PullReq	include/mshadow-ps/mshadow_ps.h	/^  inline void PullReq(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid, int priority, std::function<void(Stream<xpu> *stream)> callback)
PullReq	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  ps->PullReq(data[0], 0, devid);$/;"	p	language:C++	file:	signature:(data[0], 0, devid)
PullReq	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  ps->PullReq(data[1], 1, devid);$/;"	p	language:C++	file:	signature:(data[1], 1, devid)
PullReq	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->PullReq(data[0], 0, devid);$/;"	p	language:C++	signature:(data[0], 0, devid)
PullReq	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->PullReq(data[1], 1, devid);$/;"	p	language:C++	signature:(data[1], 1, devid)
PullReq	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->PullReq(data[0], 0, devid);$/;"	p	language:C++	signature:(data[0], 0, devid)
PullReq	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->PullReq(data[1], 1, devid);$/;"	p	language:C++	signature:(data[1], 1, devid)
PullReq	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->PullReq(grad, data_key, devid, -data_key,$/;"	p	language:C++	file:	signature:(grad, data_key, devid, -data_key, UpdateEntry::ApplyUpdate, new UpdateEntry(weight.FlatTo2D(), grad.FlatTo2D(), dim == 1))
PullReqRecord	include/mshadow-ps/ps_local-inl.h	/^    PullReqRecord(void) : ready(false), pending(false) {$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public	signature:(void)
PullReqRecord	include/mshadow-ps/ps_local-inl.h	/^  struct PullReqRecord {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
PullReq_	include/mshadow-ps/mshadow_ps.h	/^  virtual void PullReq_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority, CallbackFunction callback, void *callback_arg)
PullReq_	include/mshadow-ps/ps_local-inl.h	/^  virtual void PullReq_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority, CallbackFunction callback, void *callback_arg)
PullTask	include/mshadow-ps/ps_local-inl.h	/^      push_queues[0].Push(PullTask(data, key, devid), priority);$/;"	p	language:C++	signature:(data, key, devid)
PullTask	include/mshadow-ps/ps_local-inl.h	/^      push_queues[wid].Push(PullTask(data, key, devid), priority);$/;"	p	language:C++	signature:(data, key, devid)
PullTask	include/mshadow-ps/ps_local-inl.h	/^    PullTask(Tensor<xpu, 2, DType> data, int key, int devid)$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
PullTask	include/mshadow-ps/ps_local-inl.h	/^    PullTask(void) {}$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public	signature:(void)
PullTask	include/mshadow-ps/ps_local-inl.h	/^  struct PullTask {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
PullWait	include/mshadow-ps/mshadow_ps.h	/^  virtual void PullWait(int key, int devid) = 0;$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(int key, int devid)
PullWait	include/mshadow-ps/ps_local-inl.h	/^  virtual void PullWait(int key, int devid) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(int key, int devid)
PullWaitRecord	include/mshadow-ps/ps_local-inl.h	/^    PullWaitRecord(void)$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullWaitRecord	access:public	signature:(void)
PullWaitRecord	include/mshadow-ps/ps_local-inl.h	/^  struct PullWaitRecord {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
Push	include/mshadow-ps/mshadow_ps.h	/^  inline void Push(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid, int priority = 0)
Push	include/mshadow-ps/ps_rabit-inl.h	/^    reduce_queue_.Push(tsk, 0);$/;"	p	language:C++	signature:(tsk, 0)
Push	include/mshadow-ps/thread_util.h	/^  inline void Push(const DType &data, int priority = 0) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(const DType &data, int priority = 0)
Push	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  ps->Push(data[0], 0, devid);$/;"	p	language:C++	file:	signature:(data[0], 0, devid)
Push	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  ps->Push(data[1], 1, devid);$/;"	p	language:C++	file:	signature:(data[1], 1, devid)
Push	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->Push(data[0], 0, devid);$/;"	p	language:C++	signature:(data[0], 0, devid)
Push	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  ps->Push(data[1], 1, devid);$/;"	p	language:C++	signature:(data[1], 1, devid)
Push	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->Push(data[0], 0, devid);$/;"	p	language:C++	signature:(data[0], 0, devid)
Push	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  ps->Push(data[1], 1, devid);$/;"	p	language:C++	signature:(data[1], 1, devid)
Push	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ps->Push(grad, data_key, devid, -data_key);$/;"	p	language:C++	file:	signature:(grad, data_key, devid, -data_key)
PushEntry	include/mshadow-ps/ps_local-inl.h	/^    PushEntry(void)$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public	signature:(void)
PushEntry	include/mshadow-ps/ps_local-inl.h	/^  struct PushEntry {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
PushGlobalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PushGlobalThread(void *pthread) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *pthread)
PushHandlerGlobal	include/mshadow-ps/ps_local-inl.h	/^  inline void PushHandlerGlobal(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void)
PushHandlerLocal	include/mshadow-ps/ps_local-inl.h	/^  inline void PushHandlerLocal(size_t tid) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(size_t tid)
PushLocalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PushLocalThread(void *arg) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *arg)
PushProc	include/mshadow-ps/ps_local-inl.h	/^  inline void PushProc(utils::ThreadPQueue<PullTask> *queue) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(utils::ThreadPQueue<PullTask> *queue)
Push_	include/mshadow-ps/mshadow_ps.h	/^  virtual void Push_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority = 0)
Push_	include/mshadow-ps/ps_local-inl.h	/^  virtual void Push_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority)
REval	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      dst.REval(y, x + threadIdx.x) = p;$/;"	p	language:C++	file:	signature:(y, x + threadIdx.x)
REval	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      dst.REval(y, x + threadIdx.x) \/= ssum;$/;"	p	language:C++	file:	signature:(y, x + threadIdx.x)
REval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType &REval(index_t y, index_t x) {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x)
REval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType &REval(index_t i, index_t j) {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j)
REval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType &REval(index_t y, index_t x) {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x)
RValueExp	include/mshadow/expression.h	/^class RValueExp: public Exp<Container, DType, type::kRValue> {$/;"	c	language:C++	namespace:mshadow::expr	inherits:Exp
RabitModel	include/mshadow-ps/ps_rabit-inl.h	/^  RabitModel() {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:()
RabitModel	include/mshadow-ps/ps_rabit-inl.h	/^class RabitModel : public LocalModel<xpu, DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:LocalModel
RandNext	include/mshadow/random.h	/^  inline DType RandNext(void) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(void)
RandNext2	include/mshadow/random.h	/^  inline DType RandNext2(void) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(void)
Random	include/mshadow/random.h	/^  explicit Random(int seed) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(int seed)
Random	include/mshadow/random.h	/^class Random {};$/;"	c	language:C++	namespace:mshadow
Random	include/mshadow/random.h	/^class Random<cpu, DType> {$/;"	c	language:C++	namespace:mshadow
Random	include/mshadow/random.h	/^class Random<gpu, DType> {$/;"	c	language:C++	namespace:mshadow
Read	include/mshadow/io.h	/^  virtual size_t Read(void *ptr, size_t size) = 0;$/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)
Read	tags	/^mshadow::utils::IStream::Read	include\/mshadow\/io.h	\/^  virtual size_t Read(void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(void *ptr, size_t size)
ReadConfig	depparser/Config.cpp	/^ReadConfig(const char * pszPath)$/;"	f	language:C++	class:CConfig	signature:(const char * pszPath)
ReadConfig	depparser/Config.h	/^	static bool ReadConfig(const char *pszPath);$/;"	p	language:C++	class:CConfig	access:public	signature:(const char *pszPath)
Recycle	include/Pool.cpp	/^void CPool::Recycle()$/;"	f	language:C++	class:CPool	signature:()
Recycle	include/Pool.h	/^	void Recycle();$/;"	p	language:C++	class:CPool	access:public	signature:()
Reduce	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Reduce(volatile DType& dst,  volatile DType src) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::maximum	access:public	signature:(volatile DType& dst, volatile DType src)
Reduce	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Reduce(volatile DType& dst,  volatile DType src) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::sum	access:public	signature:(volatile DType& dst, volatile DType src)
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 1) Reducer::Reduce(buf[tid] , buf[tid + 1]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 1])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 128) Reducer::Reduce(buf[tid] , buf[tid + 128]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 128])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 16) Reducer::Reduce(buf[tid] , buf[tid + 16]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 16])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 2) Reducer::Reduce(buf[tid] , buf[tid + 2]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 2])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 256) Reducer::Reduce(buf[tid] , buf[tid + 256]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 256])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 32) Reducer::Reduce(buf[tid] , buf[tid + 32]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 32])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 4) Reducer::Reduce(buf[tid] , buf[tid + 4]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 4])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 512) Reducer::Reduce(buf[tid] , buf[tid + 512]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 512])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 64) Reducer::Reduce(buf[tid] , buf[tid + 64]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 64])
Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 8) Reducer::Reduce(buf[tid] , buf[tid + 8]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 8])
Reduce	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      Reducer::Reduce(res, plan.Eval((n * pshape[1] + c) * pshape[2] + y, x));$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(res, plan.Eval((n * pshape[1] + c) * pshape[2] + y, x))
Reduce	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      Reducer::Reduce(s_res[threadIdx.x][threadIdx.y], plan.Eval(threadIdx.y + y, x));$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(s_res[threadIdx.x][threadIdx.y], plan.Eval(threadIdx.y + y, x))
Reduce	include/mshadow/extension/spatial_pool.h	/^        Reducer::Reduce(res, src_.Eval(c * src_height_ + y, x));$/;"	p	language:C++	class:mshadow::expr::Plan::Reducer	signature:(res, src_.Eval(c * src_height_ + y, x))
Reduce	include/mshadow/tensor_cpu-inl.h	/^          Reducer::Reduce(tres,$/;"	p	language:C++	class:mshadow::Reducer	signature:(tres, splan.Eval((n * pshape[1] + c) * pshape[2] + y, x))
Reduce	include/mshadow/tensor_cpu-inl.h	/^      Reducer::Reduce(res, splan.Eval(y, x));$/;"	p	language:C++	class:mshadow::Reducer	signature:(res, splan.Eval(y, x))
Reduce	include/mshadow/tensor_cpu-inl.h	/^      Reducer::Reduce(res, tres);$/;"	p	language:C++	class:mshadow::Reducer	signature:(res, tres)
Reduce1D	include/mshadow/cuda/reduce.cuh	/^inline __device__ void Reduce1D(volatile DType buf[1 << x_bits]) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(volatile DType buf[1 << x_bits])
Reduce1D	include/mshadow/cuda/reduce.cuh	/^inline __device__ void Reduce1D(volatile DType buf[1 << x_bits]);$/;"	p	language:C++	namespace:mshadow::cuda	file:	signature:(volatile DType buf[1 << x_bits])
Reduce1DNotAlign	include/mshadow/cuda/reduce.cuh	/^Reduce1DNotAlign(volatile DType buf[1 << xmax_bits], int xsize);$/;"	p	language:C++	namespace:mshadow::cuda	file:	signature:(volatile DType buf[1 << xmax_bits], int xsize)
Reduce1DNotAlign	include/mshadow/cuda/reduce.cuh	/^inline __device__ void Reduce1DNotAlign(volatile DType buf[], int x_size) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(volatile DType buf[], int x_size)
ReduceGlobalThread	include/mshadow-ps/ps_rabit-inl.h	/^  inline static MSHADOW_THREAD_PREFIX ReduceGlobalThread(void *pthread) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:private	signature:(void *pthread)
ReduceHandler	include/mshadow-ps/ps_rabit-inl.h	/^  inline void ReduceHandler(void) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:private	signature:(void)
ReduceSum	include/mshadow-ps/ps_dist-inl.h	/^    LocalModel<xpu, DType>::ReduceSum(data);$/;"	p	language:C++	class:mshadow::ps::DistModel::LocalModel	signature:(data)
ReduceSum	include/mshadow-ps/ps_local-inl.h	/^  inline void ReduceSum(Tensor<cpu, 3, DType> data) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 3, DType> data)
ReduceSum	include/mshadow-ps/ps_rabit-inl.h	/^    LocalModel<xpu, DType>::ReduceSum(data);$/;"	p	language:C++	class:mshadow::ps::RabitModel::LocalModel	signature:(data)
ReduceTask	include/mshadow-ps/ps_rabit-inl.h	/^  struct ReduceTask {$/;"	s	language:C++	class:mshadow::ps::RabitModel	access:private
ReduceTo1DExp	include/mshadow/extension/reduceto1d.h	/^  ReduceTo1DExp(const SrcExp& src, DType scale) : src_(src), scale_(scale) {}$/;"	f	language:C++	struct:mshadow::expr::ReduceTo1DExp	access:public	signature:(const SrcExp& src, DType scale)
ReduceTo1DExp	include/mshadow/extension/reduceto1d.h	/^struct ReduceTo1DExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
ReduceX	include/mshadow/cuda/reduce.cuh	/^inline __device__ void ReduceX(volatile DType  buf[], int tid) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(volatile DType buf[], int tid)
ReleaseSemaphore	include/mshadow-ps/thread.h	/^    utils::Check(ReleaseSemaphore(sem, 1, NULL) != 0, "ReleaseSemaphore error");$/;"	p	language:C++	class:mshadow::utils::Semaphore::utils	signature:(sem, 1, NULL)
Request	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key), weight.dptr_, weight.MSize(),$/;"	p	language:C++	signature:(key)
Request	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key, -1, {ts}), sendrecv.dptr_, sendrecv.MSize(),$/;"	p	language:C++	signature:(key, -1, {ts})
ReshapeExp	include/mshadow/extension/reshape.h	/^  ReshapeExp(const SrcExp &src, Shape<dimdst> shape)$/;"	f	language:C++	struct:mshadow::expr::ReshapeExp	access:public	signature:(const SrcExp &src, Shape<dimdst> shape)
ReshapeExp	include/mshadow/extension/reshape.h	/^struct ReshapeExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
Resize	include/NNet.h	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	signature:(Wh2o.shape_)
Resize	include/NNet.h	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	signature:(Wi2h.shape_)
Resize	include/NNet.h	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	signature:(hbias.shape_)
Resize	include/NNet.h	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	signature:(nhidden.shape_)
Resize	include/NNet.h	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	signature:(obias.shape_)
Resize	include/mshadow-ps/ps_local-inl.h	/^    tmp.Resize(data.shape_);$/;"	p	language:C++	signature:(data.shape_)
Resize	include/mshadow/tensor_container.h	/^  inline void Resize(const Shape<dimension> &shape) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape)
Resize	include/mshadow/tensor_container.h	/^  inline void Resize(const Shape<dimension> &shape, DType initv) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape, DType initv)
Resize	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  tmp.Resize(ts.shape_);$/;"	p	language:C++	signature:(ts.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Ki2h.Resize(Shape2(nchannel, ksize*ksize));  g_Ki2h.Resize(Ki2h.shape_);$/;"	p	language:C++	file:	signature:(Ki2h.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Wh2o.Resize(Shape2(nflat.size(1), num_out));   g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(Wh2o.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    hbias.Resize(Shape1(nchannel)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(hbias.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	file:	signature:(nhidden.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npoolbak.Resize(npool.shape_);$/;"	p	language:C++	file:	signature:(npool.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    obias.Resize(Shape1(num_out));  g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(obias.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(Wh2o.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(Wi2h.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(hbias.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	file:	signature:(nhidden.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(obias.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(Wh2o.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(Wi2h.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(hbias.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhiddenbak.Resize(nhidden.shape_);$/;"	p	language:C++	file:	signature:(nhidden.shape_)
Resize	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(obias.shape_)
Run	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^inline int Run(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
Run	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^inline int Run(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
Run	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^inline int Run(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
RunWorkerThread	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^inline void RunWorkerThread(int devid,$/;"	f	language:C++	signature:(int devid, mshadow::ps::ISharedModel<xpu, float> *ps)
RunWorkerThread	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^inline void RunWorkerThread(int devid,$/;"	f	language:C++	signature:(int devid, mshadow::ps::ISharedModel<xpu, float> *ps)
SBlock	include/Pool.h	/^	struct SBlock$/;"	s	language:C++	class:CPool	access:private
SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck {$/;"	s	language:C++	namespace:mshadow::expr
SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, Tensor<cpu, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck< BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck<ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck<Tensor<cpu, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck<UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck{$/;"	s	language:C++	namespace:mshadow::expr
SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::div> {$/;"	s	language:C++	namespace:mshadow::sse2
SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::identity> {$/;"	s	language:C++	namespace:mshadow::sse2
SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::minus> {$/;"	s	language:C++	namespace:mshadow::sse2
SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::mul> {$/;"	s	language:C++	namespace:mshadow::sse2
SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::plus> {$/;"	s	language:C++	namespace:mshadow::sse2
SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp{$/;"	s	language:C++	namespace:mshadow::sse2
SSEPlan	include/mshadow/sse-inl.h	/^  SSEPlan(const SSEPlan<TA, DType> &lhs, const SSEPlan<TB, DType> &rhs)$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(const SSEPlan<TA, DType> &lhs, const SSEPlan<TB, DType> &rhs)
SSEPlan	include/mshadow/sse-inl.h	/^  SSEPlan(const SSEPlan<TA, DType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(const SSEPlan<TA, DType> &src)
SSEPlan	include/mshadow/sse-inl.h	/^  explicit SSEPlan(DType scalar) : scalar_(scalar) {}$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(DType scalar)
SSEPlan	include/mshadow/sse-inl.h	/^  explicit SSEPlan(const Tensor<Device, dim, DType> &t)$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(const Tensor<Device, dim, DType> &t)
SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan {$/;"	c	language:C++	namespace:mshadow::expr
SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<BinaryMapExp<OP, TA, TB, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<ScalarExp<DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<Tensor<Device, dim, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<UnaryMapExp<OP, TA, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
STACK_NUMBER	depparser/Depparser.cpp	/^	int STACK_NUMBER = 6;$/;"	l	language:C++
STACK_OFFSET	depparser/Depparser.cpp	/^	int STACK_OFFSET = 6;$/;"	l	language:C++
SampleGaussian	include/mshadow/random.h	/^  inline void SampleGaussian(Tensor<cpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<cpu, dim, DType> *dst, DType mu = 0.0f, DType sigma = 1.0f)
SampleGaussian	include/mshadow/random.h	/^  inline void SampleGaussian(Tensor<gpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<gpu, dim, DType> *dst, DType mu = 0.0f, DType sigma = 1.0f)
SampleGuassian	include/FeatureEmbedding.h	/^		rnd.SampleGuassian( featEmbeddings, 0, CConfig::fInitRange );$/;"	p	language:C++	signature:( featEmbeddings, 0, CConfig::fInitRange )
SampleNormal2D	include/mshadow/random.h	/^  inline void SampleNormal2D(DType *xx_, DType *yy_) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(DType *xx_, DType *yy_)
SampleUniform	include/mshadow/random.h	/^  inline void SampleUniform(Tensor<cpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<cpu, dim, DType> *dst, DType a = 0.0f, DType b = 1.0f)
SampleUniform	include/mshadow/random.h	/^  inline void SampleUniform(Tensor<gpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<gpu, dim, DType> *dst, DType a = 0.0f, DType b = 1.0f)
Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::minusto	access:public	signature:(DType &a, DType b)
Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::multo	access:public	signature:(DType &a, DType b)
Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::plusto	access:public	signature:(DType &a, DType b)
Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::saveto	access:public	signature:(DType &a, DType b)
Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType& a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::divto	access:public	signature:(DType& a, DType b)
Save	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    Saver::Save(dst.REval(0, c), s_rec[0] * scale);$/;"	p	language:C++	class:mshadow::cuda::Saver	file:	signature:(dst.REval(0, c), s_rec[0] * scale)
Save	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    Saver::Save(dst.REval(0, x),  s_res[threadIdx.x][0] * scale);$/;"	p	language:C++	class:mshadow::cuda::Saver	file:	signature:(dst.REval(0, x), s_res[threadIdx.x][0] * scale)
Save	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    Saver::Save(dst.REval(y, x), exp.Eval(y,x));$/;"	p	language:C++	class:mshadow::cuda::Saver	file:	signature:(dst.REval(y, x), exp.Eval(y,x))
Save	include/mshadow/sse-inl.h	/^      SV::Save(dst[y][x], plan.Eval(y, x));$/;"	p	language:C++	class:mshadow::expr::SV	signature:(dst[y][x], plan.Eval(y, x))
Save	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE static void Save(TFloat *dst, const FVec<TFloat> &src) {$/;"	f	language:C++	struct:mshadow::sse2::Saver	access:public	signature:(TFloat *dst, const FVec<TFloat> &src)
Save	include/mshadow/tensor_cpu-inl.h	/^      Saver::Save(dplan.REval(y, x), plan.Eval(y, x));$/;"	p	language:C++	class:mshadow::Saver	signature:(dplan.REval(y, x), plan.Eval(y, x))
Save	include/mshadow/tensor_cpu-inl.h	/^    Saver::Save(dplan.REval(0, c), res * scale);$/;"	p	language:C++	class:mshadow::Saver	signature:(dplan.REval(0, c), res * scale)
Save	include/mshadow/tensor_cpu-inl.h	/^    Saver::Save(dplan.REval(0, x), res * scale);$/;"	p	language:C++	class:mshadow::Saver	signature:(dplan.REval(0, x), res * scale)
SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src);  \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)
SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src_) { \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src_)
SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src) { \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)
SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src); \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)
SaveBinary	include/mshadow/tensor_container.h	/^    mshadow::SaveBinary(fo, *this);$/;"	p	language:C++	class:mshadow::TensorContainer::mshadow	signature:(fo, *this)
SaveBinary	include/mshadow/tensor_container.h	/^  inline void SaveBinary(TStream &fo) const { \/\/ NOLINT(*)$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(TStream &fo) const
SaveBinary	tags	/^mshadow::SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src);  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)
SaveBinary	tags	/^mshadow::SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src); \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)
SaveConfig	depparser/Config.cpp	/^bool CConfig::SaveConfig(const char *pszPath)$/;"	f	language:C++	class:CConfig	signature:(const char *pszPath)
SaveConfig	depparser/Config.h	/^	static bool SaveConfig(const char *pszPath);$/;"	p	language:C++	class:CConfig	access:public	signature:(const char *pszPath)
Saver	include/mshadow/sse-inl.h	/^struct Saver<sv::saveto, TFloat> {$/;"	s	language:C++	namespace:mshadow::sse2
Saver	include/mshadow/sse-inl.h	/^struct Saver{$/;"	s	language:C++	namespace:mshadow::sse2
ScalarExp	include/mshadow/expression.h	/^  ScalarExp(DType scalar) : scalar_(scalar) {}  \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::expr::ScalarExp	access:public	signature:(DType scalar)
ScalarExp	include/mshadow/expression.h	/^struct ScalarExp: public Exp<ScalarExp<DType>, DType, type::kMapper> {$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
ScoredTransitionMore	depparser/Depparser.cpp	/^ScoredTransitionMore(const CScoredTransition& x, const CScoredTransition& y) {$/;"	f	language:C++	signature:(const CScoredTransition& x, const CScoredTransition& y)
Seed	include/mshadow/random.h	/^  inline void Seed(int seed) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(int seed)
Semaphore	include/mshadow-ps/thread.h	/^class Semaphore {$/;"	c	language:C++	namespace:mshadow::utils
ServerInitKey	include/mshadow-ps/ps_dist-inl.h	/^  virtual void ServerInitKey(Tensor<cpu, 2> weight, int key) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:protected	signature:(Tensor<cpu, 2> weight, int key)
ServerInitKey	include/mshadow-ps/ps_local-inl.h	/^  virtual void ServerInitKey(Tensor<cpu, 2> weight, int key) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 2> weight, int key)
SetDevice	include/mshadow/tensor.h	/^inline void SetDevice(int devid);$/;"	p	language:C++	namespace:mshadow	signature:(int devid)
SetDevice	include/mshadow/tensor_cpu-inl.h	/^inline void SetDevice<cpu>(int devid) {$/;"	f	language:C++	namespace:mshadow	signature:(int devid)
SetDevice	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      mshadow::SetDevice<xpu>(devs[tid]);$/;"	p	language:C++	class:mshadow	file:	signature:(devs[tid])
SetDevice	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::SetDevice<xpu>(devid);$/;"	p	language:C++	class:NNet::mshadow	file:	signature:(devid)
SetDevice	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::SetDevice<xpu>(devs[i]);$/;"	p	language:C++	class:mshadow	file:	signature:(devs[i])
SetDim	include/mshadow/tensor_blob.h	/^  inline void SetDim(index_t dim) {$/;"	f	language:C++	struct:mshadow::TShape	access:private	signature:(index_t dim)
SetInitValue	include/mshadow/base.h	/^  MSHADOW_XINLINE static void SetInitValue(DType &initv) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::maximum	access:public	signature:(DType &initv)
SetInitValue	include/mshadow/base.h	/^  MSHADOW_XINLINE static void SetInitValue(DType &initv) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::sum	access:public	signature:(DType &initv)
SetInitValue	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType res; Reducer::SetInitValue(res);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(res)
SetInitValue	include/mshadow/extension/spatial_pool.h	/^    DType res; Reducer::SetInitValue(res);$/;"	p	language:C++	class:mshadow::expr::Plan::Reducer	signature:(res)
SetInitValue	include/mshadow/tensor_cpu-inl.h	/^      DType tres; Reducer::SetInitValue(tres);$/;"	p	language:C++	class:mshadow::Reducer	signature:(tres)
SetInitValue	include/mshadow/tensor_cpu-inl.h	/^    DType res; Reducer::SetInitValue(res);$/;"	p	language:C++	class:mshadow::Reducer	signature:(res)
SetParam	include/mshadow-ps/mshadow_ps.h	/^  virtual void SetParam(const char *name, const char *val) {}$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(const char *name, const char *val)
SetParam	include/mshadow-ps/mshadow_ps.h	/^  virtual void SetParam(const char *name, const char *val) {}$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(const char *name, const char *val)
SetParam	include/mshadow-ps/ps_local-inl.h	/^        custom_server->SetParam(cfgvec[j].first.c_str(),$/;"	p	language:C++	signature:(cfgvec[j].first.c_str(), cfgvec[j].second.c_str())
SetParam	include/mshadow-ps/ps_local-inl.h	/^  virtual void SetParam(const char *name, const char *val) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(const char *name, const char *val)
SetParam	include/mshadow-ps/ps_rabit-inl.h	/^    Parent::SetParam(name, val);$/;"	p	language:C++	class:mshadow::ps::RabitModel::Parent	signature:(name, val)
SetParam	include/mshadow-ps/ps_rabit-inl.h	/^  virtual void SetParam(const char *name, const char *val) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(const char *name, const char *val)
SetStream	include/mshadow/dot_engine-inl.h	/^    BLASEngine<xpu>::SetStream(dst.stream_);$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_)
SetStream	include/mshadow/dot_engine-inl.h	/^  inline static void SetStream(Stream<cpu> *stream) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream)
SetStream	include/mshadow/dot_engine-inl.h	/^  inline static void SetStream(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream)
SetWeight_	include/mshadow-ps/mshadow_ps.h	/^  virtual void SetWeight_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
SetWeight_	include/mshadow-ps/ps_local-inl.h	/^  virtual void SetWeight_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
Shape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape(const Shape<kDimension> &s) {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(const Shape<kDimension> &s)
Shape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape(void) {}$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void)
Shape	include/mshadow/tensor.h	/^struct Shape {$/;"	s	language:C++	namespace:mshadow
Shape	thirdparty/mshadow/guide/README.md	/^struct Shape {$/;"	s	language:C++	file:
Shape	thirdparty/mshadow/guide/README.md	/^struct Shape<2> {$/;"	s	language:C++	file:
Shape1	include/NNet.h	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	signature:(num_hidden)
Shape1	include/NNet.h	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	signature:(num_out)
Shape1	include/mshadow/random.h	/^    buffer_.Resize(Shape1(aligned_sz));$/;"	p	language:C++	signature:(aligned_sz)
Shape1	include/mshadow/random.h	/^    buffer_.Resize(Shape1(kRandBufferSize));$/;"	p	language:C++	signature:(kRandBufferSize)
Shape1	include/mshadow/random.h	/^    buffer_.Resize(Shape1(shape.Size()));$/;"	p	language:C++	signature:(shape.Size())
Shape1	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<1> Shape1(index_t s0) {$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0)
Shape1	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    hbias.Resize(Shape1(nchannel)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(nchannel)
Shape1	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    obias.Resize(Shape1(num_out));  g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(num_out)
Shape1	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(num_hidden)
Shape1	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(num_out)
Shape1	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    hbias.Resize(Shape1(num_hidden)); g_hbias.Resize(hbias.shape_);$/;"	p	language:C++	file:	signature:(num_hidden)
Shape1	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    obias.Resize(Shape1(num_out)); g_obias.Resize(obias.shape_);$/;"	p	language:C++	file:	signature:(num_out)
Shape2	depparser/Depparser.cpp	/^						input.Resize(Shape2(beamSize, num_out));$/;"	p	language:C++	file:	signature:(beamSize, num_out)
Shape2	depparser/Depparser.cpp	/^			input.Resize( Shape2( beamSize, num_out ) );$/;"	p	language:C++	file:	signature:(beamSize, num_out )
Shape2	depparser/Depparser.cpp	/^			pred.Resize( Shape2( beamSize, num_out ) );$/;"	p	language:C++	file:	signature:(beamSize, num_out )
Shape2	include/FeatureEmbedding.h	/^		featEmbeddings.Resize( Shape2( featureNum, embeddingSize ) );$/;"	p	language:C++	signature:(featureNum, embeddingSize )
Shape2	include/FeatureEmbedding.h	/^		input.Resize( Shape2( beamSize, inputSize ) );$/;"	p	language:C++	signature:(beamSize, inputSize )
Shape2	include/NNet.h	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	signature:(num_hidden, num_out)
Shape2	include/NNet.h	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	signature:(num_in, num_hidden)
Shape2	include/NNet.h	/^    nhidden.Resize(Shape2(batch_size, num_hidden));$/;"	p	language:C++	signature:(batch_size, num_hidden)
Shape2	include/NNet.h	/^    ninput.Resize(Shape2(batch_size, num_in));$/;"	p	language:C++	signature:(batch_size, num_in)
Shape2	include/NNet.h	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	signature:(batch_size, num_out)
Shape2	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<2> Shape2(index_t s0, index_t s1) {$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0, index_t s1)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Ki2h.Resize(Shape2(nchannel, ksize*ksize));  g_Ki2h.Resize(Ki2h.shape_);$/;"	p	language:C++	file:	signature:(nchannel, ksize*ksize)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Wh2o.Resize(Shape2(nflat.size(1), num_out));   g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(nflat.size(1), num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nflat.Resize(Shape2(batch_size, npool.size(1)*npool.size(2)*npool.size(3)));$/;"	p	language:C++	file:	signature:(batch_size, npool.size(1)*npool.size(2)*npool.size(3))
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_col.Resize(Shape2(in.size(1) * ksize * ksize,$/;"	p	language:C++	file:	signature:(in.size(1) * ksize * ksize, nbatch * oheight * owidth)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_col.Resize(Shape2(in.size(1)*ksize*ksize, nbatch*oheight*owidth));$/;"	p	language:C++	file:	signature:(in.size(1)*ksize*ksize, nbatch*oheight*owidth)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_dst.Resize(Shape2(nchannel, nbatch * oheight * owidth));$/;"	p	language:C++	file:	signature:(nchannel, nbatch * oheight * owidth)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_dst.Resize(Shape2(nchannel, nbatch*oheight*owidth));$/;"	p	language:C++	file:	signature:(nchannel, nbatch*oheight*owidth)
Shape2	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  pred.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(num_hidden, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(num_in, num_hidden)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhidden.Resize(Shape2(batch_size, num_hidden));$/;"	p	language:C++	file:	signature:(batch_size, num_hidden)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    ninput.Resize(Shape2(batch_size, num_in));$/;"	p	language:C++	file:	signature:(batch_size, num_in)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  pred.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      pred.Resize(Shape2(step, num_out));$/;"	p	language:C++	file:	signature:(step, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wh2o.Resize(Shape2(num_hidden, num_out)); g_Wh2o.Resize(Wh2o.shape_);$/;"	p	language:C++	file:	signature:(num_hidden, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wi2h.Resize(Shape2(num_in, num_hidden));  g_Wi2h.Resize(Wi2h.shape_);$/;"	p	language:C++	file:	signature:(num_in, num_hidden)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhidden.Resize(Shape2(batch_size, num_hidden));$/;"	p	language:C++	file:	signature:(batch_size, num_hidden)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ninput.Resize(Shape2(batch_size, num_in));$/;"	p	language:C++	file:	signature:(batch_size, num_in)
Shape2	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nout.Resize(Shape2(batch_size, num_out));$/;"	p	language:C++	file:	signature:(batch_size, num_out)
Shape2	thirdparty/mshadow/guide/neuralnet/util.h	/^  xdata.Resize(Shape2(num_image, width * height));$/;"	p	language:C++	signature:(num_image, width * height)
Shape3	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<3> Shape3(index_t s0, index_t s1, index_t s2) {$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0, index_t s1, index_t s2)
Shape4	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<4> Shape4(index_t s0, index_t s1,$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0, index_t s1, index_t s2, index_t s3)
Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhidden.Resize(Shape4(batch_size, nchannel, (insize - ksize)\/kstride+1, (insize -ksize)\/kstride+1));$/;"	p	language:C++	file:	signature:(batch_size, nchannel, (insize - ksize)/kstride+1, (insize -ksize)/kstride+1)
Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    ninput.Resize(Shape4(batch_size, 1, insize, insize));$/;"	p	language:C++	file:	signature:(batch_size, 1, insize, insize)
Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npool.Resize(Shape4(batch_size, nchannel, (nhidden.size(2)+1-psize)\/psize, (nhidden.size(3)+1-psize)\/psize));$/;"	p	language:C++	file:	signature:(batch_size, nchannel, (nhidden.size(2)+1-psize)/psize, (nhidden.size(3)+1-psize)/psize)
Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<cpu, 4, real_t> xtest(Shape4(xtest_.size(0),  1, insize, insize));$/;"	p	language:C++	file:	signature:(xtest_.size(0), 1, insize, insize)
Shape4	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<cpu, 4, real_t> xtrain(Shape4(xtrain_.size(0), 1, insize, insize));$/;"	p	language:C++	file:	signature:(xtrain_.size(0), 1, insize, insize)
Shape::shape_	thirdparty/mshadow/guide/README.md	/^  index_t shape_[2];$/;"	m	language:C++	struct:Shape	file:	access:public
Shape::shape_	thirdparty/mshadow/guide/README.md	/^  index_t shape_[dimension];$/;"	m	language:C++	struct:Shape	file:	access:public
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, MakeTensorExp<T, SrcExp, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, Tensor<Device, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, TransposeExp<E, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, TypecastExp<DstDType, SrcDType, EType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
ShowSize	include/Pool.h	/^	void ShowSize(){fprintf(stderr, "Pool Size %lu k\\n", totalSize >> 10);}$/;"	f	language:C++	class:CPool	access:public	signature:()
ShutdownTensorEngine	include/mshadow/tensor.h	/^inline void ShutdownTensorEngine(void);$/;"	p	language:C++	namespace:mshadow	signature:(void)
ShutdownTensorEngine	include/mshadow/tensor_cpu-inl.h	/^inline void ShutdownTensorEngine<cpu>(void) {$/;"	f	language:C++	namespace:mshadow	signature:(void)
ShutdownTensorEngine	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  mshadow::ShutdownTensorEngine<xpu>();$/;"	p	language:C++	class:mshadow	file:	signature:()
ShutdownTensorEngine	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::ShutdownTensorEngine<xpu>();$/;"	p	language:C++	class:mshadow	signature:()
ShutdownTensorEngine	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::ShutdownTensorEngine<xpu>();$/;"	p	language:C++	class:mshadow	signature:()
Signal	include/mshadow-ps/thread.h	/^  inline void Signal(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
Size	include/Dict.h	/^	inline int Size(){$/;"	f	language:C++	class:Dict	access:public	signature:()
Size	include/mshadow/tensor.h	/^  MSHADOW_XINLINE size_t Size(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
Size	include/mshadow/tensor_blob.h	/^  inline size_t Size(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
Slice	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape<dimend - dimstart> Slice(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
Slice	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor<Device, 1, DType> Slice(index_t begin, index_t end) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t begin, index_t end) const
Slice	include/mshadow/tensor.h	/^  Slice(index_t begin, index_t end) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t begin, index_t end) const
Softmax	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void Softmax(Tensor<gpu, 2, DType> &dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(Tensor<gpu, 2, DType> &dst, const Tensor<gpu, 2, DType> &src)
Softmax	include/mshadow/tensor.h	/^inline void Softmax(Tensor<cpu, 2, DType> dst, const Tensor<cpu, 2, DType> &energy);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, 2, DType> dst, const Tensor<cpu, 2, DType> &energy)
Softmax	include/mshadow/tensor.h	/^inline void Softmax(Tensor<gpu, 2, DType> dst, const Tensor<gpu, 2, DType> &energy);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, 2, DType> dst, const Tensor<gpu, 2, DType> &energy)
Softmax	include/mshadow/tensor_cpu-inl.h	/^inline void Softmax(Tensor<cpu, 1, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, 1, DType> dst, const Tensor<cpu, 1, DType> &energy)
Softmax	include/mshadow/tensor_cpu-inl.h	/^inline void Softmax(Tensor<cpu, 2, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, 2, DType> dst, const Tensor<cpu, 2, DType> &energy)
Softmax	include/mshadow/tensor_gpu-inl.h	/^  cuda::Softmax(dst, src);$/;"	p	language:C++	class:mshadow::cuda	signature:(dst, src)
Softmax	include/mshadow/tensor_gpu-inl.h	/^inline void Softmax(Tensor<gpu, 2, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, 2, DType> dst, const Tensor<gpu, 2, DType>& src)
SoftmaxKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void SoftmaxKernel(DstPlan dst, SrcPlan src, index_t xmax) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, SrcPlan src, index_t xmax)
StackActions	depparser/DepAction.h	/^enum StackActions {$/;"	g	language:C++
Start	include/mshadow-ps/ps_local-inl.h	/^        thread_pull_handler[i].Start(PullLocalThread, p);$/;"	p	language:C++	signature:(PullLocalThread, p)
Start	include/mshadow-ps/ps_local-inl.h	/^        thread_push_handler[i].Start(PushLocalThread, p);$/;"	p	language:C++	signature:(PushLocalThread, p)
Start	include/mshadow-ps/ps_local-inl.h	/^      thread_pull_handler[0].Start(PullGlobalThread, this);$/;"	p	language:C++	signature:(PullGlobalThread, this)
Start	include/mshadow-ps/ps_local-inl.h	/^      thread_push_handler[0].Start(PushGlobalThread, this);$/;"	p	language:C++	signature:(PushGlobalThread, this)
Start	include/mshadow-ps/ps_rabit-inl.h	/^    thread_reduce_handler_.Start(ReduceGlobalThread, this);$/;"	p	language:C++	signature:(ReduceGlobalThread, this)
Start	include/mshadow-ps/thread.h	/^  inline void Start(unsigned int __stdcall entry(void*p), void *param) {$/;"	f	language:C++	class:mshadow::utils::Thread	access:public	signature:(unsigned int __stdcall entry(void*p), void *param)
State	depparser/State.h	/^	State() {$/;"	f	language:C++	class:State	access:public	signature:()
State	depparser/State.h	/^	State(const State &item) {$/;"	f	language:C++	class:State	access:public	signature:(const State &item)
State	depparser/State.h	/^class State {$/;"	c	language:C++
State::State	depparser/State.h	/^	State() {$/;"	f	language:C++	class:State	access:public	signature:()
State::State	depparser/State.h	/^	State(const State &item) {$/;"	f	language:C++	class:State	access:public	signature:(const State &item)
State::bGold	depparser/State.h	/^	bool bGold;$/;"	m	language:C++	class:State	access:public
State::beamIdx	depparser/State.h	/^	int beamIdx = 0;$/;"	m	language:C++	class:State	access:public
State::copy	depparser/State.h	/^	void copy(const State &item) {$/;"	f	language:C++	class:State	access:public	signature:(const State &item)
State::equal	depparser/State.h	/^	inline bool equal(const State &item) const {$/;"	f	language:C++	class:State	access:public	signature:(const State &item) const
State::higher	depparser/State.h	/^	inline bool higher(const State &item) const {$/;"	f	language:C++	class:State	access:public	signature:(const State &item) const
State::last_action	depparser/State.h	/^	int last_action;$/;"	m	language:C++	class:State	access:public
State::len_	depparser/State.h	/^	int len_;$/;"	m	language:C++	class:State	access:public
State::m_Stack	depparser/State.h	/^	std::vector<int> m_Stack;$/;"	m	language:C++	class:State	access:private
State::m_lDepTagL	depparser/State.h	/^	CSetOfTags<int> m_lDepTagL[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lDepTagR	depparser/State.h	/^	CSetOfTags<int> m_lDepTagR[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lDepsL	depparser/State.h	/^	int m_lDepsL[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lDepsL2	depparser/State.h	/^	int m_lDepsL2[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lDepsR	depparser/State.h	/^	int m_lDepsR[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lDepsR2	depparser/State.h	/^	int m_lDepsR2[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lHeads	depparser/State.h	/^	int m_lHeads[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_lLabels	depparser/State.h	/^	int m_lLabels[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
State::m_nNextWord	depparser/State.h	/^	int m_nNextWord;$/;"	m	language:C++	class:State	access:private
State::previous_	depparser/State.h	/^	const State * previous_;$/;"	m	language:C++	class:State	access:public
State::rootLabel	depparser/State.h	/^	static std::string rootLabel = "root";$/;"	m	language:C++	class:State	access:public
State::score	depparser/State.h	/^	double score;$/;"	m	language:C++	class:State	access:public
State::setBeamIdx	depparser/State.h	/^	inline void setBeamIdx(int idx){$/;"	f	language:C++	class:State	access:public	signature:(int idx)
State::stack2top	depparser/State.h	/^	inline int stack2top() const {$/;"	f	language:C++	class:State	access:public	signature:() const
State::stack3top	depparser/State.h	/^	inline int stack3top() const {$/;"	f	language:C++	class:State	access:public	signature:() const
State::stackbottom	depparser/State.h	/^	inline int stackbottom() const {$/;"	f	language:C++	class:State	access:public	signature:() const
State::stackempty	depparser/State.h	/^	inline bool stackempty() const {$/;"	f	language:C++	class:State	access:public	signature:() const
State::stackitem	depparser/State.h	/^	inline int stackitem(const int & id) const {$/;"	f	language:C++	class:State	access:public	signature:(const int & id) const
State::stacksize	depparser/State.h	/^	inline int stacksize() const {$/;"	f	language:C++	class:State	access:public	signature:() const
State::stacktop	depparser/State.h	/^	inline int stacktop() const {$/;"	f	language:C++	class:State	access:public	signature:() const
State::std::copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsL, m_nNextWord, m_lDepsL);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL, m_nNextWord, m_lDepsL)
State::std::copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsL2, m_nNextWord, m_lDepsL2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL2, m_nNextWord, m_lDepsL2)
State::std::copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsR, m_nNextWord, m_lDepsR);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR, m_nNextWord, m_lDepsR)
State::std::copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsR2, m_nNextWord, m_lDepsR2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR2, m_nNextWord, m_lDepsR2)
State::std::copy_n	depparser/State.h	/^				std::copy_n(item.m_lHeads, m_nNextWord, m_lHeads);$/;"	p	language:C++	class:State::std	signature:(item.m_lHeads, m_nNextWord, m_lHeads)
State::std::copy_n	depparser/State.h	/^				std::copy_n(item.m_lLabels, m_nNextWord, m_lLabels);$/;"	p	language:C++	class:State::std	signature:(item.m_lLabels, m_nNextWord, m_lLabels)
State::std::copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsL, m_nNextWord, m_lDepsL);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL, m_nNextWord, m_lDepsL)
State::std::copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsL2, m_nNextWord, m_lDepsL2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL2, m_nNextWord, m_lDepsL2)
State::std::copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsR, m_nNextWord, m_lDepsR);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR, m_nNextWord, m_lDepsR)
State::std::copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsR2, m_nNextWord, m_lDepsR2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR2, m_nNextWord, m_lDepsR2)
State::std::copy_n	depparser/State.h	/^			std::copy_n(item.m_lHeads, m_nNextWord, m_lHeads);$/;"	p	language:C++	class:State::std	signature:(item.m_lHeads, m_nNextWord, m_lHeads)
State::std::copy_n	depparser/State.h	/^			std::copy_n(item.m_lLabels, m_nNextWord, m_lLabels);$/;"	p	language:C++	class:State::std	signature:(item.m_lLabels, m_nNextWord, m_lLabels)
State::~State	depparser/State.h	/^	~State() {$/;"	f	language:C++	class:State	access:public	signature:()
Store	include/mshadow/sse-inl.h	/^    ans.Store(dst);$/;"	p	language:C++	signature:(dst)
Store	include/mshadow/sse-inl.h	/^    src.Store(dst);$/;"	p	language:C++	signature:(dst)
Store	include/mshadow/sse-inl.h	/^  inline void Store(double *dst) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(double *dst) const
Store	include/mshadow/sse-inl.h	/^  inline void Store(float *dst) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(float *dst) const
Stream	include/mshadow/stream_gpu-inl.h	/^  Stream(void) : stream_(0),$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
Stream	include/mshadow/stream_gpu-inl.h	/^struct Stream<gpu> {$/;"	s	language:C++	namespace:mshadow
Stream	include/mshadow/tensor.h	/^struct Stream {$/;"	s	language:C++	namespace:mshadow
StreamInfo	include/mshadow/expr_engine-inl.h	/^struct StreamInfo {$/;"	s	language:C++	namespace:mshadow::expr
StreamInfo	include/mshadow/expr_engine-inl.h	/^struct StreamInfo<Device, Tensor<Device, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
SubShape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape<kSubdim> SubShape(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
Sum	include/mshadow/sse-inl.h	/^  inline double Sum(void) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(void) const
Sum	include/mshadow/sse-inl.h	/^  inline float Sum(void) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(void) const
SwapAxisExp	include/mshadow/extension/swapaxis.h	/^  explicit SwapAxisExp(const SrcExp &src) : src_(src) {$/;"	f	language:C++	struct:mshadow::expr::SwapAxisExp	access:public	signature:(const SrcExp &src)
SwapAxisExp	include/mshadow/extension/swapaxis.h	/^struct SwapAxisExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
SyncProc	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  inline void SyncProc(mshadow::Tensor<xpu, dim> weight,$/;"	f	language:C++	class:NNet	access:public	signature:(mshadow::Tensor<xpu, dim> weight, mshadow::Tensor<xpu, dim> grad, int data_key)
T	include/mshadow/expression.h	/^  inline const EType &T(void) const {$/;"	f	language:C++	struct:mshadow::expr::TransposeExp	access:public	signature:(void) const
T	include/mshadow/expression.h	/^  inline const TransposeExp<Container, DType> T(void) const {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(void) const
TBlob	include/mshadow/tensor_blob.h	/^  TBlob(DType *dptr,$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(DType *dptr, const TShape &shape, int dev_mask)
TBlob	include/mshadow/tensor_blob.h	/^  TBlob(const Tensor<Device, dim, DType> &src) {  \/\/ NOLINT(*)$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(const Tensor<Device, dim, DType> &src)
TBlob	include/mshadow/tensor_blob.h	/^  TBlob(void)$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(void)
TBlob	include/mshadow/tensor_blob.h	/^class TBlob {$/;"	c	language:C++	namespace:mshadow
TRValue	include/mshadow/tensor.h	/^struct TRValue: public expr::RValueExp<Container, DType> {$/;"	s	language:C++	namespace:mshadow	inherits:expr::RValueExp
TShape	include/mshadow/tensor_blob.h	/^  TShape()$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:()
TShape	include/mshadow/tensor_blob.h	/^  TShape(RandomAccessIterator begin,$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(RandomAccessIterator begin, RandomAccessIterator end)
TShape	include/mshadow/tensor_blob.h	/^  TShape(TShape &&s)$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(TShape &&s)
TShape	include/mshadow/tensor_blob.h	/^  TShape(const TShape &s)$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &s)
TShape	include/mshadow/tensor_blob.h	/^struct TShape {$/;"	s	language:C++	namespace:mshadow
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr, Shape<1> shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, Shape<1> shape)
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr, Shape<1> shape,$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, Shape<1> shape, index_t stride, Stream<Device> *stream)
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr, const Shape<dimension> &shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, const Shape<dimension> &shape)
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr,$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, const Shape<dimension> &shape, index_t stride, Stream<Device> *stream)
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(const Shape<1> &shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Shape<1> &shape)
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(const Shape<dimension> &shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Shape<dimension> &shape)
Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(void) : stream_(NULL) {}$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void)
Tensor	include/mshadow/tensor.h	/^struct Tensor: public TRValue<Tensor<Device, dimension, DType>,$/;"	s	language:C++	namespace:mshadow	inherits:TRValue
Tensor	include/mshadow/tensor.h	/^struct Tensor<Device, 1, DType>:$/;"	s	language:C++	namespace:mshadow	inherits:TRValue
Tensor	thirdparty/mshadow/guide/README.md	/^* For ```Tensor<cpu, k>```, the space can be created by ```new float[]```, or pointer to some existing space such as float array in last example.$/;"	v	language:C++
Tensor	thirdparty/mshadow/guide/README.md	/^struct Tensor {$/;"	s	language:C++	file:
Tensor	thirdparty/mshadow/guide/README.md	/^struct Tensor<cpu, 2, float> {$/;"	s	language:C++	file:
Tensor::dptr_	thirdparty/mshadow/guide/README.md	/^  DType *dptr_;$/;"	m	language:C++	struct:Tensor	file:	access:public
Tensor::dptr_	thirdparty/mshadow/guide/README.md	/^  float *dptr_;$/;"	m	language:C++	struct:Tensor	file:	access:public
Tensor::shape_	thirdparty/mshadow/guide/README.md	/^  Shape<2> shape_;$/;"	m	language:C++	struct:Tensor	file:	access:public
Tensor::shape_	thirdparty/mshadow/guide/README.md	/^  Shape<dimension> shape_;$/;"	m	language:C++	struct:Tensor	file:	access:public
Tensor::stream_	thirdparty/mshadow/guide/README.md	/^  Stream<Device> stream_;$/;"	m	language:C++	struct:Tensor	file:	access:public
Tensor::stride_	thirdparty/mshadow/guide/README.md	/^  index_t stride_;$/;"	m	language:C++	struct:Tensor	file:	access:public
TensorContainer	include/mshadow/tensor_container.h	/^  TensorContainer$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const TensorContainer<Device, dimension, DType> &src)
TensorContainer	include/mshadow/tensor_container.h	/^  explicit TensorContainer(bool pad = MSHADOW_ALLOC_PAD) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(bool pad = MSHADOW_ALLOC_PAD)
TensorContainer	include/mshadow/tensor_container.h	/^  explicit TensorContainer(const Shape<dimension> &shape) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape)
TensorContainer	include/mshadow/tensor_container.h	/^  explicit TensorContainer(const Shape<dimension> &shape, DType initv) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape, DType initv)
TensorContainer	include/mshadow/tensor_container.h	/^class TensorContainer: public Tensor<Device, dimension, DType> {$/;"	c	language:C++	namespace:mshadow	inherits:Tensor
TensorContainer	thirdparty/mshadow/guide/README.md	/^We also have STL style container object called ```TensorContainer```, they behave exactly the same as Tensors, but the memory will be automatically freed during destruction.$/;"	v	language:C++
Tensors	thirdparty/mshadow/guide/README.md	/^We also have STL style container object called ```TensorContainer```, they behave exactly the same as Tensors, but the memory will be automatically freed during destruction.$/;"	v	language:C++
Test	include/Pool.h	/^	void Test();$/;"	p	language:C++	class:CPool	access:public	signature:()
Thread	include/mshadow-ps/thread.h	/^class Thread {$/;"	c	language:C++	namespace:mshadow::utils
ThreadExit	include/mshadow-ps/ps_local-inl.h	/^    utils::ThreadExit(NULL);$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(NULL)
ThreadExit	include/mshadow-ps/thread.h	/^inline void ThreadExit(void *status) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(void *status)
ThreadPQueue	include/mshadow-ps/thread_util.h	/^  ThreadPQueue() : use_fifo_(false) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:()
ThreadPQueue	include/mshadow-ps/thread_util.h	/^class ThreadPQueue {$/;"	c	language:C++	namespace:mshadow::utils
ThreadSafeMap	include/mshadow-ps/thread_util.h	/^class ThreadSafeMap {$/;"	c	language:C++	namespace:mshadow::utils
TransposeExp	include/mshadow/expression.h	/^  explicit TransposeExp(const EType &e) : exp(e) {}$/;"	f	language:C++	struct:mshadow::expr::TransposeExp	access:public	signature:(const EType &e)
TransposeExp	include/mshadow/expression.h	/^struct TransposeExp: public Exp<TransposeExp<EType, DType>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
TypeCheck	include/mshadow/expr_engine-inl.h	/^struct TypeCheck {$/;"	s	language:C++	namespace:mshadow::expr
TypeCheckPass	include/mshadow/expr_engine-inl.h	/^struct TypeCheckPass;$/;"	x	language:C++
TypeCheckPass	include/mshadow/expr_engine-inl.h	/^struct TypeCheckPass<false> {};$/;"	s	language:C++	namespace:mshadow::expr
TypeCheckPass	include/mshadow/expr_engine-inl.h	/^struct TypeCheckPass<true> {$/;"	s	language:C++	namespace:mshadow::expr
TypecastExp	include/mshadow/expression.h	/^  explicit TypecastExp(const EType &e) : exp(e) {}$/;"	f	language:C++	struct:mshadow::expr::TypecastExp	access:public	signature:(const EType &e)
TypecastExp	include/mshadow/expression.h	/^struct TypecastExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
UnPoolingExp	include/mshadow/extension/spatial_unpool.h	/^  UnPoolingExp(const SrcExp &data_src,$/;"	f	language:C++	struct:mshadow::expr::UnPoolingExp	access:public	signature:(const SrcExp &data_src, const SrcExp &data_pooled, const SrcExp &grad_pooled, index_t ksize_y, index_t ksize_x, index_t kstride)
UnPoolingExp	include/mshadow/extension/spatial_unpool.h	/^struct UnPoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
UnaryMapExp	include/mshadow/expression.h	/^  explicit UnaryMapExp(const TA &src) : src_(src) {}$/;"	f	language:C++	struct:mshadow::expr::UnaryMapExp	access:public	signature:(const TA &src)
UnaryMapExp	include/mshadow/expression.h	/^struct UnaryMapExp: public Exp<UnaryMapExp<OP, TA, DType, etype>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
Unlock	include/mshadow-ps/ps_local-inl.h	/^          wait_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/ps_local-inl.h	/^        push_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/ps_local-inl.h	/^        request_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/ps_local-inl.h	/^      wait_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/ps_local-inl.h	/^    push_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/ps_local-inl.h	/^    request_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/ps_local-inl.h	/^    wait_lock.Unlock();$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/thread.h	/^  inline void Unlock(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
Unlock	include/mshadow-ps/thread_util.h	/^        lock_.Unlock(); return false;$/;"	p	language:C++	signature:()
Unlock	include/mshadow-ps/thread_util.h	/^    lock_.Unlock();$/;"	p	language:C++	signature:()
UnpackPatchToColXExp	include/mshadow/extension/unpack_patch2col.h	/^  UnpackPatchToColXExp(const SrcExp &img,$/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)
UnpackPatchToColXExp	include/mshadow/extension/unpack_patch2col.h	/^struct UnpackPatchToColXExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
Update	depparser/Depparser.cpp	/^						nets[round - 1]->Update();$/;"	p	language:C++	file:	signature:()
Update	include/NNet.h	/^  virtual void Update(void) {$/;"	f	language:C++	class:NNet	access:public	signature:(void)
Update	include/mshadow-ps/mshadow_ps.h	/^  virtual void Update(int key, DType *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(int key, DType *dptr, size_t size)
Update	include/mshadow-ps/ps_dist-inl.h	/^    updater_->Update(id, (DType*)recv_data, size);  \/\/ NOLINT(*)$/;"	p	language:C++	signature:(id, (DType*)recv_data, size)
Update	include/mshadow-ps/ps_dist-inl.h	/^  void Update(int id, size_t size, const DType* recv_data, DType* data) {$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:(int id, size_t size, const DType* recv_data, DType* data)
Update	include/mshadow-ps/ps_local-inl.h	/^      custom_server->Update(key, data.dptr_, data.MSize());$/;"	p	language:C++	signature:(key, data.dptr_, data.MSize())
Update	include/mshadow-ps/ps_local-inl.h	/^      custom_server->Update(key, data[0].dptr_, data[0].MSize());$/;"	p	language:C++	signature:(key, data[0].dptr_, data[0].MSize())
Update	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^      net->Update();$/;"	p	language:C++	file:	signature:()
Update	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Update(void) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(void)
Update	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual void Update(void) {$/;"	f	language:C++	class:ConvNet	access:public	signature:(void)
Update	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^      net->Update();$/;"	p	language:C++	file:	signature:()
Update	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Update(void) = 0;$/;"	p	language:C++	class:INNet	file:	access:public	signature:(void)
Update	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual void Update(void) {$/;"	f	language:C++	class:NNet	access:public	signature:(void)
Update	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      e->Update(stream);$/;"	p	language:C++	file:	signature:(stream)
Update	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    inline void Update(mshadow::Stream<xpu> *stream) {$/;"	f	language:C++	struct:NNet::UpdateEntry	access:public	signature:(mshadow::Stream<xpu> *stream)
UpdateEntry	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    UpdateEntry(mshadow::Tensor<xpu, 2> weight,$/;"	f	language:C++	struct:NNet::UpdateEntry	access:public	signature:(mshadow::Tensor<xpu, 2> weight, mshadow::Tensor<xpu, 2> grad, bool is_bias)
UpdateEntry	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  struct UpdateEntry {$/;"	s	language:C++	class:NNet	file:	access:public
UpdateSGD	thirdparty/mshadow/guide/README.md	/^void UpdateSGD(Tensor<cpu, 2> weight, Tensor<cpu, 2> grad, float eta, float lambda) {$/;"	f	language:C++	signature:(Tensor<cpu, 2> weight, Tensor<cpu, 2> grad, float eta, float lambda)
UpdateSGD	thirdparty/mshadow/guide/README.md	/^void UpdateSGD(Tensor<cpu,2> weight, Tensor<cpu,2> grad, float eta, float lambda) {$/;"	f	language:C++	signature:(Tensor<cpu,2> weight, Tensor<cpu,2> grad, float eta, float lambda)
UpdateSGD	thirdparty/mshadow/guide/README.md	/^void UpdateSGD(Tensor<xpu, 2> weight, const Tensor<xpu, 2> &grad,$/;"	f	language:C++	signature:(Tensor<xpu, 2> weight, const Tensor<xpu, 2> &grad, float eta, float lambda)
Update_	include/mshadow-ps/mshadow_ps.h	/^  virtual void Update_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
Update_	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  void Update_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::Updater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
Updater	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^class Updater : public IModelUpdater<DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:IModelUpdater
UpdaterWrapper	include/mshadow-ps/ps_dist-inl.h	/^  explicit UpdaterWrapper(IModelUpdater<DType> * updater)$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:(IModelUpdater<DType> * updater)
UpdaterWrapper	include/mshadow-ps/ps_dist-inl.h	/^class UpdaterWrapper {$/;"	c	language:C++	namespace:mshadow::ps
UpperAlign	include/mshadow/sse-inl.h	/^inline index_t UpperAlign(index_t size, size_t fsize) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(index_t size, size_t fsize)
VDot	include/mshadow/tensor_cpu-inl.h	/^inline DType VDot(const Tensor<cpu, 1, DType> &lhs,$/;"	f	language:C++	namespace:mshadow	signature:(const Tensor<cpu, 1, DType> &lhs, const Tensor<cpu, 1, DType> &rhs)
Wait	include/mshadow-ps/ps_local-inl.h	/^          pull_stream[wid]->Wait();$/;"	p	language:C++	signature:()
Wait	include/mshadow-ps/ps_local-inl.h	/^        push_stream[wid]->Wait();$/;"	p	language:C++	signature:()
Wait	include/mshadow-ps/thread.h	/^  inline void Wait(Mutex *mutex) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(Mutex *mutex)
Wait	include/mshadow-ps/thread.h	/^  inline void Wait(void) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(void)
Wait	include/mshadow-ps/thread_util.h	/^    counter_.Wait();$/;"	p	language:C++	signature:()
Wait	include/mshadow/stream_gpu-inl.h	/^  inline void Wait(void) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
Wait	include/mshadow/tensor.h	/^  inline void Wait(void) {}$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
Wait	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    stream->Wait();$/;"	p	language:C++	file:	signature:()
Wh2o	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
Wh2o	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
Wh2o	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
Wh2o	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
Wi2h	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
Wi2h	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
Wi2h	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
WorkerNodeMain	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum.cpp	/^int WorkerNodeMain(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
Write	include/mshadow/io.h	/^    fo.Write(src[i].dptr_, sizeof(DType) * src.size(1));$/;"	p	language:C++	signature:(src[i].dptr_, sizeof(DType) * src.size(1))
Write	include/mshadow/io.h	/^  virtual void Write(const void *ptr, size_t size) = 0;$/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)
Write	tags	/^mshadow::utils::IStream::Write	include\/mshadow\/io.h	\/^  virtual void Write(const void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(const void *ptr, size_t size)
_CRT_SECURE_NO_DEPRECATE	include/mshadow/base.h	12;"	d	language:C++
_CRT_SECURE_NO_WARNINGS	include/mshadow/base.h	11;"	d	language:C++
_CRT_SECURE_NO_WARNINGS	include/mshadow/utils.h	9;"	d	language:C++
__CONFIG_H__	depparser/Config.h	2;"	d	language:C++
__MSHADOW_EMUSYNC__	include/mshadow/cuda/reduce.cuh	35;"	d	language:C++	file:
__MSHADOW_EMUSYNC__	include/mshadow/cuda/reduce.cuh	37;"	d	language:C++	file:
__RD_NON_ALIGN	include/mshadow/cuda/reduce.cuh	93;"	d	language:C++	file:
__anon1::$	tags	/^Classifier::Classifier	depparser\/Classifier.cpp	\/^Classifier::Classifier() {$\/;"	f	language:C++	class:Classifier	signature:()$/;"	m	language:C++	class:__anon1	file:	access:private
__anon1::__anon2::$	tags	/^Classifier::~Classifier	depparser\/Classifier.cpp	\/^Classifier::~Classifier() {$\/;"	f	language:C++	class:Classifier	signature:()$/;"	m	language:C++	class:__anon1::__anon2	file:	access:private
__anon1::__anon2::Classifier	tags	/^Classifier	depparser\/Classifier.h	\/^class Classifier {$\/;"	c	language:C++$/;"	c	language:C++	class:__anon1::__anon2	file:	access:private
__anon1::__anon2::Classifier::$	tags	/^Classifier	depparser\/Classifier.h	\/^class Classifier {$\/;"	c	language:C++$/;"	m	language:C++	class:__anon1::__anon2::Classifier	file:	access:private
__anon1::__anon2::Classifier::__anon3::$	tags	/^Depparser	depparser\/Depparser.cpp	\/^Depparser::Depparser(bool bTrain) {$\/;"	f	language:C++	class:Depparser	signature:(bool bTrain)$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3	file:	access:private
__anon1::__anon2::Classifier::__anon3::__anon4::$	tags	/^~Depparser	depparser\/Depparser.cpp	\/^Depparser::~Depparser() {$\/;"	f	language:C++	class:Depparser	signature:()$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4	file:	access:private
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::$	tags	/^Info	include\/mshadow\/extension\/swapaxis.h	\/^  typedef ExpInfo<SrcExp> Info;$\/;"	t	language:C++$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::$	tags	/^swapaxis	include\/mshadow\/extension\/swapaxis.h	\/^swapaxis(const Exp<SrcExp, DType, etype> &src) {$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src)$/;"	m	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Info	tags	/^Info	include\/mshadow\/extension\/swapaxis.h	\/^  typedef ExpInfo<SrcExp> Info;$\/;"	t	language:C++$/;"	t	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	s	language:C++	class:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5	file:	access:private
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::$	tags	/^a1	include\/mshadow\/extension\/swapaxis.h	\/^  static const int a1 = dimsrc - m_a1;$\/;"	m	language:C++	struct:mshadow::expr::Plan	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::DType	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::DType	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::Eval	tags	/^Eval	include\/mshadow\/extension\/swapaxis.h	\/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const$/;"	f	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	access:public	signature:(index_t i, index_t j) const
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::$	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, 1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::DType	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::DType	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::Eval	tags	/^Eval	include\/mshadow\/extension\/swapaxis.h	\/^  MSHADOW_XINLINE DType Eval(index_t i, index_t x) const {$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t x) const$/;"	f	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	access:public	signature:(index_t i, index_t x) const
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^expr	include\/mshadow\/extension\/unpack_patch2col.h	\/^namespace expr {$\/;"	n	language:C++	namespace:mshadow$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^i_channel_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_channel_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^i_height_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_height_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^i_width_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_width_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^img_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  const SrcExp &img_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^imshape	include\/mshadow\/extension\/unpack_patch2col.h	\/^    Shape<srcdim> imshape = ShapeCheck<srcdim, SrcExp>::Check(img_);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^num	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t num = imshape.ProdShape(0, srcdim - 3);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^o_height	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_height = (i_height_ - psize_y) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^o_width	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_width  = (i_width_  - psize_x) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^psize_x_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_x_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^psize_y_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_y_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^pstride_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t pstride_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::$	tags	/^unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::DType	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::DType	tags	/^unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	s	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::$	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::$	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::DType	tags	/^Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::DType	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::Eval	tags	/^Eval	include\/mshadow\/extension\/unpack_patch2col.h	\/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const$/;"	f	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	access:public	signature:(index_t i, index_t j) const
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::$	tags	/^mshadow	include\/mshadow\/io.h	\/^namespace mshadow {$\/;"	n	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::$	tags	/^mshadow::utils::IStream::Read	include\/mshadow\/io.h	\/^  virtual size_t Read(void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::$	tags	/^mshadow::utils::IStream::Write	include\/mshadow\/io.h	\/^  virtual void Write(const void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::Read	tags	/^mshadow::utils::IStream::Read	include\/mshadow\/io.h	\/^  virtual size_t Read(void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(void *ptr, size_t size)
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::SaveBinary	tags	/^mshadow::SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src);  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::SaveBinary	tags	/^mshadow::SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src); \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::Write	tags	/^mshadow::utils::IStream::Write	include\/mshadow\/io.h	\/^  virtual void Write(const void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)$/;"	p	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public	signature:(const void *ptr, size_t size)
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::dst	tags	/^LoadBinary	include\/mshadow\/io.h	\/^inline void LoadBinary(TStream &fi,  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst, bool pre_alloc)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^IStream	include\/mshadow\/io.h	\/^class IStream {$\/;"	c	language:C++	namespace:mshadow::utils$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^LoadBinary	include\/mshadow\/io.h	\/^inline void LoadBinary(TStream &fi,  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst, bool pre_alloc)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^Read	include\/mshadow\/io.h	\/^  virtual size_t Read(void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src);  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src); \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^Write	include\/mshadow\/io.h	\/^  virtual void Write(const void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^utils	include\/mshadow\/io.h	\/^namespace utils {$\/;"	n	language:C++	namespace:mshadow$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8::language	tags	/^~IStream	include\/mshadow\/io.h	\/^  virtual ~IStream(void) {}$\/;"	f	language:C++	class:mshadow::utils::IStream	access:public	signature:(void)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::language	tags	/^mshadow::expr::Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::language	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::img	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::img	tags	/^unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr	include\/mshadow\/extension\/unpack_patch2col.h	\/^namespace expr {$\/;"	n	language:C++	namespace:mshadow$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct UnpackPatchToColXExp:$\/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::i_channel_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_channel_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::i_height_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_height_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::i_width_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_width_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::img_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  const SrcExp &img_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::imshape	include\/mshadow\/extension\/unpack_patch2col.h	\/^    Shape<srcdim> imshape = ShapeCheck<srcdim, SrcExp>::Check(img_);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::num	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t num = imshape.ProdShape(0, srcdim - 3);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::o_height	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_height = (i_height_ - psize_y) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::o_width	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_width  = (i_width_  - psize_x) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::psize_x_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_x_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::psize_y_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_y_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::UnpackPatchToColXExp::pstride_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t pstride_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::language	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::psize_x	tags	/^mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::psize_x	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::psize_y	tags	/^mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::psize_y	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::dimsrc	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::dimsrc	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::language	tags	/^mshadow::expr::Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, 1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::language	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::dimsrc	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::dimsrc	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::language	tags	/^mshadow::expr::Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::language	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::language	tags	/^mshadow::expr::Plan::a1	include\/mshadow\/extension\/swapaxis.h	\/^  static const int a1 = dimsrc - m_a1;$\/;"	m	language:C++	struct:mshadow::expr::Plan	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::m_a1	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::m_a1	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
__assign	include/mshadow/expression.h	/^  inline Container &__assign(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
__assign	include/mshadow/expression.h	/^  inline Container &__assign(const Exp<Container, DType, type::kRValue> &exp);$/;"	p	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<Container, DType, type::kRValue> &exp)
__assign	include/mshadow/expression.h	/^  inline Container &__assign(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
a	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      DType a = src.Eval(y, x + threadIdx.x);$/;"	l	language:C++
a1	include/mshadow/extension/swapaxis.h	/^  static const int a1 = dimsrc - m_a1;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:public
a1	include/mshadow/extension/swapaxis.h	/^  static const int a1 = dimsrc - m_a1;$/;"	m	language:C++	struct:mshadow::expr::SwapAxisExp	access:public
actNum	depparser/Depparser.cpp	/^		int actNum = input.size() * 2; \/\/ n shift and n reduce$/;"	l	language:C++
acts	depparser/Depparser.cpp	/^		std::vector<int> acts(actNum); \/\/gold acts$/;"	p	language:C++	file:	signature:(actNum)
addone	thirdparty/mshadow/guide/defop.cpp	/^struct addone {$/;"	s	language:C++	file:
addone::Map	thirdparty/mshadow/guide/defop.cpp	/^  MSHADOW_XINLINE static DType Map(DType a) {$/;"	f	language:C++	struct:addone	access:public	signature:(DType a)
again	thirdparty/mshadow/guide/exp-template/README.md	/^    - Besides element-wise expressions, we also want to support sugars such as ```A = dot(B.T(), C)```,  again, lazy evaluation is used and no extra memory is allocated.$/;"	v	language:C++
aligned_sz	include/mshadow/random.h	/^    size_t aligned_sz = ((shape.Size() + 1UL) >> 1) << 1;$/;"	l	language:C++
allocSize	include/Pool.h	/^		size_t allocSize = size > BLOCK_SIZE ? size : BLOCK_SIZE;$/;"	l	language:C++
allocateBlock	include/Pool.h	/^	SBlock * allocateBlock( size_t size )$/;"	f	language:C++	class:CPool	access:private	signature:( size_t size )
allocation	thirdparty/mshadow/guide/exp-template/README.md	/^   - If we want to keep the syntax that everything is pre-allocated, and expression executes without memory allocation (which is what we did in mshadow), we still need expression template.$/;"	p	language:C++	file:	signature:(which is what we did in mshadow)
ans	include/mshadow/sse-inl.h	/^    DType ans  = _mm_add_ps(data_, _mm_movehl_ps(data_, data_));$/;"	l	language:C++
ans	include/mshadow/sse-inl.h	/^    FVec<TFloat> ans = SSEOp<typename SV::OPType>::Map(lhs, src);$/;"	l	language:C++
argc	include/mshadow-ps/ps_dist-inl.h	/^    updater->InitUpdater(::ps::MyRank(), argc, argv);$/;"	l	language:C++
args	include/mshadow/utils.h	/^    va_list args;$/;"	l	language:C++
argv	include/mshadow-ps/ps_dist-inl.h	/^    updater->InitUpdater(::ps::MyRank(), argc, argv);$/;"	l	language:C++
atoi	depparser/Config.cpp	/^				vHiddenSize.push_back(atoi(pSizes));$/;"	p	language:C++	file:	signature:(pSizes)
atoi	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^    devs.push_back(atoi(argv[i]));$/;"	p	language:C++	signature:(argv[i])
atoi	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^    devs.push_back(atoi(argv[i]));$/;"	p	language:C++	signature:(argv[i])
atoi	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    devs.push_back(atoi(argv[i]));$/;"	p	language:C++	file:	signature:(argv[i])
b	include/mshadow/extension/concat.h	/^    const index_t b = i \/ ch_;$/;"	l	language:C++
bBPRateLinearDecay	depparser/Config.cpp	/^			CConfig::bBPRateLinearDecay = string(pVal) == string("true");$/;"	m	language:C++	class:CConfig	file:
bBPRateLinearDecay	depparser/Config.cpp	/^bool  CConfig::bBPRateLinearDecay = false;$/;"	m	language:C++	class:CConfig	file:
bBeamContainGold	depparser/Depparser.cpp	/^				bool bBeamContainGold = true;$/;"	l	language:C++
bConvert	depparser/Config.cpp	/^bool	CConfig::bConvert = false;$/;"	m	language:C++	class:CConfig	file:
bDropOut	depparser/Config.cpp	/^			CConfig::bDropOut = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
bDropOut	depparser/Config.cpp	/^bool	CConfig::bDropOut = false;$/;"	m	language:C++	class:CConfig	file:
bDropOut	depparser/Config.h	/^	static bool	 bDropOut;$/;"	m	language:C++	class:CConfig	access:public
bEarlyUpdate	depparser/Depparser.h	/^	bool bEarlyUpdate = true;$/;"	m	language:C++	class:Depparser	access:private
bGold	depparser/State.h	/^	bool bGold;$/;"	m	language:C++	class:State	access:public
bHiddenOnly	depparser/Config.cpp	/^			CConfig::bHiddenOnly = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
bHiddenOnly	depparser/Config.cpp	/^bool	CConfig::bHiddenOnly = false;$/;"	m	language:C++	class:CConfig	file:
bLoadDBN	depparser/Config.cpp	/^			CConfig::bLoadDBN = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
bLoadDBN	depparser/Config.cpp	/^bool	CConfig::bLoadDBN = false;$/;"	m	language:C++	class:CConfig	file:
bNormalizeEmbedding	depparser/Config.cpp	/^bool  CConfig::bNormalizeEmbedding = false;$/;"	m	language:C++	class:CConfig	file:
bSmall	depparser/Config.cpp	/^			CConfig::bSmall = string(pVal) == string("true");$/;"	m	language:C++	class:CConfig	file:
bSmall	depparser/Config.cpp	/^bool  CConfig::bSmall    = false;$/;"	m	language:C++	class:CConfig	file:
bWithHidden	depparser/Config.cpp	/^			CConfig::bWithHidden = string(pVal) == "true";$/;"	m	language:C++	class:CConfig	file:
bWithHidden	depparser/Config.cpp	/^bool	CConfig::bWithHidden = false;$/;"	m	language:C++	class:CConfig	file:
batch_size	include/NNet.h	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
batch_size	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
batch_size	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int batch_size = 100;$/;"	l	language:C++
batch_size	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
batch_size	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  int batch_size = 100;$/;"	l	language:C++
batch_size	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    index_t batch_size = inbatch.size(0);$/;"	l	language:C++
batch_size	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int batch_size = 100;$/;"	l	language:C++
beamIdx	depparser/Depparser.cpp	/^				int beamIdx = 0;$/;"	l	language:C++
beamIdx	depparser/State.h	/^	int beamIdx = 0;$/;"	m	language:C++	class:State	access:public
beamSize	depparser/Depparser.cpp	/^	const int beamSize = CConfig::nBeamSize;$/;"	l	language:C++
beamSize	depparser/Depparser.h	/^	int beamSize;$/;"	m	language:C++	class:Depparser	access:private
beamSize	include/FeatureEmbedding.h	/^	int beamSize;$/;"	m	language:C++	class:FeatureEmbedding	access:public
beamTransits	depparser/Depparser.cpp	/^				CScoredTransition* beamTransits = new CScoredTransition[beamSize];$/;"	l	language:C++
bestState	depparser/Depparser.cpp	/^					State * bestState = lattice_index[round];$/;"	l	language:C++
bigarray_bound	include/mshadow-ps/ps_local-inl.h	/^  size_t bigarray_bound;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
blas_handle_	include/mshadow/stream_gpu-inl.h	/^  cublasHandle_t blas_handle_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
blas_handle_ownership_	include/mshadow/stream_gpu-inl.h	/^  HandleState blas_handle_ownership_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
block_size	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int block_size = 1 << block_dim_bits;$/;"	l	language:C++
broadcast	include/mshadow/extension/broadcast.h	/^broadcast(const expr::Exp<SrcExp, DType, etype> &src, Shape<dimdst> shape) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const expr::Exp<SrcExp, DType, etype> &src, Shape<dimdst> shape)
buf	depparser/Config.cpp	/^	char buf[65536];$/;"	l	language:C++
buf	depparser/Config.cpp	/^	char buf[BUF_LEN];$/;"	l	language:C++
buffer_	include/mshadow/random.h	/^  TensorContainer<cpu, 1, DType> buffer_;$/;"	m	language:C++	class:mshadow::Random	access:private
buffer_	include/mshadow/random.h	/^  TensorContainer<gpu, 1, DType> buffer_;$/;"	m	language:C++	class:mshadow::Random	access:private
c	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int c = blockIdx.x;  $/;"	l	language:C++
c	include/mshadow/extension/channel_pool.h	/^    const index_t c = i % channel_;$/;"	l	language:C++
c	include/mshadow/extension/channel_unpool.h	/^    const index_t c = i % channel_;$/;"	l	language:C++
c	include/mshadow/extension/concat.h	/^    const index_t c = i % ch_;$/;"	l	language:C++
c	include/mshadow/extension/crop.h	/^    const index_t c = i \/ new_height_;$/;"	l	language:C++
c	include/mshadow/extension/pack_col2patch.h	/^    const index_t c = idivh % i_channel_;$/;"	l	language:C++
c	include/mshadow/extension/pad.h	/^    const index_t c = i \/ new_height_;$/;"	l	language:C++
c	include/mshadow/extension/spatial_pool.h	/^    const index_t c = i \/ new_height_;$/;"	l	language:C++
c	include/mshadow/extension/spatial_unpool.h	/^    const index_t c = i \/ sshape_y_;$/;"	l	language:C++
c	include/mshadow/extension/swapaxis.h	/^    const index_t c = i % shapec_;$/;"	l	language:C++
c	include/mshadow/extension/unpack_patch2col.h	/^    const index_t c = idivp \/ psize_y_;$/;"	l	language:C++
calbk	include/mshadow-ps/mshadow_ps.h	/^    auto calbk = new std::function<void(Stream<xpu> *stream)>();$/;"	l	language:C++
callback	include/mshadow-ps/ps_local-inl.h	/^            (*r.callback)(pull_stream[wid], r.callback_arg);$/;"	p	language:C++	signature:(pull_stream[wid], r.callback_arg)
callback	include/mshadow-ps/ps_local-inl.h	/^    CallbackFunction *callback;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
callback_arg	include/mshadow-ps/ps_local-inl.h	/^    void *callback_arg;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
cfgvec	include/mshadow-ps/ps_local-inl.h	/^  std::vector< std::pair<std::string, std::string> > cfgvec;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
ch_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
ch_src1_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
ch_src2_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
ch_unpool	include/mshadow/extension/channel_unpool.h	/^ch_unpool(const Exp<SrcExp, DType, etype> &data_src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &data_src, const Exp<SrcExp, DType, etype> &data_pooled, const Exp<SrcExp, DType, etype> &grad_pooled, index_t nsize)
ch_unpool	include/mshadow/extension/channel_unpool.h	/^ch_unpool(const Exp<SrcExp, DType, etype> &data_src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &data_src, const Exp<SrcExp, DType, etype> &data_pooled, const Exp<SrcExp, DType, etype> &grad_pooled, index_t nsize, index_t stride, index_t pad)
chpool	include/mshadow/extension/channel_pool.h	/^chpool(const Exp<SrcExp, DType, etype> &src, index_t nsize) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t nsize)
chpool	include/mshadow/extension/channel_pool.h	/^chpool(const Exp<SrcExp, DType, etype> &src, index_t nsize, index_t stride, index_t pad) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t nsize, index_t stride, index_t pad)
clear	depparser/Config.cpp	/^			vHiddenSize.clear();$/;"	p	language:C++	file:	signature:()
clear	depparser/Config.cpp	/^			vHiddenType.clear();$/;"	p	language:C++	file:	signature:()
clear	depparser/Depparser.cpp	/^				lattice[0].clear();$/;"	p	language:C++	file:	signature:()
clear	include/Dict.h	/^		map.clear();$/;"	p	language:C++	signature:()
clear	include/mshadow-ps/ps_local-inl.h	/^    dev2index.clear();$/;"	p	language:C++	signature:()
code	thirdparty/mshadow/guide/neuralnet/README.md	/^To compile the code, modify ```config.mk``` to the setting you like and type make$/;"	v	language:C++
codes	thirdparty/mshadow/guide/exp-template/README.md	/^So write expressions when you write machine learning codes, and focus your energy on the algorithm part that matters.$/;"	v	language:C++
compilation	thirdparty/mshadow/guide/README.md	/^During compilation, this code will be translated to the following form:$/;"	v	language:C++
concat	include/mshadow/extension/concat.h	/^concat(const TRValue<LhsExp, Device, srcdim, DType> &src1,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TRValue<LhsExp, Device, srcdim, DType> &src1, const TRValue<RhsExp, Device, srcdim, DType> &src2)
cond	include/mshadow-ps/thread.h	/^  CONDITION_VARIABLE cond;$/;"	m	language:C++	class:mshadow::utils::ConditionVariable	access:private
copied	include/mshadow-ps/ps_local-inl.h	/^    std::vector<bool> copied;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
copy	depparser/State.h	/^	void copy(const State &item) {$/;"	f	language:C++	class:State	access:public	signature:(const State &item)
copy	include/mshadow/tensor_blob.h	/^      std::copy(s.data_heap_, s.data_heap_ + ndim_, data_heap_);$/;"	p	language:C++	class:mshadow::TShape::std	signature:(s.data_heap_, s.data_heap_ + ndim_, data_heap_)
copy	include/mshadow/tensor_blob.h	/^      std::copy(s.data_stack_, s.data_stack_ + ndim_, data_stack_);$/;"	p	language:C++	class:mshadow::TShape::std	signature:(s.data_stack_, s.data_stack_ + ndim_, data_stack_)
copy	include/mshadow/tensor_blob.h	/^    std::copy(begin, end, data());$/;"	p	language:C++	class:mshadow::TShape::std	signature:(begin, end, data())
copy	include/mshadow/tensor_blob.h	/^    std::copy(src, src + ndim_, data());$/;"	p	language:C++	class:mshadow::TShape::std	signature:(src, src + ndim_, data())
copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsL, m_nNextWord, m_lDepsL);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL, m_nNextWord, m_lDepsL)
copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsL2, m_nNextWord, m_lDepsL2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL2, m_nNextWord, m_lDepsL2)
copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsR, m_nNextWord, m_lDepsR);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR, m_nNextWord, m_lDepsR)
copy_n	depparser/State.h	/^				std::copy_n(item.m_lDepsR2, m_nNextWord, m_lDepsR2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR2, m_nNextWord, m_lDepsR2)
copy_n	depparser/State.h	/^				std::copy_n(item.m_lHeads, m_nNextWord, m_lHeads);$/;"	p	language:C++	class:State::std	signature:(item.m_lHeads, m_nNextWord, m_lHeads)
copy_n	depparser/State.h	/^				std::copy_n(item.m_lLabels, m_nNextWord, m_lLabels);$/;"	p	language:C++	class:State::std	signature:(item.m_lLabels, m_nNextWord, m_lLabels)
copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsL, m_nNextWord, m_lDepsL);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL, m_nNextWord, m_lDepsL)
copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsL2, m_nNextWord, m_lDepsL2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsL2, m_nNextWord, m_lDepsL2)
copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsR, m_nNextWord, m_lDepsR);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR, m_nNextWord, m_lDepsR)
copy_n	depparser/State.h	/^			std::copy_n(item.m_lDepsR2, m_nNextWord, m_lDepsR2);$/;"	p	language:C++	class:State::std	signature:(item.m_lDepsR2, m_nNextWord, m_lDepsR2)
copy_n	depparser/State.h	/^			std::copy_n(item.m_lHeads, m_nNextWord, m_lHeads);$/;"	p	language:C++	class:State::std	signature:(item.m_lHeads, m_nNextWord, m_lHeads)
copy_n	depparser/State.h	/^			std::copy_n(item.m_lLabels, m_nNextWord, m_lLabels);$/;"	p	language:C++	class:State::std	signature:(item.m_lLabels, m_nNextWord, m_lLabels)
copyin_version	include/mshadow-ps/ps_local-inl.h	/^    int copyin_version;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
correctState	depparser/Depparser.cpp	/^				State * correctState = lattice;$/;"	l	language:C++
correctStateIdx	depparser/Depparser.cpp	/^			    int correctStateIdx;$/;"	l	language:C++
count	include/mshadow-ps/ps_local-inl.h	/^    index_t count = tmp.shape_.Size();$/;"	l	language:C++
counter_	include/mshadow-ps/thread_util.h	/^  utils::Semaphore counter_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
cp_version	include/mshadow-ps/ps_local-inl.h	/^        int cp_version = e.copyin_version;$/;"	l	language:C++
cpu	include/mshadow/tensor.h	/^struct cpu {$/;"	s	language:C++	namespace:mshadow
cpu_res	thirdparty/mshadow/guide/basic_stream.cu	/^  Tensor<cpu, 2> cpu_res = NewTensor<cpu, float>(Shape2(2, 2), 0.0f);$/;"	l	language:C++
crop	include/mshadow/extension/crop.h	/^crop(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape)
crop	include/mshadow/extension/crop.h	/^crop(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape, index_t start_height, index_t start_width)
cuda	include/mshadow/cuda/reduce.cuh	/^namespace cuda {$/;"	n	language:C++	namespace:mshadow	file:
cuda	include/mshadow/cuda/tensor_gpu-inl.cuh	/^namespace cuda {$/;"	n	language:C++	namespace:mshadow	file:
currentBeamSize	depparser/Depparser.cpp	/^			    int currentBeamSize = 1; \/\/ initially, the beam only have one empty state$/;"	l	language:C++
currentThreadData	depparser/Depparser.cpp	/^			auto currentThreadData = multiThread_miniBtach_data[omp_get_thread_num()];$/;"	l	language:C++
custom_server	include/mshadow-ps/ps_local-inl.h	/^  IModelUpdater<DType> *custom_server;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:protected
d	Dict_test.cpp	/^	Dict d(list);$/;"	p	language:C++	file:	signature:(list)
d	include/mshadow-ps/ps_local-inl.h	/^      double d = std::abs(tmp.dptr_[i] - e.weight.dptr_[i]);$/;"	l	language:C++
d	include/mshadow/tensor_blob.h	/^    const index_t *d = dim <= kStackCache ? data_stack_ : data_heap_;$/;"	l	language:C++
d	include/mshadow/tensor_blob.h	/^    const index_t *d = this->data();$/;"	l	language:C++
d	include/mshadow/tensor_blob.h	/^    index_t *d = dim <= kStackCache ? data_stack_ : data_heap_;$/;"	l	language:C++
data	include/mshadow-ps/ps_local-inl.h	/^    Tensor<cpu, 4, DType> data;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
data	include/mshadow-ps/ps_local-inl.h	/^    Tensor<xpu, 2, DType> data;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public
data	include/mshadow-ps/ps_rabit-inl.h	/^    mshadow::Tensor<cpu, 2> data;$/;"	m	language:C++	struct:mshadow::ps::RabitModel::ReduceTask	access:public
data	include/mshadow-ps/thread_util.h	/^    DType data;$/;"	m	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public
data	include/mshadow/tensor_blob.h	/^  inline const index_t *data() const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:() const
data	include/mshadow/tensor_blob.h	/^  inline index_t *data() {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:()
data	thirdparty/mshadow/guide/README.md	/^  float data[20];$/;"	l	language:C++
data	thirdparty/mshadow/guide/README.md	/^The result ts should be a 3 * 2 matrix, where data[2], data[5], data[8] are padding cells that are ignored. If you want a continuous memory, set ```stride_=shape_[1]```.$/;"	v	language:C++
data	thirdparty/mshadow/guide/README.md	/^float data[9] = {0, 1, 2, 3, 4, 5, 6, 7, 8};$/;"	v	language:C++
data	thirdparty/mshadow/guide/basic.cpp	/^  float data[20];$/;"	l	language:C++
data	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  Print(data);$/;"	v	language:C++
data_	include/mshadow/sse-inl.h	/^  DType data_;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
data_	include/mshadow/tensor_container.h	/^  Tensor<Device, 2, DType> data_;$/;"	m	language:C++	class:mshadow::TensorContainer	access:private
data_	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  std::map<int, Tensor<cpu, 1, DType> > data_;$/;"	m	language:C++	class:mshadow::ps::Updater	access:protected
data_heap_	include/mshadow/tensor_blob.h	/^  index_t *data_heap_;$/;"	m	language:C++	struct:mshadow::TShape	access:private
data_pooled_	include/mshadow/extension/channel_unpool.h	/^  const SrcExp &data_pooled_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
data_pooled_	include/mshadow/extension/spatial_unpool.h	/^  const SrcExp &data_pooled_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
data_src_	include/mshadow/extension/channel_unpool.h	/^  const SrcExp &data_src_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
data_src_	include/mshadow/extension/spatial_unpool.h	/^  const SrcExp &data_src_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
data_stack_	include/mshadow/tensor_blob.h	/^  index_t data_stack_[kStackCache];$/;"	m	language:C++	struct:mshadow::TShape	access:private
dbstr	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^    ss << dbstr(ts[i]) << "\\n";$/;"	p	language:C++	signature:(ts[i])
dbstr	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^std::string dbstr(mshadow::Tensor<mshadow::cpu, 1, DType> ts) {$/;"	f	language:C++	signature:(mshadow::Tensor<mshadow::cpu, 1, DType> ts)
dbstr	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^std::string dbstr(mshadow::Tensor<mshadow::cpu, 2, DType> ts) {$/;"	f	language:C++	signature:(mshadow::Tensor<mshadow::cpu, 2, DType> ts)
dbstr	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^std::string dbstr(mshadow::Tensor<mshadow::cpu, 3, DType> ts) {$/;"	f	language:C++	signature:(mshadow::Tensor<mshadow::cpu, 3, DType> ts)
dbstr	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^             << ": after sync\\n" << dbstr(data);$/;"	p	language:C++	signature:(data)
dbstr	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^             << dbstr(data);$/;"	p	language:C++	signature:(data)
dcat_src1_	include/mshadow/extension/concat.h	/^  index_t dcat_src1_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
dcat_src2_	include/mshadow/extension/concat.h	/^  index_t dcat_src2_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
default_real_t	include/mshadow/base.h	/^typedef float default_real_t;$/;"	t	language:C++	namespace:mshadow
depLabels	depparser/Depparser.h	/^	Dict depLabels;$/;"	m	language:C++	class:Depparser	access:private
dest	include/mshadow-ps/ps_local-inl.h	/^    Tensor<xpu, 2, DType> dest;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
destroy_reduce_thread_	include/mshadow-ps/ps_rabit-inl.h	/^  bool destroy_reduce_thread_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
destroy_signal	include/mshadow-ps/ps_local-inl.h	/^  bool destroy_signal;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
dev	include/mshadow-ps/mshadow_ps.h	/^    std::vector<int> dev;$/;"	l	language:C++
dev2index	include/mshadow-ps/ps_local-inl.h	/^  std::vector<int> dev2index;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
dev_mask_	include/mshadow/tensor_blob.h	/^  int dev_mask_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
device_count	include/mshadow/tensor_gpu-inl.h	/^  int device_count = 0;$/;"	l	language:C++
device_id	include/mshadow/tensor_gpu-inl.h	/^  int device_id = 0;$/;"	l	language:C++
devices	include/mshadow-ps/ps_local-inl.h	/^  std::vector<int> devices;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
devid	include/mshadow-ps/ps_local-inl.h	/^        const int devid = tsk.second;$/;"	l	language:C++
devid	include/mshadow-ps/ps_local-inl.h	/^      int devid = devices[i];$/;"	l	language:C++
devid	include/mshadow-ps/ps_local-inl.h	/^    int devid;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public
devid	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int devid;$/;"	m	language:C++	class:NNet	file:	access:private
devs	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  std::vector<int> devs;$/;"	l	language:C++
devs	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  std::vector<int> devs;$/;"	l	language:C++
devs	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  std::vector<int> devs;$/;"	l	language:C++
diff	include/mshadow-ps/ps_local-inl.h	/^    double diff = 0.0, ssum = 0.0, maxdiff = 0.0;$/;"	l	language:C++
dim3	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimGrid((eshape[1] + kMemUnit - 1) >> kMemUnitBits);$/;"	p	language:C++	file:	signature:(eshape[1] + kMemUnit - 1) >> kMemUnitBits
dimBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimBlock(kBaseThreadNum);$/;"	p	language:C++	file:	signature:(kBaseThreadNum)
dimBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimBlock(kBaseThreadNum, 1, 1);$/;"	p	language:C++	file:	signature:(kBaseThreadNum, 1, 1)
dimBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimBlock(kMemUnit, kMemUnit);$/;"	p	language:C++	file:	signature:(kMemUnit, kMemUnit)
dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    dim3 dimGrid(kBaseGridNum, 1 , 1);$/;"	p	language:C++	file:	signature:(kBaseGridNum, 1 , 1)
dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    dim3 dimGrid(num_block, 1, 1);$/;"	p	language:C++	file:	signature:(num_block, 1, 1)
dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimGrid (pshape[1]);$/;"	p	language:C++	file:	signature:(pshape[1])
dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimGrid(dst.size(0));$/;"	p	language:C++	file:	signature:(dst.size(0))
dimcat	include/mshadow/extension/concat.h	/^  static const int dimcat = srcdim - dimsrc_m_cat;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
dimcat	include/mshadow/extension/concat.h	/^  static const int dimcat = srcdim - dimsrc_m_cat;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:public
dimkeep	include/mshadow/extension/reduceto1d.h	/^  static const int dimkeep = ExpInfo<SrcExp>::kDim - m_dimkeep;$/;"	m	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public
dimsrc	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
dimsrc	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
dimsrc	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
dimsrc	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
disable_allreduce_	include/mshadow-ps/ps_rabit-inl.h	/^  int disable_allreduce_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
div	include/mshadow/base.h	/^struct div {$/;"	s	language:C++	namespace:mshadow::op
divto	include/mshadow/base.h	/^struct divto {$/;"	s	language:C++	namespace:mshadow::sv
dnn_handle_	include/mshadow/stream_gpu-inl.h	/^  cudnnHandle_t dnn_handle_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
dnn_handle_ownership_	include/mshadow/stream_gpu-inl.h	/^  HandleState dnn_handle_ownership_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
dot	include/mshadow/expression.h	/^dot(const RValueExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs)
dot	include/mshadow/expression.h	/^dot(const RValueExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs)
dot	include/mshadow/expression.h	/^dot(const TransposeExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TransposeExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs)
dot	include/mshadow/expression.h	/^dot(const TransposeExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TransposeExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs)
dplan	include/mshadow/tensor_cpu-inl.h	/^  expr::Plan<R, DType> dplan = MakePlan(dst->self());$/;"	l	language:C++
dplan	include/mshadow/tensor_cpu-inl.h	/^  expr::Plan<R, DType> dplan = expr::MakePlan(dst->self());$/;"	l	language:C++
dptr	include/mshadow/tensor_cpu-inl.h	/^  void *dptr = AllocHost_<xpu>(obj->MSize() * sizeof(DType));$/;"	l	language:C++
dptr	include/mshadow/tensor_cpu-inl.h	/^  void *dptr;$/;"	l	language:C++
dptr_	include/mshadow/expr_engine-inl.h	/^  DType  *dptr_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
dptr_	include/mshadow/sse-inl.h	/^  const DType  *dptr_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
dptr_	include/mshadow/tensor.h	/^  DType *dptr_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
dptr_	include/mshadow/tensor_blob.h	/^  void *dptr_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
dptr_	thirdparty/mshadow/guide/README.md	/^  DType *dptr_;$/;"	m	language:C++	struct:Tensor	file:	access:public
dptr_	thirdparty/mshadow/guide/README.md	/^  float *dptr_;$/;"	m	language:C++	struct:Tensor	file:	access:public
dptr_	thirdparty/mshadow/guide/README.md	/^* ``` Tensor<cpu, 2>``` contains ```dptr_```, which points to the space that backup the tensor.$/;"	v	language:C++
dshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<1> dshape = expr::ShapeCheck<1, R>::Check(dst->self());$/;"	l	language:C++
dshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<dim> dshape = expr::ShapeCheck<dim, R>::Check(dst->self());$/;"	l	language:C++
dshape	include/mshadow/tensor_gpu-inl.h	/^    Shape<1> dshape = expr::ShapeCheck<1, R>::Check(dst->self());$/;"	l	language:C++
dshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<1> dshape = expr::ShapeCheck<1, R>::Check(dst->self());$/;"	l	language:C++
dshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<dim> dshape = expr::ShapeCheck<dim, R>::Check(dst->self());$/;"	l	language:C++
dst	include/mshadow/dot_engine-inl.h	/^    Tensor<xpu, 1, DType> &dst = *p_dst;$/;"	l	language:C++
dst	include/mshadow/dot_engine-inl.h	/^    Tensor<xpu, 2, DType> &dst = *p_dst;$/;"	l	language:C++
dst	include/mshadow/io.h	/^  Tensor<cpu, 2, DType> dst = dst_->FlatTo2D();$/;"	l	language:C++
dst	include/mshadow/sse-inl.h	/^  Tensor<cpu, 2, DType> dst = _dst.FlatTo2D();$/;"	l	language:C++
dst	include/mshadow/tensor_cpu-inl.h	/^  Tensor<cpu, 2, DType> dst = _dst.FlatTo2D();$/;"	l	language:C++
dst	include/mshadow/tensor_gpu-inl.h	/^  Tensor<A, 2, DType> dst = _dst.FlatTo2D();$/;"	l	language:C++
dst	tags	/^LoadBinary	include\/mshadow\/io.h	\/^inline void LoadBinary(TStream &fi,  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst, bool pre_alloc)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
dst	thirdparty/mshadow/guide/exp-template/README.md	/^   - This only removes the need of expression template then expression generate space, say dst = A+B+C, dst does not contain space allocated before assignment.$/;"	v	language:C++
e	include/mshadow-ps/ps_local-inl.h	/^        PullEntry &e = pull_map.GetRef(key);$/;"	l	language:C++
e	include/mshadow-ps/ps_local-inl.h	/^        PushEntry &e = push_map.GetRef(key);$/;"	l	language:C++
e	include/mshadow-ps/ps_local-inl.h	/^        PushEntry &e = push_map.GetRef(tsk.key);$/;"	l	language:C++
e	include/mshadow-ps/ps_local-inl.h	/^    PullEntry &e = pull_map.GetRef(key);$/;"	l	language:C++
e	include/mshadow-ps/ps_local-inl.h	/^    PushEntry &e = push_map.GetRef(key);$/;"	l	language:C++
e	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      UpdateEntry *e = static_cast<UpdateEntry*>(arg);$/;"	l	language:C++
emplace_back	depparser/Depparser.cpp	/^						trainingStates.emplace_back(correctState);$/;"	p	language:C++	file:	signature:(correctState)
emplace_back	depparser/Depparser.cpp	/^			    	nets.emplace_back(net);$/;"	p	language:C++	file:	signature:(net)
empty_arc	depparser/DepAction.h	/^const int empty_arc = -1;$/;"	v	language:C++
empty_label	depparser/DepAction.h	/^const int empty_label = -1;$/;"	v	language:C++
end	include/Pool.h	/^	list<SBlock *>::iterator it, end;$/;"	m	language:C++	class:CPool	access:private
endl	depparser/DepTree.h	/^		os << std::endl;$/;"	m	language:C++	class:DepTree::std
endl	depparser/Depparser.cpp	/^					std::cout<<"Processing sentence "<<inst<<std::endl;$/;"	m	language:C++	class:std	file:
endl	depparser/Depparser.cpp	/^	std::cout<<"Training Instance Num: "<<inputs.size()<<std::endl;$/;"	m	language:C++	class:std	file:
endl	depparser/Depparser.cpp	/^	std::cout<<"Training begin!"<<std::endl;$/;"	m	language:C++	class:std	file:
ep	depparser/Depparser.cpp	/^		auto ep = sp + threadExampleNum;$/;"	l	language:C++
equal	depparser/State.h	/^	inline bool equal(const State &item) const {$/;"	f	language:C++	class:State	access:public	signature:(const State &item) const
erase	include/Pool.cpp	/^				m_listFree.erase (it);$/;"	p	language:C++	file:	signature:(it)
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasDgemm(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasDgemv(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasDger(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSetStream(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSgemm(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSgemv(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSger(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^      cublasStatus_t err = cublasDestroy(blas_handle_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^      cudnnStatus_t err = cudnnDestroy(dnn_handle_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^    cublasStatus_t err = cublasCreate(&blas_handle_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^    cudaError_t err = cudaStreamQuery(stream_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^    cudaError_t err = cudaStreamSynchronize(stream_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^    cudnnStatus_t err = cudnnCreate(&dnn_handle_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^  cudaError_t err = cudaStreamCreate(&st->stream_);$/;"	l	language:C++
err	include/mshadow/stream_gpu-inl.h	/^  cudaError_t err = cudaStreamDestroy(stream->stream_);$/;"	l	language:C++
err	include/mshadow/tensor_gpu-inl.h	/^    cudaError_t err =$/;"	l	language:C++
err	include/mshadow/tensor_gpu-inl.h	/^  cudaError_t err = cudaMemcpy2DAsync(dst.dptr_, dst.stride_ * sizeof(DType),$/;"	l	language:C++
eshape	include/mshadow/tensor_cpu-inl.h	/^  EShape eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
eshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<2> eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
eshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<dim> eshape = expr::ShapeCheck<dim, E>::Check(exp.self());$/;"	l	language:C++
eshape	include/mshadow/tensor_gpu-inl.h	/^  EShape eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
eshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<2> eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
eshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<dim> eshape = expr::ShapeCheck<dim, E>::Check(exp.self());$/;"	l	language:C++
eta	include/NNet.h	/^    const float eta = 0.8;$/;"	l	language:C++
eta	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    const float eta = 0.1;$/;"	l	language:C++
eta	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    const float eta = 0.8;$/;"	l	language:C++
eta	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      const float eta = 0.8;$/;"	l	language:C++
example	depparser/Depparser.cpp	/^				GlobalExample * example =  currentThreadData[inst];$/;"	l	language:C++
example	depparser/Depparser.cpp	/^			Example example(features, labels);$/;"	p	language:C++	file:	signature:(features, labels)
examples	depparser/Depparser.cpp	/^		std::vector<Example> examples; \/\/features and labels$/;"	l	language:C++
examples	depparser/GlobalExample.h	/^	std::vector<Example> examples;$/;"	m	language:C++	class:GlobalExample	access:public
exp	include/mshadow/expression.h	/^  const EType &exp;$/;"	m	language:C++	struct:mshadow::expr::TransposeExp	access:public
exp	include/mshadow/expression.h	/^  const EType &exp;$/;"	m	language:C++	struct:mshadow::expr::TypecastExp	access:public
expr	include/mshadow/dot_engine-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/expr_engine-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/expr_scalar-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/expression.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/broadcast.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/channel_pool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/channel_unpool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/concat.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/crop.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/mirror.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/pack_col2patch.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/pad.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/reduceto1d.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/reshape.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/spatial_pool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/spatial_unpool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/swapaxis.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/extension/unpack_patch2col.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expr	include/mshadow/sse-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
expressions	thirdparty/mshadow/guide/README.md	/^Also note that the defined operation can be **composited into expressions**, not only we can write ```out = F<sigmoid>(in)```,$/;"	x	language:C++
fBPRate	depparser/Config.cpp	/^			CConfig::fBPRate = atof(pVal);$/;"	m	language:C++	class:CConfig	file:
fBPRate	depparser/Config.cpp	/^double  CConfig::fBPRate = 0.1;$/;"	m	language:C++	class:CConfig	file:
fBPRate	depparser/Config.h	/^	static double fBPRate;$/;"	m	language:C++	class:CConfig	access:public
fEmb	depparser/Depparser.cpp	/^	FeatureEmbedding fEmb(CConfig::nFeatureNum, CConfig::nEmbeddingDim, beamSize);$/;"	p	language:C++	file:	signature:(CConfig::nFeatureNum, CConfig::nEmbeddingDim, beamSize)
fFinalMom	depparser/Config.cpp	/^			CConfig::fFinalMom = atof(pVal);$/;"	m	language:C++	class:CConfig	file:
fFinalMom	depparser/Config.cpp	/^double  CConfig::fFinalMom = 0.5;$/;"	m	language:C++	class:CConfig	file:
fInitMom	depparser/Config.cpp	/^			CConfig::fInitMom = atof(pVal);$/;"	m	language:C++	class:CConfig	file:
fInitMom	depparser/Config.cpp	/^double  CConfig::fInitMom = 0.5;$/;"	m	language:C++	class:CConfig	file:
fInitRange	depparser/Config.h	/^	static double fInitRange;$/;"	m	language:C++	class:CConfig	access:public
featEmbeddings	include/FeatureEmbedding.h	/^	TensorContainer<xpu,2> featEmbeddings;$/;"	m	language:C++	class:FeatureEmbedding	access:public
featureExtract	depparser/Depparser.cpp	/^void Depparser::featureExtract(State* state, std::vector<int>& wordIndexCache,$/;"	f	language:C++	class:Depparser	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector<int> & features)
featureExtract	depparser/Depparser.h	/^	void featureExtract(State* state, std::vector<int>& wordIndexCache,$/;"	p	language:C++	class:Depparser	access:public	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector<int>& features)
featureNum	depparser/Depparser.h	/^	static int featureNum = 48;$/;"	m	language:C++	class:Depparser	access:private
featureVectors	depparser/Depparser.cpp	/^					std::vector<std::vector<int> > featureVectors($/;"	p	language:C++	file:	signature:( currentBeamSize)
features	depparser/Depparser.cpp	/^			std::vector<int> features(featureNum);$/;"	p	language:C++	file:	signature:(featureNum)
features	depparser/Example.h	/^	std::vector<int> features;$/;"	m	language:C++	class:Example	access:public
featvec	depparser/Depparser.cpp	/^		std::vector<int> featvec(CConfig::nFeatureNum);$/;"	p	language:C++	file:	signature:(CConfig::nFeatureNum)
fi	thirdparty/mshadow/guide/neuralnet/util.h	/^  FILE *fi = fopen(path_img, "rb");$/;"	l	language:C++
fill	include/mshadow-ps/ps_local-inl.h	/^          std::fill(e.copied.begin(), e.copied.end(), false);$/;"	p	language:C++	class:mshadow::ps::LocalModel::std	signature:(e.copied.begin(), e.copied.end(), false)
finished	include/mshadow-ps/ps_local-inl.h	/^    bool finished;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullWaitRecord	access:public
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v	language:C++
fp	depparser/Config.cpp	/^	FILE *fp = fopen(pszPath, "r");$/;"	l	language:C++
fp	depparser/Config.cpp	/^	FILE *fp = fopen(pszPath, "w");$/;"	l	language:C++
fp	include/mshadow-ps/mshadow_ps.h	/^    auto *fp = static_cast<std::function<void(Stream<xpu> *stream)>*>(fun);$/;"	l	language:C++
fpIn	depparser/Config.cpp	/^	FILE *fpIn = fopen(pszPath, "r");$/;"	l	language:C++
fqueue_	include/mshadow-ps/thread_util.h	/^  std::queue<DType> fqueue_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
fread	thirdparty/mshadow/guide/neuralnet/util.h	/^  assert(fread(l_data, num_image , 1 , fi));    $/;"	p	language:C++	signature:(l_data, num_image , 1 , fi)
fread	thirdparty/mshadow/guide/neuralnet/util.h	/^  assert(fread(t_data, step*num_image , 1 , fi));$/;"	p	language:C++	signature:(t_data, step*num_image , 1 , fi)
fread	thirdparty/mshadow/guide/neuralnet/util.h	/^  assert(fread(zz, 4 , 1, fi));                    $/;"	p	language:C++	signature:(zz, 4 , 1, fi)
fread	thirdparty/mshadow/guide/neuralnet/util.h	/^  assert(fread(zz, 4 , 1, fi));                $/;"	p	language:C++	signature:(zz, 4 , 1, fi)
fread	thirdparty/mshadow/guide/neuralnet/util.h	/^  assert(fread(zz, 4 , 1, fi));    $/;"	p	language:C++	signature:(zz, 4 , 1, fi)
fread	thirdparty/mshadow/guide/neuralnet/util.h	/^  assert(fread(zz, 4 , 1, fi));$/;"	p	language:C++	signature:(zz, 4 , 1, fi)
g1	include/mshadow/random.h	/^    DType g1 = 0.0f, g2 = 0.0f;$/;"	l	language:C++
g2	include/mshadow/random.h	/^    DType g1 = 0.0f, g2 = 0.0f;$/;"	l	language:C++
gExamples	depparser/Depparser.h	/^	std::vector<GlobalExample> gExamples;$/;"	m	language:C++	class:Depparser	access:private
gTree	depparser/Depparser.cpp	/^		auto gTree = goldTrees[i];$/;"	l	language:C++
g_Ki2h	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
g_Wh2o	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
g_Wh2o	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> Ki2h,  Wh2o, g_Ki2h, g_Wh2o;$/;"	m	language:C++	class:ConvNet	file:	access:private
g_Wh2o	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
g_Wh2o	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
g_Wi2h	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	access:private
g_Wi2h	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
g_Wi2h	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> Wi2h, Wh2o, g_Wi2h, g_Wh2o;$/;"	m	language:C++	class:NNet	file:	access:private
g_hbias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
g_hbias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
g_hbias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
g_hbias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
g_obias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
g_obias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
g_obias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
g_obias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
gaussian	include/mshadow/random.h	/^  gaussian(Shape<dim> shape) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Shape<dim> shape)
gaussian	include/mshadow/random.h	/^  gaussian(Shape<dim> shape, DType mu = 0.0f, DType sigma = 1.0f) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Shape<dim> shape, DType mu = 0.0f, DType sigma = 1.0f)
gemm	include/mshadow/dot_engine-inl.h	/^    BLASEngine<xpu>::gemm$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_, transpose_right , transpose_left, transpose_right ? rhs.size(0) : rhs.size(1), transpose_left ? lhs.size(1) : lhs.size(0), transpose_right ? rhs.size(1) : rhs.size(0), scale * SV::AlphaBLAS(), rhs.dptr_, rhs.stride_, lhs.dptr_, lhs.stride_, SV::BetaBLAS(), dst.dptr_, dst.stride_)
gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool transa, bool transb, int m, int n, int k, double alpha, const double *A, int lda, const double *B, int ldb, double beta, double *C, int ldc)
gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool transa, bool transb, int m, int n, int k, float alpha, const float *A, int lda, const float *B, int ldb, float beta, float *C, int ldc)
gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool transa, bool transb, int m, int n, int k, double alpha, const double *A, int lda, const double *B, int ldb, double beta, double *C, int ldc)
gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool transa, bool transb, int m, int n, int k, float alpha, const float *A, int lda, const float *B, int ldb, float beta, float *C, int ldc)
gemv	include/mshadow/dot_engine-inl.h	/^    BLASEngine<xpu>::gemv$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_, transpose_right, rhs.size(1), rhs.size(0), scale * SV::AlphaBLAS(), rhs.dptr_, rhs.stride_, lhs.dptr_, 1, SV::BetaBLAS(), dst.dptr_, 1)
gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool trans, int m, int n, double alpha, const double *A, int lda, const double *X, int incX, double beta, double *Y, int incY)
gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool trans, int m, int n, float alpha, const float *A, int lda, const float *X, int incX, float beta, float *Y, int incY)
gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool trans, int m, int n, double alpha, const double *A, int lda, const double *X, int incX, double beta, double *Y, int incY)
gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool trans, int m, int n, float alpha, const float *A, int lda, const float *X, int incX, float beta, float *Y, int incY)
gen_	include/mshadow/random.h	/^  curandGenerator_t gen_;$/;"	m	language:C++	class:mshadow::Random	access:private
generateTrainingExamples	depparser/Depparser.cpp	/^void Depparser::generateTrainingExamples(std::vector<DepParseInput> inputs,$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
generateTrainingExamples	depparser/Depparser.h	/^	void generateTrainingExamples(std::vector<DepParseInput> inputs,$/;"	p	language:C++	class:Depparser	access:private	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
ger	include/mshadow/dot_engine-inl.h	/^      BLASEngine<xpu>::ger$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_, rhs.size(0), lhs.size(0), scale * SV::AlphaBLAS(), rhs.dptr_, 1, lhs.dptr_, 1, dst.dptr_, dst.stride_)
ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, int m, int n, double alpha, const double *X, int incX, const double *Y, int incY, double *A, int lda)
ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, int m, int n, float alpha, const float *X, int incX, const float *Y, int incY, float *A, int lda)
ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, int m, int n, double alpha, const double *X, int incX, const double *Y, int incY, double *A, int lda)
ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, int m, int n, float alpha, const float *X, int incX, const float *Y, int incY, float *A, int lda)
get	include/mshadow/tensor_blob.h	/^  inline Shape<dim> get(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
get	include/mshadow/tensor_blob.h	/^  inline Tensor<Device, dim, DType> get(Stream<Device> *stream = NULL) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(Stream<Device> *stream = NULL) const
getDictionaries	depparser/Depparser.cpp	/^void Depparser::getDictionaries(std::vector<DepTree> goldTrees) {$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepTree> goldTrees)
getDictionaries	depparser/Depparser.h	/^	void getDictionaries(std::vector<DepTree> goldTrees);$/;"	p	language:C++	class:Depparser	access:private	signature:(std::vector<DepTree> goldTrees)
getIndex	include/Dict.h	/^	inline int getIndex(string word){$/;"	f	language:C++	class:Dict	access:public	signature:(string word)
getInputBatch	depparser/Depparser.cpp	/^void Depparser::getInputBatch(State* state, std::vector<int>& wordIndexCache,$/;"	f	language:C++	class:Depparser	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector<std::vector<int> >& featvecs)
getInputBatch	depparser/Depparser.h	/^	void getInputBatch(State* state, std::vector<int>& wordIndexCache,$/;"	p	language:C++	class:Depparser	access:private	signature:(State* state, std::vector<int>& wordIndexCache, std::vector<int>& tagIndexCache, std::vector< std::vector<int> >& features)
getLabel	depparser/Depparser.h	/^	inline int getLabel(std::string s) {$/;"	f	language:C++	class:Depparser	access:private	signature:(std::string s)
getLabelIndex	depparser/Depparser.h	/^	inline int getLabelIndex(int index, State* state){$/;"	f	language:C++	class:Depparser	access:private	signature:(int index, State* state)
getTag	depparser/Depparser.h	/^	inline int getTag(std::string s) {$/;"	f	language:C++	class:Depparser	access:private	signature:(std::string s)
getTagIndex	depparser/Depparser.h	/^	inline int getTagIndex(int index, std::vector<int> list){$/;"	f	language:C++	class:Depparser	access:private	signature:(int index, std::vector<int> list)
getValidActs	depparser/Depparser.cpp	/^						currentState->getValidActs(validActs);$/;"	p	language:C++	file:	signature:(validActs)
getValidActs	depparser/Depparser.cpp	/^			state->getValidActs(labels);$/;"	p	language:C++	file:	signature:(labels)
getWord	depparser/Depparser.h	/^	inline int getWord(std::string s) {$/;"	f	language:C++	class:Depparser	access:private	signature:(std::string s)
getWord	include/Dict.h	/^	inline string getWord(int index){$/;"	f	language:C++	class:Dict	access:public	signature:(int index)
getWordIndex	depparser/Depparser.h	/^	inline int getWordIndex(int index, std::vector<int> list){$/;"	f	language:C++	class:Depparser	access:private	signature:(int index, std::vector<int> list)
get_with_shape	include/mshadow/tensor_blob.h	/^  inline Tensor<Device, dim, DType> get_with_shape(const TShape &shape,$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(const TShape &shape, Stream<Device> *stream = NULL) const
goldAct	depparser/Depparser.cpp	/^			int goldAct = state->StandardMove(gTree, labelIndexCache);$/;"	l	language:C++
goldActs	depparser/GlobalExample.h	/^	std::vector<int> goldActs;$/;"	m	language:C++	class:GlobalExample	access:public
got	depparser/Depparser.h	/^		auto got = labelMap.find(s);$/;"	l	language:C++
got	depparser/Depparser.h	/^		auto got = tagMap.find(s);$/;"	l	language:C++
got	depparser/Depparser.h	/^		auto got = wordMap.find(s);$/;"	l	language:C++
got	include/Dict.h	/^		auto got = map.find(word);$/;"	l	language:C++
gpu	include/mshadow/tensor.h	/^struct gpu {$/;"	s	language:C++	namespace:mshadow
grad	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::Tensor<xpu, 2> grad;$/;"	m	language:C++	struct:NNet::UpdateEntry	file:	access:public
grad_pooled_	include/mshadow/extension/channel_unpool.h	/^  const SrcExp &grad_pooled_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
grad_pooled_	include/mshadow/extension/spatial_unpool.h	/^  const SrcExp &grad_pooled_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
grads	depparser/Depparser.cpp	/^						TensorContainer<cpu, 2> grads;$/;"	l	language:C++
h	include/mshadow/extension/crop.h	/^    const index_t h = y + pad_height_;$/;"	l	language:C++
h	include/mshadow/extension/pad.h	/^    const index_t h = y - pad_y_;$/;"	l	language:C++
handle	thirdparty/mshadow/guide/README.md	/^This means ```Tensor<cpu, k>``` variable is more like a reference handle(pointer), instead of a object. If we assign a tensor to another variable, the two share the same content space.$/;"	p	language:C++	file:	signature:(pointer)
hbias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
hbias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
hbias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
hbias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
head	depparser/DepTreeNode.h	/^	int head;$/;"	m	language:C++	class:DepTreeNode	access:public
height	thirdparty/mshadow/guide/neuralnet/util.h	/^  int num_image, width, height, nlabel;            $/;"	l	language:C++
height_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
higher	depparser/State.h	/^	inline bool higher(const State &item) const {$/;"	f	language:C++	class:State	access:public	signature:(const State &item) const
i	depparser/Depparser.cpp	/^						int i = 0;$/;"	l	language:C++
i	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    index_t i = i_offset + threadIdx.x;$/;"	l	language:C++
i_channel_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
i_channel_	include/mshadow/extension/unpack_patch2col.h	/^  index_t i_channel_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
i_height_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
i_height_	include/mshadow/extension/unpack_patch2col.h	/^  index_t i_height_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
i_width_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
i_width_	include/mshadow/extension/unpack_patch2col.h	/^  index_t i_width_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
identity	include/mshadow/base.h	/^struct identity{$/;"	s	language:C++	namespace:mshadow::op
idivh	include/mshadow/extension/pack_col2patch.h	/^    const index_t idivh = i \/ i_height_;$/;"	l	language:C++
idivp	include/mshadow/extension/unpack_patch2col.h	/^    const index_t idivp    = i \/ psize_x_;$/;"	l	language:C++
idx	include/mshadow/extension/reshape.h	/^    const index_t idx = y * oshapex_ + x;$/;"	l	language:C++
img	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
img	tags	/^unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
img_	include/mshadow/extension/unpack_patch2col.h	/^  const SrcExp &img_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
imshape	include/mshadow/extension/unpack_patch2col.h	/^    Shape<srcdim> imshape = ShapeCheck<srcdim, SrcExp>::Check(img_);$/;"	l	language:C++
index	depparser/Depparser.cpp	/^		int index = 0;$/;"	l	language:C++
index	depparser/Depparser.cpp	/^	int index = 0;$/;"	l	language:C++
index	include/Dict.h	/^		int index = 0;$/;"	l	language:C++
index_t	include/mshadow/base.h	/^typedef unsigned index_t;$/;"	t	language:C++	namespace:mshadow
init	depparser/Depparser.cpp	/^	NNet::init(beamSize, num_in, num_hidden, num_out);	\/\/init the static member in the neural net$/;"	p	language:C++	class:NNet	file:	signature:(beamSize, num_in, num_hidden, num_out)
init	depparser/Depparser.cpp	/^void Depparser::init(std::vector<DepParseInput> inputs,$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
init	depparser/Depparser.h	/^	void init(std::vector<DepParseInput> inputs,$/;"	p	language:C++	class:Depparser	access:public	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees)
init_end	include/mshadow-ps/ps_local-inl.h	/^  int init_end;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
init_reducer_	include/mshadow-ps/ps_rabit-inl.h	/^  int init_reducer_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
input	depparser/Depparser.cpp	/^			TensorContainer<cpu, 2> input;$/;"	l	language:C++
input	depparser/Depparser.cpp	/^		auto input = inputs[i];$/;"	l	language:C++
inputIndex	include/FeatureEmbedding.h	/^			int inputIndex = 0;$/;"	l	language:C++
inputSize	include/FeatureEmbedding.h	/^	int inputSize;$/;"	m	language:C++	class:FeatureEmbedding	access:public
insert	depparser/Depparser.cpp	/^			labelSet.insert(treeNode.label);$/;"	p	language:C++	file:	signature:(treeNode.label)
insert	depparser/Depparser.cpp	/^			tagSet.insert(treeNode.tag);$/;"	p	language:C++	file:	signature:(treeNode.tag)
insert	depparser/Depparser.cpp	/^			wordSet.insert(treeNode.word);$/;"	p	language:C++	file:	signature:(treeNode.word)
insertBeam	depparser/Depparser.h	/^	inline int insertBeam(const CScoredTransition& transition, CScoredTransition* beamTransitsint,$/;"	f	language:C++	class:Depparser	access:private	signature:(const CScoredTransition& transition, CScoredTransition* beamTransitsint, int currentBeamSize = beamSize)
insize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int insize = 28;$/;"	l	language:C++
is_bias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    bool is_bias;$/;"	m	language:C++	struct:NNet::UpdateEntry	file:	access:public
ishape	include/mshadow/extension/reshape.h	/^    Shape<dimsrc> ishape = ShapeCheck<dimsrc, SrcExp>::Check(src_);$/;"	l	language:C++
ishapex_	include/mshadow/extension/reshape.h	/^  const index_t oshapex_, ishapex_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
ishapex_	include/mshadow/extension/reshape.h	/^  index_t ishapex_;$/;"	m	language:C++	struct:mshadow::expr::ReshapeExp	access:public
iss_id	depparser/DepTreeNode.h	/^	   std::istringstream iss_id(line);$/;"	p	language:C++	signature:(line)
it	include/Pool.h	/^	list<SBlock *>::iterator it, end;$/;"	m	language:C++	class:CPool	access:private
it	include/mshadow-ps/ps_local-inl.h	/^        it = push_operation.find(key);$/;"	l	language:C++
it	include/mshadow-ps/thread_util.h	/^        it = map_.find(key);$/;"	l	language:C++
jdivw	include/mshadow/extension/unpack_patch2col.h	/^    const index_t jdivw = j \/ o_width_;$/;"	l	language:C++
kActNum	depparser/DepAction.h	/^  kActNum = CConfig::nLabelNum * 2 + 1,$/;"	e	language:C++	enum:StackActions
kArcLeftFirst	depparser/DepAction.h	/^  kArcLeftFirst = 1,$/;"	e	language:C++	enum:StackActions
kArcRightFirst	depparser/DepAction.h	/^  kArcRightFirst = CConfig::nLabelNum + 2,$/;"	e	language:C++	enum:StackActions
kBaseGridNum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kBaseGridNum = 1024;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kBaseThreadBits	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kBaseThreadBits = 8;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kBaseThreadNum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kBaseThreadNum  = 1 << kBaseThreadBits;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kChainer	include/mshadow/expression.h	/^const int kChainer = 3;$/;"	m	language:C++	namespace:mshadow::expr::type
kComplex	include/mshadow/expression.h	/^const int kComplex = 7;$/;"	m	language:C++	namespace:mshadow::expr::type
kDevCPU	include/mshadow/tensor.h	/^  static const bool kDevCPU = Device::kDevCPU;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
kDevCPU	include/mshadow/tensor.h	/^  static const bool kDevCPU = false;$/;"	m	language:C++	struct:mshadow::gpu	access:public
kDevCPU	include/mshadow/tensor.h	/^  static const bool kDevCPU = true;$/;"	m	language:C++	struct:mshadow::cpu	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = 0;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = 0xffff;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = Device::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<E>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<EType>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<SrcExp>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<TA>::kDevMask & ExpInfo<TB>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<TA>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDevMask	include/mshadow/extension/concat.h	/^  static const int kDevMask = ExpInfo<LhsExp>::kDevMask & ExpInfo<RhsExp>::kDevMask;$/;"	l	language:C++
kDevMask	include/mshadow/tensor.h	/^  static const int kDevMask = 1 << 0;$/;"	m	language:C++	struct:mshadow::cpu	access:public
kDevMask	include/mshadow/tensor.h	/^  static const int kDevMask = 1 << 1;$/;"	m	language:C++	struct:mshadow::gpu	access:public
kDevPass	include/mshadow/expr_engine-inl.h	/^  static const bool kDevPass = (ExpInfo<E>::kDevMask & Device::kDevMask) != 0;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = (kDimLhs >= 0 && kDimRhs >= 0) ?\\$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = -1;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = 0;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = ExpInfo<E>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = ExpInfo<EType>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = ExpInfo<TA>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = dim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = kDimSrc >= 0 ? dim : -1;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDimLhs	include/mshadow/expr_engine-inl.h	/^  static const int kDimLhs = ExpInfo<TA>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDimRhs	include/mshadow/expr_engine-inl.h	/^  static const int kDimRhs = ExpInfo<TB>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDimSrc	include/mshadow/expr_engine-inl.h	/^  static const int kDimSrc = ExpInfo<SrcExp>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
kDimension	include/mshadow/tensor.h	/^  static const int kDimension = dimension;$/;"	m	language:C++	struct:mshadow::Shape	access:public
kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = false;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = false;$/;"	m	language:C++	struct:mshadow::sse2::SSEOp	access:public
kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = true;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = true;$/;"	m	language:C++	struct:mshadow::sse2::SSEOp	access:public
kExpDim	include/mshadow/expr_engine-inl.h	/^  static const int kExpDim = ExpInfo<E>::kDim;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
kFlag	include/mshadow/tensor_blob.h	/^  static const int kFlag = 0;$/;"	m	language:C++	struct:mshadow::DataType	access:public
kFlag	include/mshadow/tensor_blob.h	/^  static const int kFlag = 1;$/;"	m	language:C++	struct:mshadow::DataType	access:public
kGather	include/mshadow-ps/ps_local-inl.h	/^    kGather = 1$/;"	e	language:C++	enum:mshadow::ps::LocalModel::LocalOp
kMapPass	include/mshadow/expr_engine-inl.h	/^  static const bool kMapPass = (kExpDim == 0 || kExpDim == dim) && kDevPass;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
kMapper	include/mshadow/expression.h	/^const int kMapper = 1;$/;"	m	language:C++	namespace:mshadow::expr::type
kMaxGridNum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMaxGridNum = 65535;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kMaxThreadsPerBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMaxThreadsPerBlock = 512;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kMemUnit	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMemUnit = 1 << kMemUnitBits;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kMemUnitBits	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMemUnitBits = 4;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kMemUnitMask	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMemUnitMask = kMemUnit - 1;$/;"	m	language:C++	namespace:mshadow::cuda	file:
kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = SSECheck<TA>::kPass && sse2::SSEOp<OP>::kEnabled;$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = SSECheck<TA>::kPass &&$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = false;$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = sse2::FVec<DType>::kEnabled;$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
kPi	include/mshadow/base.h	/^const float kPi = 3.1415926f;$/;"	m	language:C++	namespace:mshadow
kPrintBuffer	include/mshadow/utils.h	/^const int kPrintBuffer = 1 << 12;$/;"	m	language:C++	namespace:mshadow::utils
kRValue	include/mshadow/expression.h	/^const int kRValue = 0;$/;"	m	language:C++	namespace:mshadow::expr::type
kRandBufferSize	include/mshadow/base.h	/^const unsigned kRandBufferSize = 1000000;$/;"	m	language:C++	namespace:mshadow
kRedPass	include/mshadow/expr_engine-inl.h	/^  static const bool kRedPass = (kExpDim > dim) && kDevPass;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
kShift	depparser/DepAction.h	/^  kShift = 0,$/;"	e	language:C++	enum:StackActions
kSize	include/mshadow/sse-inl.h	/^  static const index_t kSize = 2;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
kSize	include/mshadow/sse-inl.h	/^  static const index_t kSize = 4;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
kStackCache	include/mshadow/tensor_blob.h	/^  static const index_t kStackCache = 4;$/;"	m	language:C++	struct:mshadow::TShape	access:private
kSubdim	include/mshadow/tensor.h	/^  static const int  kSubdim = dimension - 1;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
kSubdim	include/mshadow/tensor.h	/^  static const int kSubdim = dimension - 1;$/;"	m	language:C++	struct:mshadow::Shape	access:public
kSum	include/mshadow-ps/ps_local-inl.h	/^    kSum = 0,$/;"	e	language:C++	enum:mshadow::ps::LocalModel::LocalOp
key	include/mshadow-ps/ps_local-inl.h	/^        const int key = tsk.first;$/;"	l	language:C++
key	include/mshadow-ps/ps_local-inl.h	/^    int key;$/;"	l	language:C++
key	include/mshadow-ps/ps_local-inl.h	/^    int key;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public
key	include/mshadow-ps/ps_rabit-inl.h	/^        int key = tsk.key;$/;"	l	language:C++
key	include/mshadow-ps/ps_rabit-inl.h	/^    int key;$/;"	m	language:C++	struct:mshadow::ps::RabitModel::ReduceTask	access:public
knowLabels	depparser/Depparser.h	/^	std::vector<std::string> knowLabels;$/;"	m	language:C++	class:Depparser	access:private
knowTags	depparser/Depparser.h	/^	std::vector<std::string> knowTags;$/;"	m	language:C++	class:Depparser	access:private
knowWords	depparser/Depparser.h	/^	std::vector<std::string> knowWords;$/;"	m	language:C++	class:Depparser	access:private
ksize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize = 5;$/;"	l	language:C++
ksize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize, kstride, psize;$/;"	m	language:C++	class:ConvNet	file:	access:private
ksize_x_	include/mshadow/extension/spatial_pool.h	/^  const index_t ksize_y_, ksize_x_, kstride_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
ksize_x_	include/mshadow/extension/spatial_pool.h	/^  index_t ksize_x_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
ksize_x_	include/mshadow/extension/spatial_unpool.h	/^  index_t ksize_x_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
ksize_y_	include/mshadow/extension/spatial_pool.h	/^  const index_t ksize_y_, ksize_x_, kstride_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
ksize_y_	include/mshadow/extension/spatial_pool.h	/^  index_t ksize_y_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
ksize_y_	include/mshadow/extension/spatial_unpool.h	/^  index_t ksize_y_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
kstride	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize, kstride, psize;$/;"	m	language:C++	class:ConvNet	file:	access:private
kstride	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int kstride = 1;$/;"	l	language:C++
kstride_	include/mshadow/extension/channel_unpool.h	/^  index_t kstride_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
kstride_	include/mshadow/extension/spatial_pool.h	/^  const index_t ksize_y_, ksize_x_, kstride_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
kstride_	include/mshadow/extension/spatial_pool.h	/^  index_t kstride_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
kstride_	include/mshadow/extension/spatial_unpool.h	/^  index_t kstride_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
l_data	thirdparty/mshadow/guide/neuralnet/util.h	/^  unsigned char *t_data, *l_data;$/;"	l	language:C++
label	depparser/DepTreeNode.h	/^	std::string label;$/;"	m	language:C++	class:DepTreeNode	access:public
labelIdx	depparser/Depparser.cpp	/^			auto labelIdx = labelMap.find(iter->label);$/;"	l	language:C++
labelIndexCache	depparser/Depparser.cpp	/^		std::vector<int> labelIndexCache(gTree.size);$/;"	p	language:C++	file:	signature:(gTree.size)
labelMap	depparser/Depparser.h	/^	std::unordered_map<std::string, int> labelMap;$/;"	m	language:C++	class:Depparser	access:private
labelNullIdx	depparser/Depparser.h	/^	static int labelNullIdx;$/;"	m	language:C++	class:Depparser	access:private
labelNum	depparser/Depparser.h	/^	const int labelNum;$/;"	m	language:C++	class:Depparser	access:private
labelSet	depparser/Depparser.cpp	/^	std::unordered_set labelSet;$/;"	l	language:C++
labels	depparser/Depparser.cpp	/^			std::vector<int> labels(kActNum, 0);$/;"	p	language:C++	file:	signature:(kActNum, 0)
labels	depparser/Example.h	/^	std::vector<int> labels;$/;"	m	language:C++	class:Example	access:public
language	tags	/^IStream	include\/mshadow\/io.h	\/^class IStream {$\/;"	c	language:C++	namespace:mshadow::utils$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^LoadBinary	include\/mshadow\/io.h	\/^inline void LoadBinary(TStream &fi,  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst, bool pre_alloc)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^Read	include\/mshadow\/io.h	\/^  virtual size_t Read(void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src);  \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^SaveBinary	include\/mshadow\/io.h	\/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src); \\\/\\\/ NOLINT(*)$\/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^Write	include\/mshadow\/io.h	\/^  virtual void Write(const void *ptr, size_t size) = 0;$\/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^mshadow::expr	include\/mshadow\/extension\/unpack_patch2col.h	\/^namespace expr {$\/;"	n	language:C++	namespace:mshadow$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, 1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
language	tags	/^mshadow::expr::Plan	include\/mshadow\/extension\/swapaxis.h	\/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
language	tags	/^mshadow::expr::Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$\/;"	s	language:C++	namespace:mshadow::expr$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
language	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6	file:	access:public
language	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
language	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/unpack_patch2col.h	\/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan	file:	access:public
language	tags	/^mshadow::expr::Plan::a1	include\/mshadow\/extension\/swapaxis.h	\/^  static const int a1 = dimsrc - m_a1;$\/;"	m	language:C++	struct:mshadow::expr::Plan	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^struct UnpackPatchToColXExp:$\/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::i_channel_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_channel_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::i_height_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_height_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::i_width_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t i_width_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::img_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  const SrcExp &img_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::imshape	include\/mshadow\/extension\/unpack_patch2col.h	\/^    Shape<srcdim> imshape = ShapeCheck<srcdim, SrcExp>::Check(img_);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::num	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t num = imshape.ProdShape(0, srcdim - 3);$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::o_height	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_height = (i_height_ - psize_y) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::o_width	include\/mshadow\/extension\/unpack_patch2col.h	\/^    const index_t o_width  = (i_width_  - psize_x) \\\/ pstride + 1;$\/;"	l	language:C++$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::psize_x_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_x_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::psize_y_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t psize_y_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::UnpackPatchToColXExp::pstride_	include\/mshadow\/extension\/unpack_patch2col.h	\/^  index_t pstride_;$\/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
language	tags	/^utils	include\/mshadow\/io.h	\/^namespace utils {$\/;"	n	language:C++	namespace:mshadow$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
language	tags	/^~IStream	include\/mshadow\/io.h	\/^  virtual ~IStream(void) {}$\/;"	f	language:C++	class:mshadow::utils::IStream	access:public	signature:(void)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7::Plan::__anon8	file:	access:public
last_action	depparser/State.h	/^	int last_action;$/;"	m	language:C++	class:State	access:public
lattice	depparser/Depparser.cpp	/^				State * lattice = new State[max_lattice_size];$/;"	l	language:C++
lattice_index	depparser/Depparser.cpp	/^				State * lattice_index = new State[maxRound];$/;"	l	language:C++
len_	depparser/State.h	/^	int len_;$/;"	m	language:C++	class:State	access:public
lhs	include/mshadow/sse-inl.h	/^    FVec<TFloat> lhs(dst);$/;"	p	language:C++	signature:(dst)
lhs_	include/mshadow/expr_engine-inl.h	/^  Plan<TA, DType> lhs_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
lhs_	include/mshadow/expression.h	/^  const TA &lhs_;$/;"	m	language:C++	struct:mshadow::expr::BinaryMapExp	access:public
lhs_	include/mshadow/expression.h	/^  const TA &lhs_;$/;"	m	language:C++	struct:mshadow::expr::DotExp	access:public
lhs_	include/mshadow/sse-inl.h	/^  SSEPlan<TA, DType> lhs_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
limits	include/mshadow/base.h	/^namespace limits {$/;"	n	language:C++	namespace:mshadow::red
line	depparser/DepTreeNode.h	/^	   std::string line;$/;"	l	language:C++
list	Dict_test.cpp	/^	vector<string> list = {"first", "second", "third"};$/;"	l	language:C++
load	include/Dict.h	/^	void load(vector<string> wordlist){$/;"	f	language:C++	class:Dict	access:public	signature:(vector<string> wordlist)
lock_	include/mshadow-ps/thread_util.h	/^  utils::Mutex lock_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
lock_	include/mshadow-ps/thread_util.h	/^  utils::Mutex lock_;$/;"	m	language:C++	class:mshadow::utils::ThreadSafeMap	access:private
m_Stack	depparser/State.h	/^	std::vector<int> m_Stack;$/;"	m	language:C++	class:State	access:private
m_a1	tags	/^Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
m_a1	tags	/^mshadow::expr::Plan::Plan	include\/mshadow\/extension\/swapaxis.h	\/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$\/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan	file:	access:public
m_bTrain	depparser/Depparser.h	/^	bool m_bTrain;$/;"	m	language:C++	class:Depparser	access:private
m_lDepTagL	depparser/State.h	/^	CSetOfTags<int> m_lDepTagL[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lDepTagR	depparser/State.h	/^	CSetOfTags<int> m_lDepTagR[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lDepsL	depparser/State.h	/^	int m_lDepsL[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lDepsL2	depparser/State.h	/^	int m_lDepsL2[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lDepsR	depparser/State.h	/^	int m_lDepsR[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lDepsR2	depparser/State.h	/^	int m_lDepsR2[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lHeads	depparser/State.h	/^	int m_lHeads[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_lLabels	depparser/State.h	/^	int m_lLabels[MAX_SENTENCE_SIZE];$/;"	m	language:C++	class:State	access:private
m_listFree	include/Pool.h	/^	list<SBlock *> m_listUsed, m_listFree;$/;"	m	language:C++	class:CPool	access:private
m_listUsed	include/Pool.h	/^	list<SBlock *> m_listUsed, m_listFree;$/;"	m	language:C++	class:CPool	access:private
m_nBlkSize	include/Pool.h	/^		size_t m_nBlkSize, m_nUsed;$/;"	m	language:C++	struct:CPool::SBlock	access:public
m_nNextWord	depparser/State.h	/^	int m_nNextWord;$/;"	m	language:C++	class:State	access:private
m_nUsed	include/Pool.h	/^		size_t m_nBlkSize, m_nUsed;$/;"	m	language:C++	struct:CPool::SBlock	access:public
m_pData	include/Pool.h	/^		char *m_pData;$/;"	m	language:C++	struct:CPool::SBlock	access:public
main	Dict_test.cpp	/^int main(){$/;"	f	language:C++	signature:()
main	thirdparty/mshadow/guide/README.md	/^int main(void) {$/;"	f	language:C++	signature:(void)
main	thirdparty/mshadow/guide/basic.cpp	/^int main(void) {$/;"	f	language:C++	signature:(void)
main	thirdparty/mshadow/guide/basic_stream.cu	/^int main(void) {$/;"	f	language:C++	signature:(void)
main	thirdparty/mshadow/guide/defop.cpp	/^int main(void) {$/;"	f	language:C++	signature:(void)
main	thirdparty/mshadow/guide/mshadow-ps/local_sum.cpp	/^int main(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
main	thirdparty/mshadow/guide/mshadow-ps/local_sum.cu	/^int main(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
main	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^int main(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
main	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^int main(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
main	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^int main(int argc, char *argv[]) {$/;"	f	language:C++	signature:(int argc, char *argv[])
make_pair	include/mshadow-ps/ps_local-inl.h	/^          pull_queues[0].Push(std::make_pair(key, devices[i]));$/;"	p	language:C++	signature:(key, devices[i])
make_pair	include/mshadow-ps/ps_local-inl.h	/^          pull_queues[i].Push(std::make_pair(key, devices[i]));$/;"	p	language:C++	signature:(key, devices[i])
make_pair	include/mshadow-ps/ps_local-inl.h	/^        pull_queues[0].Push(std::make_pair(key, devid));$/;"	p	language:C++	signature:(key, devid)
make_pair	include/mshadow-ps/ps_local-inl.h	/^        pull_queues[wid].Push(std::make_pair(key, devid));$/;"	p	language:C++	signature:(key, devid)
map	include/Dict.h	/^	unordered_map<string, int> map;$/;"	m	language:C++	class:Dict	access:private
map_	include/mshadow-ps/thread_util.h	/^  std::map<int, TValue*> map_;$/;"	m	language:C++	class:mshadow::utils::ThreadSafeMap	access:private
mat	include/mshadow/random.h	/^    Tensor<cpu, 2, DType> mat = dst->FlatTo2D();$/;"	l	language:C++
mat	thirdparty/mshadow/guide/README.md	/^  Tensor<cpu, 2> mat = ts[0];$/;"	l	language:C++
mat	thirdparty/mshadow/guide/basic.cpp	/^  Tensor<cpu, 2> mat = ts[0];$/;"	l	language:C++
mat	thirdparty/mshadow/guide/defop.cpp	/^  Tensor<cpu,2, float> mat = NewTensor<cpu>(Shape2(2,3), 0.0f, stream_);$/;"	l	language:C++
mat2	thirdparty/mshadow/guide/README.md	/^  Tensor<cpu, 2, float> mat2 = mat;$/;"	l	language:C++
mat2	thirdparty/mshadow/guide/basic.cpp	/^  Tensor<cpu, 2, float> mat2 = mat;$/;"	l	language:C++
mat2	thirdparty/mshadow/guide/defop.cpp	/^  Tensor<cpu,2, float> mat2= NewTensor<cpu>(Shape2(2,3), 0.0f, stream_);$/;"	l	language:C++
matrix	thirdparty/mshadow/guide/README.md	/^The result ts should be a 3 * 2 matrix, where data[2], data[5], data[8] are padding cells that are ignored. If you want a continuous memory, set ```stride_=shape_[1]```.$/;"	v	language:C++
maxRound	depparser/Depparser.cpp	/^				const int maxRound = sentLen * 2 + 1;$/;"	l	language:C++
maxScore	depparser/Depparser.cpp	/^				double maxScore = 0;$/;"	l	language:C++
max_lattice_size	depparser/Depparser.cpp	/^				const int max_lattice_size =  (beamSize + 1) * maxRound;$/;"	l	language:C++
maxdiff	include/mshadow-ps/ps_local-inl.h	/^    double diff = 0.0, ssum = 0.0, maxdiff = 0.0;$/;"	l	language:C++
maxidx	include/NNet.h	/^  int maxidx = 0;$/;"	l	language:C++
maxidx	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int maxidx = 0;$/;"	l	language:C++
maxidx	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  int maxidx = 0;$/;"	l	language:C++
maxidx	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int maxidx = 0;$/;"	l	language:C++
maximum	include/mshadow/base.h	/^struct maximum {$/;"	s	language:C++	namespace:mshadow::red
maxoftwo	thirdparty/mshadow/guide/defop.cpp	/^struct maxoftwo {$/;"	s	language:C++	file:
maxoftwo::Map	thirdparty/mshadow/guide/defop.cpp	/^  MSHADOW_XINLINE static float Map(float a, float b) {$/;"	f	language:C++	struct:maxoftwo	access:public	signature:(float a, float b)
memory	thirdparty/mshadow/guide/exp-template/README.md	/^* Expression Template and C++11: in C++11, move constructor can be used to save repetitive allocation memory, which removes some need to expression template. However, the space still needs to be allocated at least once. $/;"	v	language:C++
memsz	include/mshadow/tensor.h	/^    size_t memsz = this->stride_;$/;"	l	language:C++
minus	include/mshadow/base.h	/^struct minus {$/;"	s	language:C++	namespace:mshadow::op
minusto	include/mshadow/base.h	/^struct minusto {$/;"	s	language:C++	namespace:mshadow::sv
mirror	include/mshadow/extension/mirror.h	/^mirror(const Exp<SrcExp, DType, etype> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src)
mmax	include/mshadow/tensor_cpu-inl.h	/^  DType mmax = energy[0];$/;"	l	language:C++
ms_omp_uint	include/mshadow-ps/ps_local-inl.h	/^typedef int ms_omp_uint;$/;"	t	language:C++
ms_omp_uint	include/mshadow-ps/ps_local-inl.h	/^typedef unsigned ms_omp_uint;$/;"	t	language:C++
msg	include/mshadow/utils.h	/^    std::string msg(kPrintBuffer, '\\0');$/;"	p	language:C++	signature:(kPrintBuffer, Ã)
mshadow	include/mshadow-ps/mshadow_ps.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow-ps/ps_dist-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow-ps/ps_local-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow-ps/ps_rabit-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow-ps/thread.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow-ps/thread_util.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/base.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/cuda/reduce.cuh	/^namespace mshadow {$/;"	n	language:C++	file:
mshadow	include/mshadow/cuda/tensor_gpu-inl.cuh	/^namespace mshadow {$/;"	n	language:C++	file:
mshadow	include/mshadow/dot_engine-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/expr_engine-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/expr_scalar-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/expression.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/broadcast.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/channel_pool.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/channel_unpool.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/concat.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/crop.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/mirror.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/pack_col2patch.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/pad.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/reduceto1d.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/reshape.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/spatial_pool.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/spatial_unpool.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/swapaxis.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/extension/unpack_patch2col.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/io.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/random.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/sse-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/stream_gpu-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/tensor.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/tensor_blob.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/tensor_container.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/tensor_cpu-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/tensor_gpu-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	include/mshadow/utils.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	thirdparty/mshadow/guide/README.md	/^Tutorial of mshadow$/;"	v	language:C++
mshadow	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^namespace mshadow {$/;"	n	language:C++
mshadow	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^namespace mshadow {$/;"	n	language:C++	file:
mshadow::AllocHost	include/mshadow/tensor_cpu-inl.h	/^inline void AllocHost(Tensor<cpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
mshadow::AllocHost_	include/mshadow/tensor_cpu-inl.h	/^inline void *AllocHost_(size_t size);$/;"	p	language:C++	namespace:mshadow	signature:(size_t size)
mshadow::AllocHost_	include/mshadow/tensor_cpu-inl.h	/^inline void *AllocHost_<cpu>(size_t size) {$/;"	f	language:C++	namespace:mshadow	signature:(size_t size)
mshadow::AllocHost_	include/mshadow/tensor_cpu-inl.h	/^inline void *AllocHost_<gpu>(size_t size) {$/;"	f	language:C++	namespace:mshadow	signature:(size_t size)
mshadow::AllocSpace	include/mshadow/tensor.h	/^inline void AllocSpace(Tensor<cpu, dim, DType> *obj,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj, bool pad = MSHADOW_ALLOC_PAD)
mshadow::AllocSpace	include/mshadow/tensor.h	/^inline void AllocSpace(Tensor<gpu, dim, DType> *obj,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> *obj, bool pad = MSHADOW_ALLOC_PAD)
mshadow::AllocSpace	include/mshadow/tensor_cpu-inl.h	/^inline void AllocSpace(Tensor<cpu, dim, DType> *obj, bool pad) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj, bool pad)
mshadow::Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<cpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> dst, const Tensor<cpu, dim, DType> &src, Stream<cpu> *stream = NULL)
mshadow::Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<cpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream = NULL)
mshadow::Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<cpu, dim, DType> &src, Stream<gpu> *stream = NULL)
mshadow::Copy	include/mshadow/tensor.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream = NULL)
mshadow::Copy	include/mshadow/tensor_cpu-inl.h	/^inline void Copy(Tensor<cpu, dim, DType> _dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> _dst, const Tensor<cpu, dim, DType> &_src, Stream<cpu> *stream)
mshadow::Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<A, dim, DType> _dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<A, dim, DType> _dst, Tensor<B, dim, DType> _src, cudaMemcpyKind kind, Stream<gpu> *stream)
mshadow::Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<cpu, dim, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream)
mshadow::Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<cpu, dim, DType> &src, Stream<gpu> *stream)
mshadow::Copy	include/mshadow/tensor_gpu-inl.h	/^inline void Copy(Tensor<gpu, dim, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> dst, const Tensor<gpu, dim, DType> &src, Stream<gpu> *stream)
mshadow::Copy	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::Copy(tmp, ts);$/;"	p	language:C++	class:mshadow	signature:(tmp, ts)
mshadow::CreateBlasHandle	include/mshadow/stream_gpu-inl.h	/^    st->CreateBlasHandle();$/;"	p	language:C++	signature:()
mshadow::CreateDnnHandle	include/mshadow/stream_gpu-inl.h	/^    st->CreateDnnHandle();$/;"	p	language:C++	signature:()
mshadow::DataType	include/mshadow/tensor_blob.h	/^struct DataType;$/;"	x	language:C++
mshadow::DataType	include/mshadow/tensor_blob.h	/^struct DataType<double> {$/;"	s	language:C++	namespace:mshadow
mshadow::DataType	include/mshadow/tensor_blob.h	/^struct DataType<float> {$/;"	s	language:C++	namespace:mshadow
mshadow::DataType::kFlag	include/mshadow/tensor_blob.h	/^  static const int kFlag = 0;$/;"	m	language:C++	struct:mshadow::DataType	access:public
mshadow::DataType::kFlag	include/mshadow/tensor_blob.h	/^  static const int kFlag = 1;$/;"	m	language:C++	struct:mshadow::DataType	access:public
mshadow::DeleteStream	include/mshadow/stream_gpu-inl.h	/^inline void DeleteStream<gpu>(Stream<gpu> *stream) {$/;"	f	language:C++	namespace:mshadow	signature:(Stream<gpu> *stream)
mshadow::DeleteStream	include/mshadow/tensor.h	/^inline void DeleteStream(Stream<Device> *stream);$/;"	p	language:C++	namespace:mshadow	signature:(Stream<Device> *stream)
mshadow::DeleteStream	include/mshadow/tensor_cpu-inl.h	/^inline void DeleteStream<cpu>(Stream<cpu> *stream) {$/;"	f	language:C++	namespace:mshadow	signature:(Stream<cpu> *stream)
mshadow::DeleteStream	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  mshadow::DeleteStream(stream);$/;"	p	language:C++	class:mshadow	file:	signature:(stream)
mshadow::DeleteStream	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::DeleteStream(stream);$/;"	p	language:C++	class:mshadow	signature:(stream)
mshadow::DeleteStream	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::DeleteStream(stream);$/;"	p	language:C++	class:mshadow	signature:(stream)
mshadow::DestoryBlasHandle	include/mshadow/stream_gpu-inl.h	/^  stream->DestoryBlasHandle();$/;"	p	language:C++	signature:()
mshadow::DestroyDnnHandle	include/mshadow/stream_gpu-inl.h	/^  stream->DestroyDnnHandle();$/;"	p	language:C++	signature:()
mshadow::EShape	include/mshadow/tensor_cpu-inl.h	/^  typedef Shape<expr::ExpInfo<E>::kDim> EShape;$/;"	t	language:C++
mshadow::EShape	include/mshadow/tensor_gpu-inl.h	/^  typedef Shape<expr::ExpInfo<E>::kDim> EShape;$/;"	t	language:C++
mshadow::FlatTo2D	include/mshadow/tensor_gpu-inl.h	/^                       dshape.FlatTo2D(),$/;"	p	language:C++	signature:()
mshadow::FreeHost	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost(Tensor<cpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
mshadow::FreeHost_	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost_(void * dptr);$/;"	p	language:C++	namespace:mshadow	signature:(void * dptr)
mshadow::FreeHost_	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost_<cpu>(void *dptr) {$/;"	f	language:C++	namespace:mshadow	signature:(void *dptr)
mshadow::FreeHost_	include/mshadow/tensor_cpu-inl.h	/^inline void FreeHost_<gpu>(void *dptr) {$/;"	f	language:C++	namespace:mshadow	signature:(void *dptr)
mshadow::FreeSpace	include/mshadow/tensor.h	/^inline void FreeSpace(Tensor<cpu, dim, DType> *obj);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
mshadow::FreeSpace	include/mshadow/tensor.h	/^inline void FreeSpace(Tensor<gpu, dim, DType> *obj);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> *obj)
mshadow::FreeSpace	include/mshadow/tensor_cpu-inl.h	/^inline void FreeSpace(Tensor<cpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, dim, DType> *obj)
mshadow::FreeSpace	include/mshadow/tensor_gpu-inl.h	/^inline void FreeSpace(Tensor<gpu, dim, DType> *obj) {$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, dim, DType> *obj)
mshadow::InitTensorEngine	include/mshadow/tensor.h	/^inline void InitTensorEngine(int device_id = 0);$/;"	p	language:C++	namespace:mshadow	signature:(int device_id = 0)
mshadow::InitTensorEngine	include/mshadow/tensor_cpu-inl.h	/^inline void InitTensorEngine<cpu>(int dev_id) {$/;"	f	language:C++	namespace:mshadow	signature:(int dev_id)
mshadow::InitTensorEngine	include/mshadow/tensor_gpu-inl.h	/^inline void InitTensorEngine<gpu>(int dev_id) {$/;"	f	language:C++	namespace:mshadow	signature:(int dev_id)
mshadow::InitTensorEngine	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::InitTensorEngine<xpu>(devid);$/;"	p	language:C++	class:mshadow	signature:(devid)
mshadow::InitTensorEngine	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::InitTensorEngine<xpu>(devid);$/;"	p	language:C++	class:mshadow	signature:(devid)
mshadow::InitTensorEngine	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::InitTensorEngine<xpu>(devs[i]);$/;"	p	language:C++	class:mshadow	file:	signature:(devs[i])
mshadow::LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi,  \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst, bool pre_alloc)
mshadow::LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi, \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<cpu, dim, DType> *dst_, bool pre_alloc)
mshadow::LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi, \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<gpu, dim, DType> *dst, bool pre_alloc)
mshadow::LoadBinary	include/mshadow/io.h	/^inline void LoadBinary(TStream &fi, \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fi, Tensor<gpu, dim, DType> *dst, bool pre_alloc)
mshadow::MapExp	include/mshadow/tensor.h	/^inline void MapExp(TRValue<R, cpu, dim, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
mshadow::MapExp	include/mshadow/tensor.h	/^inline void MapExp(TRValue<R, gpu, dim, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
mshadow::MapExp	include/mshadow/tensor_cpu-inl.h	/^inline void MapExp(TRValue<R, cpu, dim, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
mshadow::MapExp	include/mshadow/tensor_gpu-inl.h	/^inline void MapExp(TRValue<R, gpu, dim, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
mshadow::MapExpCPUEngine	include/mshadow/tensor_cpu-inl.h	/^struct MapExpCPUEngine {$/;"	s	language:C++	namespace:mshadow
mshadow::MapExpCPUEngine	include/mshadow/tensor_cpu-inl.h	/^struct MapExpCPUEngine<true, SV, Tensor<cpu, dim, DType>,$/;"	s	language:C++	namespace:mshadow
mshadow::MapExpCPUEngine::Map	include/mshadow/tensor_cpu-inl.h	/^  MapExpCPUEngine<false, Saver, R, dim, DType, E, etype>::Map(dst, exp);$/;"	p	language:C++	class:mshadow::MapExpCPUEngine	signature:(dst, exp)
mshadow::MapExpCPUEngine::Map	include/mshadow/tensor_cpu-inl.h	/^  inline static void Map(TRValue<R, cpu, dim, DType> *dst,$/;"	f	language:C++	struct:mshadow::MapExpCPUEngine	access:public	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
mshadow::MapExpCPUEngine::Map	include/mshadow/tensor_cpu-inl.h	/^  inline static void Map(Tensor<cpu, dim, DType> *dst,$/;"	f	language:C++	struct:mshadow::MapExpCPUEngine	access:public	signature:(Tensor<cpu, dim, DType> *dst, const expr::Exp<E, DType, etype> &exp)
mshadow::MapPlan	include/mshadow/tensor_cpu-inl.h	/^inline void MapPlan(TRValue<R, cpu, dim, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, dim, DType> *dst, const expr::Plan<E, DType> &plan)
mshadow::MapReduceKeepHighDim	include/mshadow/tensor.h	/^inline void MapReduceKeepHighDim(TRValue<R, cpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
mshadow::MapReduceKeepHighDim	include/mshadow/tensor.h	/^inline void MapReduceKeepHighDim(TRValue<R, gpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
mshadow::MapReduceKeepHighDim	include/mshadow/tensor_cpu-inl.h	/^inline void MapReduceKeepHighDim(TRValue<R, cpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
mshadow::MapReduceKeepHighDim	include/mshadow/tensor_gpu-inl.h	/^inline void MapReduceKeepHighDim(TRValue<R, gpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
mshadow::MapReduceKeepLowest	include/mshadow/tensor.h	/^inline void MapReduceKeepLowest(TRValue<R, cpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
mshadow::MapReduceKeepLowest	include/mshadow/tensor.h	/^inline void MapReduceKeepLowest(TRValue<R, gpu, 1, DType> *dst,$/;"	p	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale = 1)
mshadow::MapReduceKeepLowest	include/mshadow/tensor_cpu-inl.h	/^inline void MapReduceKeepLowest(TRValue<R, cpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, cpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
mshadow::MapReduceKeepLowest	include/mshadow/tensor_gpu-inl.h	/^inline void MapReduceKeepLowest(TRValue<R, gpu, 1, DType> *dst,$/;"	f	language:C++	namespace:mshadow	signature:(TRValue<R, gpu, 1, DType> *dst, const expr::Exp<E, DType, etype> &exp, DType scale)
mshadow::NewStream	include/mshadow/stream_gpu-inl.h	/^inline Stream<gpu> *NewStream<gpu>(bool create_blas_handle,$/;"	f	language:C++	namespace:mshadow	signature:(bool create_blas_handle, bool create_dnn_handle)
mshadow::NewStream	include/mshadow/tensor.h	/^inline Stream<Device> *NewStream() {$/;"	f	language:C++	namespace:mshadow	signature:()
mshadow::NewStream	include/mshadow/tensor.h	/^inline Stream<Device> *NewStream(bool create_blas_handle,$/;"	p	language:C++	namespace:mshadow	signature:(bool create_blas_handle, bool create_dnn_handle)
mshadow::NewStream	include/mshadow/tensor_cpu-inl.h	/^inline Stream<cpu> *NewStream<cpu>(bool create_blas_handle,$/;"	f	language:C++	namespace:mshadow	signature:(bool create_blas_handle, bool create_dnn_handle)
mshadow::NewTensor	include/mshadow/tensor.h	/^inline Tensor<Device, dim, DType> NewTensor(const Shape<dim> &shape,$/;"	p	language:C++	namespace:mshadow	signature:(const Shape<dim> &shape, DType initv, bool pad = MSHADOW_ALLOC_PAD, Stream<Device> *stream = NULL)
mshadow::NewTensor	include/mshadow/tensor_cpu-inl.h	/^NewTensor(const Shape<dim> &shape, DType initv, bool pad, Stream<Device> *stream_) {$/;"	f	language:C++	namespace:mshadow	signature:(const Shape<dim> &shape, DType initv, bool pad, Stream<Device> *stream_)
mshadow::Random	include/mshadow/random.h	/^class Random {};$/;"	c	language:C++	namespace:mshadow
mshadow::Random	include/mshadow/random.h	/^class Random<cpu, DType> {$/;"	c	language:C++	namespace:mshadow
mshadow::Random	include/mshadow/random.h	/^class Random<gpu, DType> {$/;"	c	language:C++	namespace:mshadow
mshadow::Random::GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(double *dptr, index_t size, double mu, double sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, index_t size, double mu, double sigma)
mshadow::Random::GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(double *dptr, size_t size, double mu, double sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, size_t size, double mu, double sigma)
mshadow::Random::GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(float *dptr, index_t size, float mu, float sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, index_t size, float mu, float sigma)
mshadow::Random::GenGaussian	include/mshadow/random.h	/^  inline void GenGaussian(float *dptr, size_t size, float mu, float sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, size_t size, float mu, float sigma)
mshadow::Random::GenGaussianX	include/mshadow/random.h	/^  inline void GenGaussianX(DType *dptr, index_t size, DType mu, DType sigma) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(DType *dptr, index_t size, DType mu, DType sigma)
mshadow::Random::GenUniform	include/mshadow/random.h	/^  inline void GenUniform(double *dptr, index_t size, double a, double b) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, index_t size, double a, double b)
mshadow::Random::GenUniform	include/mshadow/random.h	/^  inline void GenUniform(double *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(double *dptr, size_t size)
mshadow::Random::GenUniform	include/mshadow/random.h	/^  inline void GenUniform(float *dptr, index_t size, float a, float b) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, index_t size, float a, float b)
mshadow::Random::GenUniform	include/mshadow/random.h	/^  inline void GenUniform(float *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(float *dptr, size_t size)
mshadow::Random::RandNext	include/mshadow/random.h	/^  inline DType RandNext(void) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(void)
mshadow::Random::RandNext2	include/mshadow/random.h	/^  inline DType RandNext2(void) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(void)
mshadow::Random::Random	include/mshadow/random.h	/^  explicit Random(int seed) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(int seed)
mshadow::Random::SampleGaussian	include/mshadow/random.h	/^  inline void SampleGaussian(Tensor<cpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<cpu, dim, DType> *dst, DType mu = 0.0f, DType sigma = 1.0f)
mshadow::Random::SampleGaussian	include/mshadow/random.h	/^  inline void SampleGaussian(Tensor<gpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<gpu, dim, DType> *dst, DType mu = 0.0f, DType sigma = 1.0f)
mshadow::Random::SampleNormal2D	include/mshadow/random.h	/^  inline void SampleNormal2D(DType *xx_, DType *yy_) {$/;"	f	language:C++	class:mshadow::Random	access:private	signature:(DType *xx_, DType *yy_)
mshadow::Random::SampleUniform	include/mshadow/random.h	/^  inline void SampleUniform(Tensor<cpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<cpu, dim, DType> *dst, DType a = 0.0f, DType b = 1.0f)
mshadow::Random::SampleUniform	include/mshadow/random.h	/^  inline void SampleUniform(Tensor<gpu, dim, DType> *dst,$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Tensor<gpu, dim, DType> *dst, DType a = 0.0f, DType b = 1.0f)
mshadow::Random::Seed	include/mshadow/random.h	/^  inline void Seed(int seed) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(int seed)
mshadow::Random::Shape1	include/mshadow/random.h	/^    buffer_.Resize(Shape1(aligned_sz));$/;"	p	language:C++	signature:(aligned_sz)
mshadow::Random::Shape1	include/mshadow/random.h	/^    buffer_.Resize(Shape1(kRandBufferSize));$/;"	p	language:C++	signature:(kRandBufferSize)
mshadow::Random::Shape1	include/mshadow/random.h	/^    buffer_.Resize(Shape1(shape.Size()));$/;"	p	language:C++	signature:(shape.Size())
mshadow::Random::aligned_sz	include/mshadow/random.h	/^    size_t aligned_sz = ((shape.Size() + 1UL) >> 1) << 1;$/;"	l	language:C++
mshadow::Random::buffer_	include/mshadow/random.h	/^  TensorContainer<cpu, 1, DType> buffer_;$/;"	m	language:C++	class:mshadow::Random	access:private
mshadow::Random::buffer_	include/mshadow/random.h	/^  TensorContainer<gpu, 1, DType> buffer_;$/;"	m	language:C++	class:mshadow::Random	access:private
mshadow::Random::g1	include/mshadow/random.h	/^    DType g1 = 0.0f, g2 = 0.0f;$/;"	l	language:C++
mshadow::Random::g2	include/mshadow/random.h	/^    DType g1 = 0.0f, g2 = 0.0f;$/;"	l	language:C++
mshadow::Random::gaussian	include/mshadow/random.h	/^  gaussian(Shape<dim> shape) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Shape<dim> shape)
mshadow::Random::gaussian	include/mshadow/random.h	/^  gaussian(Shape<dim> shape, DType mu = 0.0f, DType sigma = 1.0f) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Shape<dim> shape, DType mu = 0.0f, DType sigma = 1.0f)
mshadow::Random::gen_	include/mshadow/random.h	/^  curandGenerator_t gen_;$/;"	m	language:C++	class:mshadow::Random	access:private
mshadow::Random::mat	include/mshadow/random.h	/^    Tensor<cpu, 2, DType> mat = dst->FlatTo2D();$/;"	l	language:C++
mshadow::Random::rseed_	include/mshadow/random.h	/^  unsigned rseed_;$/;"	m	language:C++	class:mshadow::Random	access:private
mshadow::Random::s	include/mshadow/random.h	/^    DType x, y, s;$/;"	l	language:C++
mshadow::Random::set_stream	include/mshadow/random.h	/^  inline void set_stream(Stream<cpu> *stream) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Stream<cpu> *stream)
mshadow::Random::set_stream	include/mshadow/random.h	/^  inline void set_stream(Stream<gpu> *stream) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Stream<gpu> *stream)
mshadow::Random::status	include/mshadow/random.h	/^    curandStatus_t status;$/;"	l	language:C++
mshadow::Random::status	include/mshadow/random.h	/^    int status = vdRngGaussian(0, vStream_, size, dptr, mu, sigma);$/;"	l	language:C++
mshadow::Random::status	include/mshadow/random.h	/^    int status = vdRngUniform(0, vStream_, size, dptr, a, b);$/;"	l	language:C++
mshadow::Random::status	include/mshadow/random.h	/^    int status = vsRngGaussian(0, vStream_, size, dptr, mu, sigma);$/;"	l	language:C++
mshadow::Random::status	include/mshadow/random.h	/^    int status = vsRngUniform(0, vStream_, size, dptr, a, b);$/;"	l	language:C++
mshadow::Random::status	include/mshadow/random.h	/^    int status = vslNewStream(&vStream_, VSL_BRNG_MT19937, seed);$/;"	l	language:C++
mshadow::Random::t	include/mshadow/random.h	/^    DType t = std::sqrt(-2.0f * std::log(s) \/ s);$/;"	l	language:C++
mshadow::Random::uniform	include/mshadow/random.h	/^  uniform(Shape<dim> shape) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Shape<dim> shape)
mshadow::Random::utils::Check	include/mshadow/random.h	/^    utils::Check(status == CURAND_STATUS_SUCCESS, "CURAND Gen Uniform failed");$/;"	p	language:C++	class:mshadow::Random::utils	signature:(status == CURAND_STATUS_SUCCESS, Ó)
mshadow::Random::utils::Check	include/mshadow/random.h	/^    utils::Check(status == CURAND_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::Random::utils	signature:(status == CURAND_STATUS_SUCCESS, Ó)
mshadow::Random::utils::Check	include/mshadow/random.h	/^    utils::Check(status == VSL_STATUS_OK,$/;"	p	language:C++	class:mshadow::Random::utils	signature:(status == VSL_STATUS_OK, Ó)
mshadow::Random::vStream_	include/mshadow/random.h	/^  VSLStreamStatePtr vStream_;$/;"	m	language:C++	class:mshadow::Random	access:private
mshadow::Random::x	include/mshadow/random.h	/^    DType x, y, s;$/;"	l	language:C++
mshadow::Random::xx	include/mshadow/random.h	/^    DType &xx = *xx_, &yy = *yy_;$/;"	l	language:C++
mshadow::Random::y	include/mshadow/random.h	/^    DType x, y, s;$/;"	l	language:C++
mshadow::Random::yy	include/mshadow/random.h	/^    DType &xx = *xx_, &yy = *yy_;$/;"	l	language:C++
mshadow::Random::~Random	include/mshadow/random.h	/^  ~Random(void) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(void)
mshadow::Reducer::Reduce	include/mshadow/tensor_cpu-inl.h	/^          Reducer::Reduce(tres,$/;"	p	language:C++	class:mshadow::Reducer	signature:(tres, splan.Eval((n * pshape[1] + c) * pshape[2] + y, x))
mshadow::Reducer::Reduce	include/mshadow/tensor_cpu-inl.h	/^      Reducer::Reduce(res, splan.Eval(y, x));$/;"	p	language:C++	class:mshadow::Reducer	signature:(res, splan.Eval(y, x))
mshadow::Reducer::Reduce	include/mshadow/tensor_cpu-inl.h	/^      Reducer::Reduce(res, tres);$/;"	p	language:C++	class:mshadow::Reducer	signature:(res, tres)
mshadow::Reducer::SetInitValue	include/mshadow/tensor_cpu-inl.h	/^      DType tres; Reducer::SetInitValue(tres);$/;"	p	language:C++	class:mshadow::Reducer	signature:(tres)
mshadow::Reducer::SetInitValue	include/mshadow/tensor_cpu-inl.h	/^    DType res; Reducer::SetInitValue(res);$/;"	p	language:C++	class:mshadow::Reducer	signature:(res)
mshadow::SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src);  \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src)
mshadow::SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<cpu, dim, DType> &src_) { \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<cpu, dim, DType> &src_)
mshadow::SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src) { \/\/ NOLINT(*)$/;"	f	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)
mshadow::SaveBinary	include/mshadow/io.h	/^inline void SaveBinary(TStream &fo, const Tensor<gpu, dim, DType> &src); \/\/ NOLINT(*)$/;"	p	language:C++	namespace:mshadow	signature:(TStream &fo, const Tensor<gpu, dim, DType> &src)
mshadow::Saver::Save	include/mshadow/tensor_cpu-inl.h	/^      Saver::Save(dplan.REval(y, x), plan.Eval(y, x));$/;"	p	language:C++	class:mshadow::Saver	signature:(dplan.REval(y, x), plan.Eval(y, x))
mshadow::Saver::Save	include/mshadow/tensor_cpu-inl.h	/^    Saver::Save(dplan.REval(0, c), res * scale);$/;"	p	language:C++	class:mshadow::Saver	signature:(dplan.REval(0, c), res * scale)
mshadow::Saver::Save	include/mshadow/tensor_cpu-inl.h	/^    Saver::Save(dplan.REval(0, x), res * scale);$/;"	p	language:C++	class:mshadow::Saver	signature:(dplan.REval(0, x), res * scale)
mshadow::SetDevice	include/mshadow/tensor.h	/^inline void SetDevice(int devid);$/;"	p	language:C++	namespace:mshadow	signature:(int devid)
mshadow::SetDevice	include/mshadow/tensor_cpu-inl.h	/^inline void SetDevice<cpu>(int devid) {$/;"	f	language:C++	namespace:mshadow	signature:(int devid)
mshadow::SetDevice	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      mshadow::SetDevice<xpu>(devs[tid]);$/;"	p	language:C++	class:mshadow	file:	signature:(devs[tid])
mshadow::SetDevice	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::SetDevice<xpu>(devs[i]);$/;"	p	language:C++	class:mshadow	file:	signature:(devs[i])
mshadow::Shape	include/mshadow/tensor.h	/^struct Shape {$/;"	s	language:C++	namespace:mshadow
mshadow::Shape1	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<1> Shape1(index_t s0) {$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0)
mshadow::Shape2	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<2> Shape2(index_t s0, index_t s1) {$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0, index_t s1)
mshadow::Shape3	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<3> Shape3(index_t s0, index_t s1, index_t s2) {$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0, index_t s1, index_t s2)
mshadow::Shape4	include/mshadow/tensor.h	/^MSHADOW_XINLINE Shape<4> Shape4(index_t s0, index_t s1,$/;"	f	language:C++	namespace:mshadow	signature:(index_t s0, index_t s1, index_t s2, index_t s3)
mshadow::Shape::FlatTo2D	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape<2> FlatTo2D(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
mshadow::Shape::ProdShape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t ProdShape(int dimstart, int dimend) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(int dimstart, int dimend) const
mshadow::Shape::Shape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape(const Shape<kDimension> &s) {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(const Shape<kDimension> &s)
mshadow::Shape::Shape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape(void) {}$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void)
mshadow::Shape::Size	include/mshadow/tensor.h	/^  MSHADOW_XINLINE size_t Size(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
mshadow::Shape::Slice	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape<dimend - dimstart> Slice(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
mshadow::Shape::SubShape	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Shape<kSubdim> SubShape(void) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(void) const
mshadow::Shape::kDimension	include/mshadow/tensor.h	/^  static const int kDimension = dimension;$/;"	m	language:C++	struct:mshadow::Shape	access:public
mshadow::Shape::kSubdim	include/mshadow/tensor.h	/^  static const int kSubdim = dimension - 1;$/;"	m	language:C++	struct:mshadow::Shape	access:public
mshadow::Shape::num	include/mshadow/tensor.h	/^    index_t num = 1;$/;"	l	language:C++
mshadow::Shape::operator !=	include/mshadow/tensor.h	/^  MSHADOW_XINLINE bool operator!=(const Shape<kDimension> &s) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(const Shape<kDimension> &s) const
mshadow::Shape::operator ==	include/mshadow/tensor.h	/^  MSHADOW_XINLINE bool operator==(const Shape<kDimension> &s) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(const Shape<kDimension> &s) const
mshadow::Shape::operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE const index_t &operator[](index_t idx) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(index_t idx) const
mshadow::Shape::operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t &operator[](index_t idx) {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(index_t idx)
mshadow::Shape::s	include/mshadow/tensor.h	/^    Shape<2> s;$/;"	l	language:C++
mshadow::Shape::s	include/mshadow/tensor.h	/^    Shape<dimend - dimstart> s;$/;"	l	language:C++
mshadow::Shape::s	include/mshadow/tensor.h	/^    Shape<kSubdim> s;$/;"	l	language:C++
mshadow::Shape::shape_	include/mshadow/tensor.h	/^  index_t shape_[kDimension];$/;"	m	language:C++	struct:mshadow::Shape	access:public
mshadow::Shape::size	include/mshadow/tensor.h	/^    size_t size = this->shape_[0];$/;"	l	language:C++
mshadow::Shape::ymax	include/mshadow/tensor.h	/^    index_t ymax = 1;$/;"	l	language:C++
mshadow::ShutdownTensorEngine	include/mshadow/tensor.h	/^inline void ShutdownTensorEngine(void);$/;"	p	language:C++	namespace:mshadow	signature:(void)
mshadow::ShutdownTensorEngine	include/mshadow/tensor_cpu-inl.h	/^inline void ShutdownTensorEngine<cpu>(void) {$/;"	f	language:C++	namespace:mshadow	signature:(void)
mshadow::ShutdownTensorEngine	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  mshadow::ShutdownTensorEngine<xpu>();$/;"	p	language:C++	class:mshadow	file:	signature:()
mshadow::ShutdownTensorEngine	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::ShutdownTensorEngine<xpu>();$/;"	p	language:C++	class:mshadow	signature:()
mshadow::ShutdownTensorEngine	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::ShutdownTensorEngine<xpu>();$/;"	p	language:C++	class:mshadow	signature:()
mshadow::Softmax	include/mshadow/tensor.h	/^inline void Softmax(Tensor<cpu, 2, DType> dst, const Tensor<cpu, 2, DType> &energy);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<cpu, 2, DType> dst, const Tensor<cpu, 2, DType> &energy)
mshadow::Softmax	include/mshadow/tensor.h	/^inline void Softmax(Tensor<gpu, 2, DType> dst, const Tensor<gpu, 2, DType> &energy);$/;"	p	language:C++	namespace:mshadow	signature:(Tensor<gpu, 2, DType> dst, const Tensor<gpu, 2, DType> &energy)
mshadow::Softmax	include/mshadow/tensor_cpu-inl.h	/^inline void Softmax(Tensor<cpu, 1, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, 1, DType> dst, const Tensor<cpu, 1, DType> &energy)
mshadow::Softmax	include/mshadow/tensor_cpu-inl.h	/^inline void Softmax(Tensor<cpu, 2, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<cpu, 2, DType> dst, const Tensor<cpu, 2, DType> &energy)
mshadow::Softmax	include/mshadow/tensor_gpu-inl.h	/^inline void Softmax(Tensor<gpu, 2, DType> dst,$/;"	f	language:C++	namespace:mshadow	signature:(Tensor<gpu, 2, DType> dst, const Tensor<gpu, 2, DType>& src)
mshadow::Stream	include/mshadow/stream_gpu-inl.h	/^struct Stream<gpu> {$/;"	s	language:C++	namespace:mshadow
mshadow::Stream	include/mshadow/tensor.h	/^struct Stream {$/;"	s	language:C++	namespace:mshadow
mshadow::Stream::CheckIdle	include/mshadow/stream_gpu-inl.h	/^  inline bool CheckIdle(void) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
mshadow::Stream::CheckIdle	include/mshadow/tensor.h	/^  inline bool CheckIdle(void) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
mshadow::Stream::CreateBlasHandle	include/mshadow/stream_gpu-inl.h	/^  inline void CreateBlasHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
mshadow::Stream::CreateBlasHandle	include/mshadow/tensor.h	/^  inline void CreateBlasHandle() {}$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
mshadow::Stream::CreateDnnHandle	include/mshadow/stream_gpu-inl.h	/^  inline void CreateDnnHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
mshadow::Stream::DestoryBlasHandle	include/mshadow/stream_gpu-inl.h	/^  inline void DestoryBlasHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
mshadow::Stream::DestroyDnnHandle	include/mshadow/stream_gpu-inl.h	/^  inline void DestroyDnnHandle() {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:()
mshadow::Stream::GetBlasHandle	include/mshadow/stream_gpu-inl.h	/^  inline static cublasHandle_t GetBlasHandle(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(Stream<gpu> *stream)
mshadow::Stream::GetDnnHandle	include/mshadow/stream_gpu-inl.h	/^  inline static cudnnHandle_t GetDnnHandle(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(Stream<gpu> *stream)
mshadow::Stream::GetStream	include/mshadow/stream_gpu-inl.h	/^  inline static cudaStream_t GetStream(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(Stream<gpu> *stream)
mshadow::Stream::HandleState	include/mshadow/stream_gpu-inl.h	/^  enum HandleState {$/;"	g	language:C++	struct:mshadow::Stream	access:public
mshadow::Stream::NoHandle	include/mshadow/stream_gpu-inl.h	/^    NoHandle = 0,$/;"	e	language:C++	enum:mshadow::Stream::HandleState
mshadow::Stream::OwnHandle	include/mshadow/stream_gpu-inl.h	/^    OwnHandle = 1,$/;"	e	language:C++	enum:mshadow::Stream::HandleState
mshadow::Stream::Stream	include/mshadow/stream_gpu-inl.h	/^  Stream(void) : stream_(0),$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
mshadow::Stream::Wait	include/mshadow/stream_gpu-inl.h	/^  inline void Wait(void) {$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
mshadow::Stream::Wait	include/mshadow/tensor.h	/^  inline void Wait(void) {}$/;"	f	language:C++	struct:mshadow::Stream	access:public	signature:(void)
mshadow::Stream::blas_handle_	include/mshadow/stream_gpu-inl.h	/^  cublasHandle_t blas_handle_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
mshadow::Stream::blas_handle_ownership_	include/mshadow/stream_gpu-inl.h	/^  HandleState blas_handle_ownership_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
mshadow::Stream::dnn_handle_	include/mshadow/stream_gpu-inl.h	/^  cudnnHandle_t dnn_handle_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
mshadow::Stream::dnn_handle_ownership_	include/mshadow/stream_gpu-inl.h	/^  HandleState dnn_handle_ownership_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
mshadow::Stream::err	include/mshadow/stream_gpu-inl.h	/^      cublasStatus_t err = cublasDestroy(blas_handle_);$/;"	l	language:C++
mshadow::Stream::err	include/mshadow/stream_gpu-inl.h	/^      cudnnStatus_t err = cudnnDestroy(dnn_handle_);$/;"	l	language:C++
mshadow::Stream::err	include/mshadow/stream_gpu-inl.h	/^    cublasStatus_t err = cublasCreate(&blas_handle_);$/;"	l	language:C++
mshadow::Stream::err	include/mshadow/stream_gpu-inl.h	/^    cudaError_t err = cudaStreamQuery(stream_);$/;"	l	language:C++
mshadow::Stream::err	include/mshadow/stream_gpu-inl.h	/^    cudaError_t err = cudaStreamSynchronize(stream_);$/;"	l	language:C++
mshadow::Stream::err	include/mshadow/stream_gpu-inl.h	/^    cudnnStatus_t err = cudnnCreate(&dnn_handle_);$/;"	l	language:C++
mshadow::Stream::stream_	include/mshadow/stream_gpu-inl.h	/^  cudaStream_t stream_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
mshadow::Stream::utils::Check	include/mshadow/stream_gpu-inl.h	/^      utils::Check(err == CUBLAS_STATUS_SUCCESS, "Destory cublas handle failed");$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::Stream::utils::Check	include/mshadow/stream_gpu-inl.h	/^      utils::Check(err == CUDNN_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUDNN_STATUS_SUCCESS, Ó)
mshadow::Stream::utils::Check	include/mshadow/stream_gpu-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "Create cublas handle failed");$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::Stream::utils::Check	include/mshadow/stream_gpu-inl.h	/^    utils::Check(err == CUDNN_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == CUDNN_STATUS_SUCCESS, Ó)
mshadow::Stream::utils::Check	include/mshadow/stream_gpu-inl.h	/^    utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::Stream::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
mshadow::TBlob	include/mshadow/tensor_blob.h	/^class TBlob {$/;"	c	language:C++	namespace:mshadow
mshadow::TBlob::CheckContiguous	include/mshadow/tensor_blob.h	/^  inline bool CheckContiguous(void) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(void) const
mshadow::TBlob::FlatTo2D	include/mshadow/tensor_blob.h	/^  inline Tensor<Device, 2, DType> FlatTo2D(Stream<Device> *stream = NULL) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(Stream<Device> *stream = NULL) const
mshadow::TBlob::TBlob	include/mshadow/tensor_blob.h	/^  TBlob(DType *dptr,$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(DType *dptr, const TShape &shape, int dev_mask)
mshadow::TBlob::TBlob	include/mshadow/tensor_blob.h	/^  TBlob(const Tensor<Device, dim, DType> &src) {  \/\/ NOLINT(*)$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(const Tensor<Device, dim, DType> &src)
mshadow::TBlob::TBlob	include/mshadow/tensor_blob.h	/^  TBlob(void)$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(void)
mshadow::TBlob::dev_mask_	include/mshadow/tensor_blob.h	/^  int dev_mask_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
mshadow::TBlob::dptr_	include/mshadow/tensor_blob.h	/^  void *dptr_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
mshadow::TBlob::get	include/mshadow/tensor_blob.h	/^  inline Tensor<Device, dim, DType> get(Stream<Device> *stream = NULL) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(Stream<Device> *stream = NULL) const
mshadow::TBlob::get_with_shape	include/mshadow/tensor_blob.h	/^  inline Tensor<Device, dim, DType> get_with_shape(const TShape &shape,$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(const TShape &shape, Stream<Device> *stream = NULL) const
mshadow::TBlob::ndim	include/mshadow/tensor_blob.h	/^  inline int ndim(void) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(void) const
mshadow::TBlob::operator =	include/mshadow/tensor_blob.h	/^  &operator=(const Tensor<Device, dim, DType> &src) {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(const Tensor<Device, dim, DType> &src)
mshadow::TBlob::shape_	include/mshadow/tensor_blob.h	/^  TShape shape_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
mshadow::TBlob::size	include/mshadow/tensor_blob.h	/^  inline index_t size(index_t idx) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(index_t idx) const
mshadow::TBlob::stride_	include/mshadow/tensor_blob.h	/^  index_t stride_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
mshadow::TBlob::type_flag_	include/mshadow/tensor_blob.h	/^  int type_flag_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
mshadow::TBlob::utils::Check	include/mshadow/tensor_blob.h	/^    utils::Check(Device::kDevMask == dev_mask_ && DataType<DType>::kFlag == type_flag_,$/;"	p	language:C++	class:mshadow::TBlob::utils	signature:(Device::kDevMask == dev_mask_ && DataType<DType>::kFlag == type_flag_, Ó)
mshadow::TBlob::utils::Check	include/mshadow/tensor_blob.h	/^    utils::Check(this->CheckContiguous(), "TBlob.get_reshape: must be contiguous");$/;"	p	language:C++	class:mshadow::TBlob::utils	signature:(this->CheckContiguous(), Ó)
mshadow::TBlob::utils::Check	include/mshadow/tensor_blob.h	/^    utils::Check(this->shape_.Size() == shape.Size(),$/;"	p	language:C++	class:mshadow::TBlob::utils	signature:(this->shape_.Size() == shape.Size(), Ó)
mshadow::TRValue	include/mshadow/tensor.h	/^struct TRValue: public expr::RValueExp<Container, DType> {$/;"	s	language:C++	namespace:mshadow	inherits:expr::RValueExp
mshadow::TShape	include/mshadow/tensor_blob.h	/^struct TShape {$/;"	s	language:C++	namespace:mshadow
mshadow::TShape::CopyFrom	include/mshadow/tensor_blob.h	/^  inline void CopyFrom(RandomAccessIterator begin,$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(RandomAccessIterator begin, RandomAccessIterator end)
mshadow::TShape::FlatTo2D	include/mshadow/tensor_blob.h	/^  inline Shape<2> FlatTo2D(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
mshadow::TShape::SetDim	include/mshadow/tensor_blob.h	/^  inline void SetDim(index_t dim) {$/;"	f	language:C++	struct:mshadow::TShape	access:private	signature:(index_t dim)
mshadow::TShape::Size	include/mshadow/tensor_blob.h	/^  inline size_t Size(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
mshadow::TShape::TShape	include/mshadow/tensor_blob.h	/^  TShape()$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:()
mshadow::TShape::TShape	include/mshadow/tensor_blob.h	/^  TShape(RandomAccessIterator begin,$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(RandomAccessIterator begin, RandomAccessIterator end)
mshadow::TShape::TShape	include/mshadow/tensor_blob.h	/^  TShape(TShape &&s)$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(TShape &&s)
mshadow::TShape::TShape	include/mshadow/tensor_blob.h	/^  TShape(const TShape &s)$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &s)
mshadow::TShape::d	include/mshadow/tensor_blob.h	/^    const index_t *d = dim <= kStackCache ? data_stack_ : data_heap_;$/;"	l	language:C++
mshadow::TShape::d	include/mshadow/tensor_blob.h	/^    const index_t *d = this->data();$/;"	l	language:C++
mshadow::TShape::d	include/mshadow/tensor_blob.h	/^    index_t *d = dim <= kStackCache ? data_stack_ : data_heap_;$/;"	l	language:C++
mshadow::TShape::data	include/mshadow/tensor_blob.h	/^  inline const index_t *data() const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:() const
mshadow::TShape::data	include/mshadow/tensor_blob.h	/^  inline index_t *data() {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:()
mshadow::TShape::data_heap_	include/mshadow/tensor_blob.h	/^  index_t *data_heap_;$/;"	m	language:C++	struct:mshadow::TShape	access:private
mshadow::TShape::data_stack_	include/mshadow/tensor_blob.h	/^  index_t data_stack_[kStackCache];$/;"	m	language:C++	struct:mshadow::TShape	access:private
mshadow::TShape::get	include/mshadow/tensor_blob.h	/^  inline Shape<dim> get(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
mshadow::TShape::kStackCache	include/mshadow/tensor_blob.h	/^  static const index_t kStackCache = 4;$/;"	m	language:C++	struct:mshadow::TShape	access:private
mshadow::TShape::ndim	include/mshadow/tensor_blob.h	/^  inline index_t ndim(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
mshadow::TShape::ndim_	include/mshadow/tensor_blob.h	/^  index_t ndim_;$/;"	m	language:C++	struct:mshadow::TShape	access:private
mshadow::TShape::num_heap_allocated_	include/mshadow/tensor_blob.h	/^  index_t num_heap_allocated_;$/;"	m	language:C++	struct:mshadow::TShape	access:private
mshadow::TShape::operator !=	include/mshadow/tensor_blob.h	/^  inline bool operator!=(const Shape<dim> &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const Shape<dim> &s) const
mshadow::TShape::operator !=	include/mshadow/tensor_blob.h	/^  inline bool operator!=(const TShape &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &s) const
mshadow::TShape::operator =	include/mshadow/tensor_blob.h	/^  inline TShape &operator=(const Shape<dim> &shape) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const Shape<dim> &shape)
mshadow::TShape::operator =	include/mshadow/tensor_blob.h	/^  inline TShape &operator=(const TShape &shape) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &shape)
mshadow::TShape::operator =	include/mshadow/tensor_blob.h	/^  inline TShape &operator=(const std::vector<index_t> &shape) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const std::vector<index_t> &shape)
mshadow::TShape::operator ==	include/mshadow/tensor_blob.h	/^  inline bool operator==(const Shape<dim> &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const Shape<dim> &s) const
mshadow::TShape::operator ==	include/mshadow/tensor_blob.h	/^  inline bool operator==(const TShape &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &s) const
mshadow::TShape::operator []	include/mshadow/tensor_blob.h	/^  inline const index_t &operator[](index_t i) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(index_t i) const
mshadow::TShape::operator []	include/mshadow/tensor_blob.h	/^  inline index_t &operator[](index_t i) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(index_t i)
mshadow::TShape::s	include/mshadow/tensor_blob.h	/^    Shape<2> s;$/;"	l	language:C++
mshadow::TShape::s	include/mshadow/tensor_blob.h	/^    Shape<dim> s;$/;"	l	language:C++
mshadow::TShape::size	include/mshadow/tensor_blob.h	/^    size_t size = 1;$/;"	l	language:C++
mshadow::TShape::src	include/mshadow/tensor_blob.h	/^    const index_t *src = shape.data();$/;"	l	language:C++
mshadow::TShape::std::copy	include/mshadow/tensor_blob.h	/^      std::copy(s.data_heap_, s.data_heap_ + ndim_, data_heap_);$/;"	p	language:C++	class:mshadow::TShape::std	signature:(s.data_heap_, s.data_heap_ + ndim_, data_heap_)
mshadow::TShape::std::copy	include/mshadow/tensor_blob.h	/^      std::copy(s.data_stack_, s.data_stack_ + ndim_, data_stack_);$/;"	p	language:C++	class:mshadow::TShape::std	signature:(s.data_stack_, s.data_stack_ + ndim_, data_stack_)
mshadow::TShape::std::copy	include/mshadow/tensor_blob.h	/^    std::copy(begin, end, data());$/;"	p	language:C++	class:mshadow::TShape::std	signature:(begin, end, data())
mshadow::TShape::std::copy	include/mshadow/tensor_blob.h	/^    std::copy(src, src + ndim_, data());$/;"	p	language:C++	class:mshadow::TShape::std	signature:(src, src + ndim_, data())
mshadow::TShape::utils::Check	include/mshadow/tensor_blob.h	/^    utils::Check(dim == ndim_,$/;"	p	language:C++	class:mshadow::TShape::utils	signature:(dim == ndim_, Ó)
mshadow::TShape::ymax	include/mshadow/tensor_blob.h	/^    index_t ymax = 1;$/;"	l	language:C++
mshadow::TShape::~TShape	include/mshadow/tensor_blob.h	/^  ~TShape() {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:()
mshadow::Tensor	include/mshadow/tensor.h	/^struct Tensor: public TRValue<Tensor<Device, dimension, DType>,$/;"	s	language:C++	namespace:mshadow	inherits:TRValue
mshadow::Tensor	include/mshadow/tensor.h	/^struct Tensor<Device, 1, DType>:$/;"	s	language:C++	namespace:mshadow	inherits:TRValue
mshadow::Tensor::CheckContiguous	include/mshadow/tensor.h	/^  MSHADOW_XINLINE bool CheckContiguous(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
mshadow::Tensor::FlatTo2D	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor<Device, 2, DType> FlatTo2D(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
mshadow::Tensor::MSize	include/mshadow/tensor.h	/^  MSHADOW_XINLINE size_t MSize(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
mshadow::Tensor::MemSize	include/mshadow/tensor.h	/^  MSHADOW_XINLINE size_t MemSize(void) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void) const
mshadow::Tensor::Slice	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor<Device, 1, DType> Slice(index_t begin, index_t end) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t begin, index_t end) const
mshadow::Tensor::Slice	include/mshadow/tensor.h	/^  Slice(index_t begin, index_t end) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t begin, index_t end) const
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr, Shape<1> shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, Shape<1> shape)
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr, Shape<1> shape,$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, Shape<1> shape, index_t stride, Stream<Device> *stream)
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr, const Shape<dimension> &shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, const Shape<dimension> &shape)
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(DType *dptr,$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(DType *dptr, const Shape<dimension> &shape, index_t stride, Stream<Device> *stream)
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(const Shape<1> &shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Shape<1> &shape)
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(const Shape<dimension> &shape)$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Shape<dimension> &shape)
mshadow::Tensor::Tensor	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor(void) : stream_(NULL) {}$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(void)
mshadow::Tensor::dptr_	include/mshadow/tensor.h	/^  DType *dptr_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::Tensor::kDevCPU	include/mshadow/tensor.h	/^  static const bool kDevCPU = Device::kDevCPU;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::Tensor::kSubdim	include/mshadow/tensor.h	/^  static const int  kSubdim = dimension - 1;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::Tensor::memsz	include/mshadow/tensor.h	/^    size_t memsz = this->stride_;$/;"	l	language:C++
mshadow::Tensor::operator =	include/mshadow/tensor.h	/^  inline Tensor<Device, 1, DType> &operator=(const DType &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const DType &exp)
mshadow::Tensor::operator =	include/mshadow/tensor.h	/^  inline Tensor<Device, dimension, DType> &operator=(const DType &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const DType &exp)
mshadow::Tensor::operator =	include/mshadow/tensor.h	/^  operator=(const Tensor<Device, 1, DType> &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Tensor<Device, 1, DType> &exp)
mshadow::Tensor::operator =	include/mshadow/tensor.h	/^  operator=(const Tensor<Device, dimension, DType> &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Tensor<Device, dimension, DType> &exp)
mshadow::Tensor::operator =	include/mshadow/tensor.h	/^  operator=(const expr::Exp<E, DType, etype> &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const expr::Exp<E, DType, etype> &exp)
mshadow::Tensor::operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE DType &operator[](index_t idx) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx)
mshadow::Tensor::operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor<Device, kSubdim, DType> operator[](index_t idx) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx) const
mshadow::Tensor::operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE const DType &operator[](index_t idx) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx) const
mshadow::Tensor::s	include/mshadow/tensor.h	/^    Shape<1> s;$/;"	l	language:C++
mshadow::Tensor::s	include/mshadow/tensor.h	/^    Shape<dimension> s = this->shape_;$/;"	l	language:C++
mshadow::Tensor::set_stream	include/mshadow/tensor.h	/^  inline void set_stream(Stream<Device> *stream) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(Stream<Device> *stream)
mshadow::Tensor::shape_	include/mshadow/tensor.h	/^  Shape<1> shape_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::Tensor::shape_	include/mshadow/tensor.h	/^  Shape<dimension> shape_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::Tensor::size	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t size(index_t i) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t i) const
mshadow::Tensor::size	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t size(index_t idx) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx) const
mshadow::Tensor::stream_	include/mshadow/tensor.h	/^  Stream<Device> *stream_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::Tensor::stride_	include/mshadow/tensor.h	/^  index_t stride_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
mshadow::TensorContainer	include/mshadow/tensor_container.h	/^class TensorContainer: public Tensor<Device, dimension, DType> {$/;"	c	language:C++	namespace:mshadow	inherits:Tensor
mshadow::TensorContainer::AllocByShape	include/mshadow/tensor_container.h	/^  inline void AllocByShape(const Shape<dimension>& shape) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:private	signature:(const Shape<dimension>& shape)
mshadow::TensorContainer::FreeSpace	include/mshadow/tensor_container.h	/^  inline void FreeSpace(void) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:private	signature:(void)
mshadow::TensorContainer::LoadBinary	include/mshadow/tensor_container.h	/^  inline void LoadBinary(TStream &fi) { \/\/ NOLINT(*)$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(TStream &fi)
mshadow::TensorContainer::Resize	include/mshadow/tensor_container.h	/^  inline void Resize(const Shape<dimension> &shape) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape)
mshadow::TensorContainer::Resize	include/mshadow/tensor_container.h	/^  inline void Resize(const Shape<dimension> &shape, DType initv) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape, DType initv)
mshadow::TensorContainer::SaveBinary	include/mshadow/tensor_container.h	/^  inline void SaveBinary(TStream &fo) const { \/\/ NOLINT(*)$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(TStream &fo) const
mshadow::TensorContainer::TensorContainer	include/mshadow/tensor_container.h	/^  TensorContainer$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const TensorContainer<Device, dimension, DType> &src)
mshadow::TensorContainer::TensorContainer	include/mshadow/tensor_container.h	/^  explicit TensorContainer(bool pad = MSHADOW_ALLOC_PAD) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(bool pad = MSHADOW_ALLOC_PAD)
mshadow::TensorContainer::TensorContainer	include/mshadow/tensor_container.h	/^  explicit TensorContainer(const Shape<dimension> &shape) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape)
mshadow::TensorContainer::TensorContainer	include/mshadow/tensor_container.h	/^  explicit TensorContainer(const Shape<dimension> &shape, DType initv) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const Shape<dimension> &shape, DType initv)
mshadow::TensorContainer::data_	include/mshadow/tensor_container.h	/^  Tensor<Device, 2, DType> data_;$/;"	m	language:C++	class:mshadow::TensorContainer	access:private
mshadow::TensorContainer::mshadow::LoadBinary	include/mshadow/tensor_container.h	/^    mshadow::LoadBinary(fi, &tmp, false);$/;"	p	language:C++	class:mshadow::TensorContainer::mshadow	signature:(fi, &tmp, false)
mshadow::TensorContainer::mshadow::SaveBinary	include/mshadow/tensor_container.h	/^    mshadow::SaveBinary(fo, *this);$/;"	p	language:C++	class:mshadow::TensorContainer::mshadow	signature:(fo, *this)
mshadow::TensorContainer::operator =	include/mshadow/tensor_container.h	/^  inline Tensor<Device, dimension, DType> &operator=(DType s) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(DType s)
mshadow::TensorContainer::operator =	include/mshadow/tensor_container.h	/^  inline TensorContainer &operator=$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const TensorContainer<Device, dimension, DType> &src)
mshadow::TensorContainer::operator =	include/mshadow/tensor_container.h	/^  operator=(const expr::Exp<E, DType, expr::type::kChainer> &exp) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const expr::Exp<E, DType, expr::type::kChainer> &exp)
mshadow::TensorContainer::operator =	include/mshadow/tensor_container.h	/^  operator=(const expr::Exp<E, DType, expr::type::kComplex> &exp) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const expr::Exp<E, DType, expr::type::kComplex> &exp)
mshadow::TensorContainer::operator =	include/mshadow/tensor_container.h	/^  operator=(const expr::Exp<E, DType, expr::type::kMapper> &exp) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const expr::Exp<E, DType, expr::type::kMapper> &exp)
mshadow::TensorContainer::pad_	include/mshadow/tensor_container.h	/^  bool pad_;$/;"	m	language:C++	class:mshadow::TensorContainer	access:private
mshadow::TensorContainer::s2	include/mshadow/tensor_container.h	/^    Shape<2> s2 = shape.FlatTo2D();$/;"	l	language:C++
mshadow::TensorContainer::set_pad	include/mshadow/tensor_container.h	/^  inline void set_pad(bool pad) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(bool pad)
mshadow::TensorContainer::stream	include/mshadow/tensor_container.h	/^    Stream<Device> stream;$/;"	l	language:C++
mshadow::TensorContainer::tmp	include/mshadow/tensor_container.h	/^    Tensor<cpu, dimension, DType> tmp;$/;"	l	language:C++
mshadow::TensorContainer::~TensorContainer	include/mshadow/tensor_container.h	/^  ~TensorContainer(void) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(void)
mshadow::VDot	include/mshadow/tensor_cpu-inl.h	/^inline DType VDot(const Tensor<cpu, 1, DType> &lhs,$/;"	f	language:C++	namespace:mshadow	signature:(const Tensor<cpu, 1, DType> &lhs, const Tensor<cpu, 1, DType> &rhs)
mshadow::Write	include/mshadow/io.h	/^    fo.Write(src[i].dptr_, sizeof(DType) * src.size(1));$/;"	p	language:C++	signature:(src[i].dptr_, sizeof(DType) * src.size(1))
mshadow::cpu	include/mshadow/tensor.h	/^struct cpu {$/;"	s	language:C++	namespace:mshadow
mshadow::cpu::kDevCPU	include/mshadow/tensor.h	/^  static const bool kDevCPU = true;$/;"	m	language:C++	struct:mshadow::cpu	access:public
mshadow::cpu::kDevMask	include/mshadow/tensor.h	/^  static const int kDevMask = 1 << 0;$/;"	m	language:C++	struct:mshadow::cpu	access:public
mshadow::cuda	include/mshadow/cuda/reduce.cuh	/^namespace cuda {$/;"	n	language:C++	namespace:mshadow	file:
mshadow::cuda	include/mshadow/cuda/tensor_gpu-inl.cuh	/^namespace cuda {$/;"	n	language:C++	namespace:mshadow	file:
mshadow::cuda::CheckLaunchParam	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void CheckLaunchParam(dim3 dimGrid, dim3 dimBlock, const char *estr = "") {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(dim3 dimGrid, dim3 dimBlock, const char *estr = Ó)
mshadow::cuda::GetAlignStride	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline index_t GetAlignStride(index_t xsize) { $/;"	f	language:C++	namespace:mshadow::cuda	signature:(index_t xsize)
mshadow::cuda::MakePlan	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      (expr::MakePlan(dst),$/;"	p	language:C++	file:	signature:(dst)
mshadow::cuda::MapPlan	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void MapPlan(expr::Plan<DstExp, DType> dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(expr::Plan<DstExp, DType> dst, const expr::Plan<E, DType> &plan, Shape<2> dshape, cudaStream_t stream)
mshadow::cuda::MapPlanKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapPlanKernel(DstPlan dst, index_t xstride,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, index_t xstride, Shape<2> dshape, const Plan exp)
mshadow::cuda::MapPlanLargeKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapPlanLargeKernel(DstPlan dst, index_t xstride,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, index_t xstride, Shape<2> dshape, const Plan exp, int repeat)
mshadow::cuda::MapPlanProc	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__device__ void MapPlanProc(DstPlan dst, index_t xstride,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, index_t xstride, Shape<2> dshape, const Plan exp, int block_idx)
mshadow::cuda::MapRedKeepLowestKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapRedKeepLowestKernel(DstPlan dst, Plan plan,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, Plan plan, DType scale, Shape<2> eshape)
mshadow::cuda::MapReduceKeepDim1	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void MapReduceKeepDim1(expr::Plan<DstExp, DType> dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(expr::Plan<DstExp, DType> dst, const expr::Plan<E, DType> &plan, DType scale, Shape<4> pshape, cudaStream_t stream)
mshadow::cuda::MapReduceKeepDim1Kernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void MapReduceKeepDim1Kernel(DstPlan dst, Plan plan, DType scale, Shape<4> pshape) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, Plan plan, DType scale, Shape<4> pshape)
mshadow::cuda::MapReduceKeepLowest	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void MapReduceKeepLowest(expr::Plan<DstExp, DType> dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(expr::Plan<DstExp, DType> dst, const expr::Plan<E, DType> &plan, DType scale, Shape<2> eshape, cudaStream_t stream)
mshadow::cuda::REval	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      dst.REval(y, x + threadIdx.x) = p;$/;"	p	language:C++	file:	signature:(y, x + threadIdx.x)
mshadow::cuda::REval	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      dst.REval(y, x + threadIdx.x) \/= ssum;$/;"	p	language:C++	file:	signature:(y, x + threadIdx.x)
mshadow::cuda::Reduce1D	include/mshadow/cuda/reduce.cuh	/^inline __device__ void Reduce1D(volatile DType buf[1 << x_bits]) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(volatile DType buf[1 << x_bits])
mshadow::cuda::Reduce1D	include/mshadow/cuda/reduce.cuh	/^inline __device__ void Reduce1D(volatile DType buf[1 << x_bits]);$/;"	p	language:C++	namespace:mshadow::cuda	file:	signature:(volatile DType buf[1 << x_bits])
mshadow::cuda::Reduce1DNotAlign	include/mshadow/cuda/reduce.cuh	/^Reduce1DNotAlign(volatile DType buf[1 << xmax_bits], int xsize);$/;"	p	language:C++	namespace:mshadow::cuda	file:	signature:(volatile DType buf[1 << xmax_bits], int xsize)
mshadow::cuda::Reduce1DNotAlign	include/mshadow/cuda/reduce.cuh	/^inline __device__ void Reduce1DNotAlign(volatile DType buf[], int x_size) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(volatile DType buf[], int x_size)
mshadow::cuda::ReduceX	include/mshadow/cuda/reduce.cuh	/^inline __device__ void ReduceX(volatile DType  buf[], int tid) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(volatile DType buf[], int tid)
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 1) Reducer::Reduce(buf[tid] , buf[tid + 1]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 1])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 128) Reducer::Reduce(buf[tid] , buf[tid + 128]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 128])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 16) Reducer::Reduce(buf[tid] , buf[tid + 16]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 16])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 2) Reducer::Reduce(buf[tid] , buf[tid + 2]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 2])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 256) Reducer::Reduce(buf[tid] , buf[tid + 256]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 256])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 32) Reducer::Reduce(buf[tid] , buf[tid + 32]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 32])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 4) Reducer::Reduce(buf[tid] , buf[tid + 4]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 4])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 512) Reducer::Reduce(buf[tid] , buf[tid + 512]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 512])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 64) Reducer::Reduce(buf[tid] , buf[tid + 64]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 64])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/reduce.cuh	/^    if (tid < 8) Reducer::Reduce(buf[tid] , buf[tid + 8]);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(buf[tid] , buf[tid + 8])
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      Reducer::Reduce(res, plan.Eval((n * pshape[1] + c) * pshape[2] + y, x));$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(res, plan.Eval((n * pshape[1] + c) * pshape[2] + y, x))
mshadow::cuda::Reducer::Reduce	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      Reducer::Reduce(s_res[threadIdx.x][threadIdx.y], plan.Eval(threadIdx.y + y, x));$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(s_res[threadIdx.x][threadIdx.y], plan.Eval(threadIdx.y + y, x))
mshadow::cuda::Reducer::SetInitValue	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType res; Reducer::SetInitValue(res);$/;"	p	language:C++	class:mshadow::cuda::Reducer	file:	signature:(res)
mshadow::cuda::Saver::Save	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    Saver::Save(dst.REval(0, c), s_rec[0] * scale);$/;"	p	language:C++	class:mshadow::cuda::Saver	file:	signature:(dst.REval(0, c), s_rec[0] * scale)
mshadow::cuda::Saver::Save	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    Saver::Save(dst.REval(0, x),  s_res[threadIdx.x][0] * scale);$/;"	p	language:C++	class:mshadow::cuda::Saver	file:	signature:(dst.REval(0, x), s_res[threadIdx.x][0] * scale)
mshadow::cuda::Saver::Save	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    Saver::Save(dst.REval(y, x), exp.Eval(y,x));$/;"	p	language:C++	class:mshadow::cuda::Saver	file:	signature:(dst.REval(y, x), exp.Eval(y,x))
mshadow::cuda::Softmax	include/mshadow/cuda/tensor_gpu-inl.cuh	/^inline void Softmax(Tensor<gpu, 2, DType> &dst,$/;"	f	language:C++	namespace:mshadow::cuda	signature:(Tensor<gpu, 2, DType> &dst, const Tensor<gpu, 2, DType> &src)
mshadow::cuda::Softmax	include/mshadow/tensor_gpu-inl.h	/^  cuda::Softmax(dst, src);$/;"	p	language:C++	class:mshadow::cuda	signature:(dst, src)
mshadow::cuda::SoftmaxKernel	include/mshadow/cuda/tensor_gpu-inl.cuh	/^__global__ void SoftmaxKernel(DstPlan dst, SrcPlan src, index_t xmax) {$/;"	f	language:C++	namespace:mshadow::cuda	signature:(DstPlan dst, SrcPlan src, index_t xmax)
mshadow::cuda::a	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      DType a = src.Eval(y, x + threadIdx.x);$/;"	l	language:C++
mshadow::cuda::block_size	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int block_size = 1 << block_dim_bits;$/;"	l	language:C++
mshadow::cuda::c	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int c = blockIdx.x;  $/;"	l	language:C++
mshadow::cuda::dim3	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimGrid((eshape[1] + kMemUnit - 1) >> kMemUnitBits);$/;"	p	language:C++	file:	signature:(eshape[1] + kMemUnit - 1) >> kMemUnitBits
mshadow::cuda::dimBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimBlock(kBaseThreadNum);$/;"	p	language:C++	file:	signature:(kBaseThreadNum)
mshadow::cuda::dimBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimBlock(kBaseThreadNum, 1, 1);$/;"	p	language:C++	file:	signature:(kBaseThreadNum, 1, 1)
mshadow::cuda::dimBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimBlock(kMemUnit, kMemUnit);$/;"	p	language:C++	file:	signature:(kMemUnit, kMemUnit)
mshadow::cuda::dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    dim3 dimGrid(kBaseGridNum, 1 , 1);$/;"	p	language:C++	file:	signature:(kBaseGridNum, 1 , 1)
mshadow::cuda::dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    dim3 dimGrid(num_block, 1, 1);$/;"	p	language:C++	file:	signature:(num_block, 1, 1)
mshadow::cuda::dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimGrid (pshape[1]);$/;"	p	language:C++	file:	signature:(pshape[1])
mshadow::cuda::dimGrid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  dim3 dimGrid(dst.size(0));$/;"	p	language:C++	file:	signature:(dst.size(0))
mshadow::cuda::expr::MakePlan	include/mshadow/cuda/tensor_gpu-inl.cuh	/^       expr::MakePlan(src),$/;"	p	language:C++	class:mshadow::cuda::expr	file:	signature:(src)
mshadow::cuda::i	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    index_t i = i_offset + threadIdx.x;$/;"	l	language:C++
mshadow::cuda::kBaseGridNum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kBaseGridNum = 1024;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kBaseThreadBits	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kBaseThreadBits = 8;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kBaseThreadNum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kBaseThreadNum  = 1 << kBaseThreadBits;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kMaxGridNum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMaxGridNum = 65535;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kMaxThreadsPerBlock	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMaxThreadsPerBlock = 512;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kMemUnit	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMemUnit = 1 << kMemUnitBits;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kMemUnitBits	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMemUnitBits = 4;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::kMemUnitMask	include/mshadow/cuda/tensor_gpu-inl.cuh	/^const int kMemUnitMask = kMemUnit - 1;$/;"	m	language:C++	namespace:mshadow::cuda	file:
mshadow::cuda::n	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      const index_t n = i \/ pshape[2];$/;"	l	language:C++
mshadow::cuda::num_block	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int num_block = (dshape[0] * xstride + kBaseThreadNum-1) \/ kBaseThreadNum;$/;"	l	language:C++
mshadow::cuda::p	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      DType p = expf(src.Eval(y, x + threadIdx.x) - smax);$/;"	l	language:C++
mshadow::cuda::repeat	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    int repeat = (num_block + kBaseGridNum-1) \/ kBaseGridNum;$/;"	l	language:C++
mshadow::cuda::res	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType res; Reducer::SetInitValue(res);$/;"	l	language:C++
mshadow::cuda::s_rec	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  __shared__ DType s_rec[block_size];$/;"	l	language:C++
mshadow::cuda::s_rec	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  __shared__ DType s_rec[x_size];  $/;"	l	language:C++
mshadow::cuda::s_res	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  __shared__ DType s_res[warp_size][warp_size + 1];$/;"	l	language:C++
mshadow::cuda::smax	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType smax = s_rec[0];$/;"	l	language:C++
mshadow::cuda::ssum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType ssum = s_rec[0];$/;"	l	language:C++
mshadow::cuda::stream	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  cudaStream_t stream = Stream<gpu>::GetStream(dst.stream_);$/;"	l	language:C++
mshadow::cuda::tid	include/mshadow/cuda/reduce.cuh	/^  int tid = threadIdx.x;$/;"	l	language:C++
mshadow::cuda::tid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const index_t tid = (block_idx << block_dim_bits) + threadIdx.x;$/;"	l	language:C++
mshadow::cuda::tot	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const index_t tot = pshape[3] * pshape[2] * pshape[0];$/;"	l	language:C++
mshadow::cuda::utils::Check	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  utils::Check(dst.shape_ == src.shape_, "Softmax: shape mismatch");$/;"	p	language:C++	class:mshadow::cuda::utils	file:	signature:(dst.shape_ == src.shape_, Ó)
mshadow::cuda::warp_size	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const unsigned warp_size = 1 << warp_bits;$/;"	l	language:C++
mshadow::cuda::x	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      const index_t x = i % pshape[3];$/;"	l	language:C++
mshadow::cuda::x	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int x = tid % xstride;$/;"	l	language:C++
mshadow::cuda::x	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const unsigned x = (blockIdx.x << warp_bits) + threadIdx.x;$/;"	l	language:C++
mshadow::cuda::x_size	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const unsigned x_size = 1 << x_bits;$/;"	l	language:C++
mshadow::cuda::xstride	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const index_t xstride = GetAlignStride(dshape[1]);$/;"	l	language:C++
mshadow::cuda::y	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      const index_t y = i % pshape[2];$/;"	l	language:C++
mshadow::cuda::y	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int y = blockIdx.x;$/;"	l	language:C++
mshadow::cuda::y	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int y = tid \/ xstride;$/;"	l	language:C++
mshadow::default_real_t	include/mshadow/base.h	/^typedef float default_real_t;$/;"	t	language:C++	namespace:mshadow
mshadow::device_count	include/mshadow/tensor_gpu-inl.h	/^  int device_count = 0;$/;"	l	language:C++
mshadow::device_id	include/mshadow/tensor_gpu-inl.h	/^  int device_id = 0;$/;"	l	language:C++
mshadow::dplan	include/mshadow/tensor_cpu-inl.h	/^  expr::Plan<R, DType> dplan = MakePlan(dst->self());$/;"	l	language:C++
mshadow::dplan	include/mshadow/tensor_cpu-inl.h	/^  expr::Plan<R, DType> dplan = expr::MakePlan(dst->self());$/;"	l	language:C++
mshadow::dptr	include/mshadow/tensor_cpu-inl.h	/^  void *dptr = AllocHost_<xpu>(obj->MSize() * sizeof(DType));$/;"	l	language:C++
mshadow::dptr	include/mshadow/tensor_cpu-inl.h	/^  void *dptr;$/;"	l	language:C++
mshadow::dshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<1> dshape = expr::ShapeCheck<1, R>::Check(dst->self());$/;"	l	language:C++
mshadow::dshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<dim> dshape = expr::ShapeCheck<dim, R>::Check(dst->self());$/;"	l	language:C++
mshadow::dshape	include/mshadow/tensor_gpu-inl.h	/^    Shape<1> dshape = expr::ShapeCheck<1, R>::Check(dst->self());$/;"	l	language:C++
mshadow::dshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<1> dshape = expr::ShapeCheck<1, R>::Check(dst->self());$/;"	l	language:C++
mshadow::dshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<dim> dshape = expr::ShapeCheck<dim, R>::Check(dst->self());$/;"	l	language:C++
mshadow::dst	include/mshadow/io.h	/^  Tensor<cpu, 2, DType> dst = dst_->FlatTo2D();$/;"	l	language:C++
mshadow::dst	include/mshadow/tensor_cpu-inl.h	/^  Tensor<cpu, 2, DType> dst = _dst.FlatTo2D();$/;"	l	language:C++
mshadow::dst	include/mshadow/tensor_gpu-inl.h	/^  Tensor<A, 2, DType> dst = _dst.FlatTo2D();$/;"	l	language:C++
mshadow::err	include/mshadow/stream_gpu-inl.h	/^  cudaError_t err = cudaStreamCreate(&st->stream_);$/;"	l	language:C++
mshadow::err	include/mshadow/stream_gpu-inl.h	/^  cudaError_t err = cudaStreamDestroy(stream->stream_);$/;"	l	language:C++
mshadow::err	include/mshadow/tensor_gpu-inl.h	/^    cudaError_t err =$/;"	l	language:C++
mshadow::err	include/mshadow/tensor_gpu-inl.h	/^  cudaError_t err = cudaMemcpy2DAsync(dst.dptr_, dst.stride_ * sizeof(DType),$/;"	l	language:C++
mshadow::eshape	include/mshadow/tensor_cpu-inl.h	/^  EShape eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
mshadow::eshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<2> eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
mshadow::eshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<dim> eshape = expr::ShapeCheck<dim, E>::Check(exp.self());$/;"	l	language:C++
mshadow::eshape	include/mshadow/tensor_gpu-inl.h	/^  EShape eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
mshadow::eshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<2> eshape = expr::ShapeCheck<expr::ExpInfo<E>::kDim, E>$/;"	l	language:C++
mshadow::eshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<dim> eshape = expr::ShapeCheck<dim, E>::Check(exp.self());$/;"	l	language:C++
mshadow::expr	include/mshadow/dot_engine-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/expr_engine-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/expr_scalar-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/expression.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/broadcast.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/channel_pool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/channel_unpool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/concat.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/crop.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/mirror.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/pack_col2patch.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/pad.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/reduceto1d.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/reshape.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/spatial_pool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/spatial_unpool.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/swapaxis.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/extension/unpack_patch2col.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr	include/mshadow/sse-inl.h	/^namespace expr {$/;"	n	language:C++	namespace:mshadow
mshadow::expr::BLASEngine	include/mshadow/dot_engine-inl.h	/^struct BLASEngine;$/;"	x	language:C++
mshadow::expr::BLASEngine	include/mshadow/dot_engine-inl.h	/^struct BLASEngine<cpu> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::BLASEngine	include/mshadow/dot_engine-inl.h	/^struct BLASEngine<gpu> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::BLASEngine::GetT	include/mshadow/dot_engine-inl.h	/^  inline static CBLAS_TRANSPOSE GetT(bool t) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(bool t)
mshadow::expr::BLASEngine::GetT	include/mshadow/dot_engine-inl.h	/^  inline static cublasOperation_t GetT(bool t) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(bool t)
mshadow::expr::BLASEngine::SetStream	include/mshadow/dot_engine-inl.h	/^  inline static void SetStream(Stream<cpu> *stream) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream)
mshadow::expr::BLASEngine::SetStream	include/mshadow/dot_engine-inl.h	/^  inline static void SetStream(Stream<gpu> *stream) {$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream)
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasDgemm(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasDgemv(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasDger(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSetStream(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSgemm(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSgemv(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::err	include/mshadow/dot_engine-inl.h	/^    cublasStatus_t err = cublasSger(Stream<gpu>::GetBlasHandle(stream),$/;"	l	language:C++
mshadow::expr::BLASEngine::gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool transa, bool transb, int m, int n, int k, double alpha, const double *A, int lda, const double *B, int ldb, double beta, double *C, int ldc)
mshadow::expr::BLASEngine::gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool transa, bool transb, int m, int n, int k, float alpha, const float *A, int lda, const float *B, int ldb, float beta, float *C, int ldc)
mshadow::expr::BLASEngine::gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool transa, bool transb, int m, int n, int k, double alpha, const double *A, int lda, const double *B, int ldb, double beta, double *C, int ldc)
mshadow::expr::BLASEngine::gemm	include/mshadow/dot_engine-inl.h	/^  inline static void gemm(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool transa, bool transb, int m, int n, int k, float alpha, const float *A, int lda, const float *B, int ldb, float beta, float *C, int ldc)
mshadow::expr::BLASEngine::gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool trans, int m, int n, double alpha, const double *A, int lda, const double *X, int incX, double beta, double *Y, int incY)
mshadow::expr::BLASEngine::gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, bool trans, int m, int n, float alpha, const float *A, int lda, const float *X, int incX, float beta, float *Y, int incY)
mshadow::expr::BLASEngine::gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool trans, int m, int n, double alpha, const double *A, int lda, const double *X, int incX, double beta, double *Y, int incY)
mshadow::expr::BLASEngine::gemv	include/mshadow/dot_engine-inl.h	/^  inline static void gemv(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, bool trans, int m, int n, float alpha, const float *A, int lda, const float *X, int incX, float beta, float *Y, int incY)
mshadow::expr::BLASEngine::ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, int m, int n, double alpha, const double *X, int incX, const double *Y, int incY, double *A, int lda)
mshadow::expr::BLASEngine::ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<cpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<cpu> *stream, int m, int n, float alpha, const float *X, int incX, const float *Y, int incY, float *A, int lda)
mshadow::expr::BLASEngine::ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, int m, int n, double alpha, const double *X, int incX, const double *Y, int incY, double *A, int lda)
mshadow::expr::BLASEngine::ger	include/mshadow/dot_engine-inl.h	/^  inline static void ger(Stream<gpu> *stream,$/;"	f	language:C++	struct:mshadow::expr::BLASEngine	access:public	signature:(Stream<gpu> *stream, int m, int n, float alpha, const float *X, int incX, const float *Y, int incY, float *A, int lda)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Dgemm fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Dgemv fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Dger fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Sgemm fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Sgemv fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS, "cublas: Sger fail");$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BLASEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(err == CUBLAS_STATUS_SUCCESS,$/;"	p	language:C++	class:mshadow::expr::BLASEngine::utils	signature:(err == CUBLAS_STATUS_SUCCESS, Ó)
mshadow::expr::BinaryMapExp	include/mshadow/expression.h	/^struct BinaryMapExp: public Exp<BinaryMapExp<OP, TA, TB, DType, etype>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::BinaryMapExp::BinaryMapExp	include/mshadow/expression.h	/^  explicit BinaryMapExp(const TA &lhs, const TB &rhs)$/;"	f	language:C++	struct:mshadow::expr::BinaryMapExp	access:public	signature:(const TA &lhs, const TB &rhs)
mshadow::expr::BinaryMapExp::lhs_	include/mshadow/expression.h	/^  const TA &lhs_;$/;"	m	language:C++	struct:mshadow::expr::BinaryMapExp	access:public
mshadow::expr::BinaryMapExp::rhs_	include/mshadow/expression.h	/^  const TB &rhs_;$/;"	m	language:C++	struct:mshadow::expr::BinaryMapExp	access:public
mshadow::expr::Broadcast1DExp	include/mshadow/extension/broadcast.h	/^struct Broadcast1DExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::Broadcast1DExp::Broadcast1DExp	include/mshadow/extension/broadcast.h	/^  Broadcast1DExp(const SrcExp &src, Shape<dimdst> shape)$/;"	f	language:C++	struct:mshadow::expr::Broadcast1DExp	access:public	signature:(const SrcExp &src, Shape<dimdst> shape)
mshadow::expr::Broadcast1DExp::src_	include/mshadow/extension/broadcast.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::Broadcast1DExp	access:public
mshadow::expr::ChannelPoolingExp	include/mshadow/extension/channel_pool.h	/^struct ChannelPoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::ChannelPoolingExp::ChannelPoolingExp	include/mshadow/extension/channel_pool.h	/^  ChannelPoolingExp(const SrcExp &src, index_t nsize, index_t stride, index_t pad)$/;"	f	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public	signature:(const SrcExp &src, index_t nsize, index_t stride, index_t pad)
mshadow::expr::ChannelPoolingExp::nsize_	include/mshadow/extension/channel_pool.h	/^  index_t nsize_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
mshadow::expr::ChannelPoolingExp::pad_	include/mshadow/extension/channel_pool.h	/^  index_t pad_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
mshadow::expr::ChannelPoolingExp::src_	include/mshadow/extension/channel_pool.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
mshadow::expr::ChannelPoolingExp::src_channel_	include/mshadow/extension/channel_pool.h	/^  index_t src_channel_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
mshadow::expr::ChannelPoolingExp::stride_	include/mshadow/extension/channel_pool.h	/^  index_t stride_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
mshadow::expr::ChannelPoolingExp::utils::Check	include/mshadow/extension/channel_pool.h	/^    utils::Check(this->shape_[srcdim - 3] >= nsize_,$/;"	p	language:C++	class:mshadow::expr::ChannelPoolingExp::utils	signature:(this->shape_[srcdim - 3] >= nsize_, Ó)
mshadow::expr::ChannelUnpoolingExp	include/mshadow/extension/channel_unpool.h	/^struct ChannelUnpoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::ChannelUnpoolingExp::ChannelUnpoolingExp	include/mshadow/extension/channel_unpool.h	/^  ChannelUnpoolingExp(const SrcExp &data_src,$/;"	f	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public	signature:(const SrcExp &data_src, const SrcExp &data_pooled, const SrcExp &grad_pooled, index_t nsize, index_t kstride, index_t pad)
mshadow::expr::ChannelUnpoolingExp::data_pooled_	include/mshadow/extension/channel_unpool.h	/^  const SrcExp &data_pooled_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::data_src_	include/mshadow/extension/channel_unpool.h	/^  const SrcExp &data_src_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::grad_pooled_	include/mshadow/extension/channel_unpool.h	/^  const SrcExp &grad_pooled_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::kstride_	include/mshadow/extension/channel_unpool.h	/^  index_t kstride_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::nsize_	include/mshadow/extension/channel_unpool.h	/^  index_t nsize_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::pad_	include/mshadow/extension/channel_unpool.h	/^  index_t pad_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::pchannel_	include/mshadow/extension/channel_unpool.h	/^  index_t pchannel_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
mshadow::expr::ChannelUnpoolingExp::pshape	include/mshadow/extension/channel_unpool.h	/^    Shape<srcdim> pshape = ShapeCheck<srcdim, SrcExp>::Check(grad_pooled);$/;"	l	language:C++
mshadow::expr::ChannelUnpoolingExp::sshape	include/mshadow/extension/channel_unpool.h	/^    Shape<srcdim> sshape = ShapeCheck<srcdim, SrcExp>::Check(data_src);$/;"	l	language:C++
mshadow::expr::ChannelUnpoolingExp::utils::Check	include/mshadow/extension/channel_unpool.h	/^      utils::Check(pshape[k] == sshape[k],$/;"	p	language:C++	class:mshadow::expr::ChannelUnpoolingExp::utils	signature:(pshape[k] == sshape[k], Ó)
mshadow::expr::ChannelUnpoolingExp::utils::Check	include/mshadow/extension/channel_unpool.h	/^    utils::Check(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled),$/;"	p	language:C++	class:mshadow::expr::ChannelUnpoolingExp::utils	signature:(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled), Ó)
mshadow::expr::ConcatExp	include/mshadow/extension/concat.h	/^struct ConcatExp : public TRValue<ConcatExp<LhsExp, RhsExp,$/;"	s	language:C++	namespace:mshadow::expr	inherits:TRValue
mshadow::expr::ConcatExp::ConcatExp	include/mshadow/extension/concat.h	/^  ConcatExp(const LhsExp &src1, const RhsExp &src2) : src1_(src1), src2_(src2) {$/;"	f	language:C++	struct:mshadow::expr::ConcatExp	access:public	signature:(const LhsExp &src1, const RhsExp &src2)
mshadow::expr::ConcatExp::dcat_src1_	include/mshadow/extension/concat.h	/^  index_t dcat_src1_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
mshadow::expr::ConcatExp::dcat_src2_	include/mshadow/extension/concat.h	/^  index_t dcat_src2_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
mshadow::expr::ConcatExp::dimcat	include/mshadow/extension/concat.h	/^  static const int dimcat = srcdim - dimsrc_m_cat;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
mshadow::expr::ConcatExp::operator =	include/mshadow/extension/concat.h	/^  operator=(const DType &exp) {$/;"	f	language:C++	struct:mshadow::expr::ConcatExp	access:public	signature:(const DType &exp)
mshadow::expr::ConcatExp::operator =	include/mshadow/extension/concat.h	/^  operator=(const expr::Exp<E, DType, etype> &exp) {$/;"	f	language:C++	struct:mshadow::expr::ConcatExp	access:public	signature:(const expr::Exp<E, DType, etype> &exp)
mshadow::expr::ConcatExp::shape_	include/mshadow/extension/concat.h	/^  Shape<4> shape_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
mshadow::expr::ConcatExp::src1_	include/mshadow/extension/concat.h	/^  const LhsExp &src1_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
mshadow::expr::ConcatExp::src2_	include/mshadow/extension/concat.h	/^  const RhsExp &src2_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
mshadow::expr::ConcatExp::sshape1	include/mshadow/extension/concat.h	/^    Shape<srcdim> sshape1 = ShapeCheck<srcdim, LhsExp>::Check(src1_);$/;"	l	language:C++
mshadow::expr::ConcatExp::sshape2	include/mshadow/extension/concat.h	/^    Shape<srcdim> sshape2 = ShapeCheck<srcdim, RhsExp>::Check(src2_);$/;"	l	language:C++
mshadow::expr::ConcatExp::utils::Check	include/mshadow/extension/concat.h	/^        utils::Check(sshape1[i] == sshape2[i],$/;"	p	language:C++	class:mshadow::expr::ConcatExp::utils	signature:(sshape1[i] == sshape2[i], Ó)
mshadow::expr::CroppingExp	include/mshadow/extension/crop.h	/^struct CroppingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::CroppingExp::CroppingExp	include/mshadow/extension/crop.h	/^  explicit CroppingExp(const SrcExp &src, Shape<2> cshape)$/;"	f	language:C++	struct:mshadow::expr::CroppingExp	access:public	signature:(const SrcExp &src, Shape<2> cshape)
mshadow::expr::CroppingExp::CroppingExp	include/mshadow/extension/crop.h	/^  explicit CroppingExp(const SrcExp &src, Shape<2> cshape,$/;"	f	language:C++	struct:mshadow::expr::CroppingExp	access:public	signature:(const SrcExp &src, Shape<2> cshape, index_t start_height, index_t start_width)
mshadow::expr::CroppingExp::pad_height_	include/mshadow/extension/crop.h	/^  index_t pad_height_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
mshadow::expr::CroppingExp::pad_width_	include/mshadow/extension/crop.h	/^  index_t pad_width_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
mshadow::expr::CroppingExp::src_	include/mshadow/extension/crop.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
mshadow::expr::CroppingExp::src_height_	include/mshadow/extension/crop.h	/^  index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
mshadow::expr::CroppingExp::utils::Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 1] >= cshape[1] + start_width,$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 1] >= cshape[1] + start_width, Ó)
mshadow::expr::CroppingExp::utils::Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 1] >= cshape[1],$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 1] >= cshape[1], Ó)
mshadow::expr::CroppingExp::utils::Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 2] >= cshape[0] + start_height,$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 2] >= cshape[0] + start_height, Ó)
mshadow::expr::CroppingExp::utils::Check	include/mshadow/extension/crop.h	/^    utils::Check(this->shape_[srcdim - 2] >= cshape[0],$/;"	p	language:C++	class:mshadow::expr::CroppingExp::utils	signature:(this->shape_[srcdim - 2] >= cshape[0], Ó)
mshadow::expr::DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine<SV, xpu, 1, 1, 2, false, transpose_right, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine<SV, xpu, 2, 1, 1, true, false, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::DotEngine	include/mshadow/dot_engine-inl.h	/^struct DotEngine<SV, xpu, 2, 2, 2, transpose_left, transpose_right, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::DotEngine::BLASEngine::SetStream	include/mshadow/dot_engine-inl.h	/^    BLASEngine<xpu>::SetStream(dst.stream_);$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_)
mshadow::expr::DotEngine::BLASEngine::gemm	include/mshadow/dot_engine-inl.h	/^    BLASEngine<xpu>::gemm$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_, transpose_right , transpose_left, transpose_right ? rhs.size(0) : rhs.size(1), transpose_left ? lhs.size(1) : lhs.size(0), transpose_right ? rhs.size(1) : rhs.size(0), scale * SV::AlphaBLAS(), rhs.dptr_, rhs.stride_, lhs.dptr_, lhs.stride_, SV::BetaBLAS(), dst.dptr_, dst.stride_)
mshadow::expr::DotEngine::BLASEngine::gemv	include/mshadow/dot_engine-inl.h	/^    BLASEngine<xpu>::gemv$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_, transpose_right, rhs.size(1), rhs.size(0), scale * SV::AlphaBLAS(), rhs.dptr_, rhs.stride_, lhs.dptr_, 1, SV::BetaBLAS(), dst.dptr_, 1)
mshadow::expr::DotEngine::BLASEngine::ger	include/mshadow/dot_engine-inl.h	/^      BLASEngine<xpu>::ger$/;"	p	language:C++	class:mshadow::expr::DotEngine::BLASEngine	signature:(dst.stream_, rhs.size(0), lhs.size(0), scale * SV::AlphaBLAS(), rhs.dptr_, 1, lhs.dptr_, 1, dst.dptr_, dst.stride_)
mshadow::expr::DotEngine::DotEngine::Eval	include/mshadow/dot_engine-inl.h	/^                DType>::Eval(dst, lhs.FlatTo2D(), rhs.FlatTo2D(), scale);$/;"	p	language:C++	class:mshadow::expr::DotEngine::DotEngine	signature:(dst, lhs.FlatTo2D(), rhs.FlatTo2D(), scale)
mshadow::expr::DotEngine::Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<Device, ddim, DType> *p_dst,$/;"	p	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<Device, ddim, DType> *p_dst, const Tensor<Device, ldim, DType> &lhs, const Tensor<Device, rdim, DType> &rhs, DType scale)
mshadow::expr::DotEngine::Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<xpu, 1, DType> *p_dst,$/;"	f	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<xpu, 1, DType> *p_dst, const Tensor<xpu, 1, DType> &lhs, const Tensor<xpu, 2, DType> &rhs, DType scale)
mshadow::expr::DotEngine::Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<xpu, 2, DType> *p_dst,$/;"	f	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<xpu, 2, DType> *p_dst, const Tensor<xpu, 1, DType> &lhs, const Tensor<xpu, 1, DType> &rhs, DType scale)
mshadow::expr::DotEngine::Eval	include/mshadow/dot_engine-inl.h	/^  inline static void Eval(Tensor<xpu, 2, DType> *p_dst,$/;"	f	language:C++	struct:mshadow::expr::DotEngine	access:public	signature:(Tensor<xpu, 2, DType> *p_dst, const Tensor<xpu, 2, DType> &lhs, const Tensor<xpu, 2, DType> &rhs, DType scale)
mshadow::expr::DotEngine::dst	include/mshadow/dot_engine-inl.h	/^    Tensor<xpu, 1, DType> &dst = *p_dst;$/;"	l	language:C++
mshadow::expr::DotEngine::dst	include/mshadow/dot_engine-inl.h	/^    Tensor<xpu, 2, DType> &dst = *p_dst;$/;"	l	language:C++
mshadow::expr::DotEngine::sleft	include/mshadow/dot_engine-inl.h	/^    Shape<2> sleft = GetShape(lhs.shape_, transpose_left);$/;"	l	language:C++
mshadow::expr::DotEngine::sright	include/mshadow/dot_engine-inl.h	/^    Shape<2> sright = GetShape(rhs.shape, transpose_right);$/;"	l	language:C++
mshadow::expr::DotEngine::sright	include/mshadow/dot_engine-inl.h	/^    Shape<2> sright = GetShape(rhs.shape_, transpose_right);$/;"	l	language:C++
mshadow::expr::DotEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(dst.size(0) == lhs.size(0) && dst.size(1) == rhs.size(0),$/;"	p	language:C++	class:mshadow::expr::DotEngine::utils	signature:(dst.size(0) == lhs.size(0) && dst.size(1) == rhs.size(0), Ó)
mshadow::expr::DotEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(dst.size(0) == sleft[0] && dst.size(1) == sright[1] \\$/;"	p	language:C++	class:mshadow::expr::DotEngine::utils	signature:(dst.size(0) == sleft[0] && dst.size(1) == sright[1] \ && sleft[1] == sright[0] , Ó)
mshadow::expr::DotEngine::utils::Check	include/mshadow/dot_engine-inl.h	/^    utils::Check(dst.size(0) == sright[1] && lhs.size(0) == sright[0],$/;"	p	language:C++	class:mshadow::expr::DotEngine::utils	signature:(dst.size(0) == sright[1] && lhs.size(0) == sright[0], Ó)
mshadow::expr::DotExp	include/mshadow/expression.h	/^struct DotExp: public Exp<DotExp<TA, TB, ltrans, rtrans, DType>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::DotExp::DotExp	include/mshadow/expression.h	/^  explicit DotExp(const TA &lhs, const TB &rhs, DType scale)$/;"	f	language:C++	struct:mshadow::expr::DotExp	access:public	signature:(const TA &lhs, const TB &rhs, DType scale)
mshadow::expr::DotExp::lhs_	include/mshadow/expression.h	/^  const TA &lhs_;$/;"	m	language:C++	struct:mshadow::expr::DotExp	access:public
mshadow::expr::DotExp::rhs_	include/mshadow/expression.h	/^  const TB &rhs_;$/;"	m	language:C++	struct:mshadow::expr::DotExp	access:public
mshadow::expr::DotExp::scale_	include/mshadow/expression.h	/^  DType scale_;$/;"	m	language:C++	struct:mshadow::expr::DotExp	access:public
mshadow::expr::Exp	include/mshadow/expression.h	/^struct Exp {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Exp::ptrself	include/mshadow/expression.h	/^  inline SubType* ptrself(void) {$/;"	f	language:C++	struct:mshadow::expr::Exp	access:public	signature:(void)
mshadow::expr::Exp::self	include/mshadow/expression.h	/^  inline const SubType& self(void) const {$/;"	f	language:C++	struct:mshadow::expr::Exp	access:public	signature:(void) const
mshadow::expr::ExpComplexEngine	include/mshadow/expr_engine-inl.h	/^struct ExpComplexEngine {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpComplexEngine	include/mshadow/expr_engine-inl.h	/^struct ExpComplexEngine<SV,$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpComplexEngine	include/mshadow/extension/reduceto1d.h	/^struct ExpComplexEngine<SV,$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpComplexEngine::DotEngine::Eval	include/mshadow/expr_engine-inl.h	/^              ltrans, rtrans, DType>::Eval(dst, exp.lhs_, exp.rhs_, exp.scale_);$/;"	p	language:C++	class:mshadow::expr::ExpComplexEngine::DotEngine	signature:(dst, exp.lhs_, exp.rhs_, exp.scale_)
mshadow::expr::ExpComplexEngine::Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst, const E &exp);$/;"	p	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(RV *dst, const E &exp)
mshadow::expr::ExpComplexEngine::Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(Tensor<Device, dim, DType> *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(Tensor<Device, dim, DType> *dst, const DotExp<Tensor<Device, ldim, DType>, Tensor<Device, rdim, DType>, ltrans, rtrans, DType> &exp)
mshadow::expr::ExpComplexEngine::Eval	include/mshadow/extension/reduceto1d.h	/^  inline static void Eval(Tensor<Device, 1, DType> *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(Tensor<Device, 1, DType> *dst, const ReduceTo1DExp<SrcExp, DType, Reducer, 1> &exp)
mshadow::expr::ExpComplexEngine::Eval	include/mshadow/extension/reduceto1d.h	/^  inline static void Eval(Tensor<Device, 1, DType> *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public	signature:(Tensor<Device, 1, DType> *dst, const ReduceTo1DExp<SrcExp, DType, Reducer, m_dimkeep> &exp)
mshadow::expr::ExpComplexEngine::TypeCheckPass::Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/reduceto1d.h	/^        ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::ExpComplexEngine::TypeCheckPass	signature:()
mshadow::expr::ExpComplexEngine::dimkeep	include/mshadow/extension/reduceto1d.h	/^  static const int dimkeep = ExpInfo<SrcExp>::kDim - m_dimkeep;$/;"	m	language:C++	struct:mshadow::expr::ExpComplexEngine	access:public
mshadow::expr::ExpEngine	include/mshadow/expr_engine-inl.h	/^struct ExpEngine {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpEngine	include/mshadow/expression.h	/^struct ExpEngine;$/;"	x	language:C++
mshadow::expr::ExpEngine::Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kChainer> &exp)
mshadow::expr::ExpEngine::Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kComplex> &exp)
mshadow::expr::ExpEngine::Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kMapper> &exp)
mshadow::expr::ExpEngine::Eval	include/mshadow/expr_engine-inl.h	/^  inline static void Eval(RV *dst,$/;"	f	language:C++	struct:mshadow::expr::ExpEngine	access:public	signature:(RV *dst, const Exp<E, DType, type::kRValue> &exp)
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo< ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<MakeTensorExp<T, SrcExp, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<Tensor<Device, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<TransposeExp<E, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<TypecastExp<DstDType, SrcDType, EType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo	include/mshadow/expr_engine-inl.h	/^struct ExpInfo<UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = 0;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = 0xffff;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = Device::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<E>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<EType>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<SrcExp>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<TA>::kDevMask & ExpInfo<TB>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDevMask	include/mshadow/expr_engine-inl.h	/^  static const int kDevMask = ExpInfo<TA>::kDevMask;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = (kDimLhs >= 0 && kDimRhs >= 0) ?\\$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = -1;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = 0;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = ExpInfo<E>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = ExpInfo<EType>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = ExpInfo<TA>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = dim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDim	include/mshadow/expr_engine-inl.h	/^  static const int kDim = kDimSrc >= 0 ? dim : -1;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDimLhs	include/mshadow/expr_engine-inl.h	/^  static const int kDimLhs = ExpInfo<TA>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDimRhs	include/mshadow/expr_engine-inl.h	/^  static const int kDimRhs = ExpInfo<TB>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::ExpInfo::kDimSrc	include/mshadow/expr_engine-inl.h	/^  static const int kDimSrc = ExpInfo<SrcExp>::kDim;$/;"	m	language:C++	struct:mshadow::expr::ExpInfo	access:public
mshadow::expr::F	include/mshadow/expr_scalar-inl.h	/^F(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
mshadow::expr::F	include/mshadow/expr_scalar-inl.h	/^F(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
mshadow::expr::F	include/mshadow/expression.h	/^F(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
mshadow::expr::F	include/mshadow/expression.h	/^F(const Exp<TA, DType, ta> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &src)
mshadow::expr::GetShape	include/mshadow/dot_engine-inl.h	/^inline static Shape<2> GetShape(const Shape<2> &shape, bool transpose) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Shape<2> &shape, bool transpose)
mshadow::expr::Info	include/mshadow/extension/swapaxis.h	/^  typedef ExpInfo<SrcExp> Info;$/;"	t	language:C++
mshadow::expr::MakeExp	include/mshadow/expression.h	/^MakeExp(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
mshadow::expr::MakeExp	include/mshadow/expression.h	/^MakeExp(const Exp<TA, DType, ta> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &src)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e);$/;"	p	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const MakeTensorExp<T, SrcExp, dim, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const MakeTensorExp<T, SrcExp, dim, DType> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const TransposeExp<T, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TransposeExp<T, DType> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const TypecastExp<DstDType, SrcDType, EType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TypecastExp<DstDType, SrcDType, EType, etype> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^MakePlan(const UnaryMapExp<OP, TA, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const UnaryMapExp<OP, TA, DType, etype> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^inline Plan<ScalarExp<DType>, DType> MakePlan(const ScalarExp<DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<DType> &e)
mshadow::expr::MakePlan	include/mshadow/expr_engine-inl.h	/^inline Plan<T, DType> MakePlan(const RValueExp<T, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<T, DType> &e)
mshadow::expr::MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
mshadow::expr::MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const BinaryMapExp<OP, TA, TB, DType, etype> &e);$/;"	p	language:C++	namespace:mshadow::expr	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &e)
mshadow::expr::MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const MakeTensorExp<T, cpu, dim, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const MakeTensorExp<T, cpu, dim, DType> &e)
mshadow::expr::MakeSSEPlan	include/mshadow/sse-inl.h	/^MakeSSEPlan(const UnaryMapExp<OP, TA, DType, etype> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const UnaryMapExp<OP, TA, DType, etype> &e)
mshadow::expr::MakeSSEPlan	include/mshadow/sse-inl.h	/^inline SSEPlan<ScalarExp<DType>, DType> MakeSSEPlan(const ScalarExp<DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<DType> &e)
mshadow::expr::MakeSSEPlan	include/mshadow/sse-inl.h	/^inline SSEPlan<T, DType> MakeSSEPlan(const RValueExp<T, DType> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<T, DType> &e)
mshadow::expr::MakeTensorExp	include/mshadow/expr_engine-inl.h	/^struct MakeTensorExp$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::MakeTensorExp::real_self	include/mshadow/expr_engine-inl.h	/^  inline const SubType& real_self(void) const{$/;"	f	language:C++	struct:mshadow::expr::MakeTensorExp	access:public	signature:(void) const
mshadow::expr::MakeTensorExp::shape_	include/mshadow/expr_engine-inl.h	/^  Shape<dim> shape_;$/;"	m	language:C++	struct:mshadow::expr::MakeTensorExp	access:public
mshadow::expr::MapSSEPlan	include/mshadow/sse-inl.h	/^inline void MapSSEPlan(Tensor<cpu, dim, DType> _dst,$/;"	f	language:C++	namespace:mshadow::expr	signature:(Tensor<cpu, dim, DType> _dst, const expr::SSEPlan<E, DType> &plan)
mshadow::expr::MirroringExp	include/mshadow/extension/mirror.h	/^struct MirroringExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::MirroringExp::MirroringExp	include/mshadow/extension/mirror.h	/^  explicit MirroringExp(const SrcExp &src) : src_(src) {$/;"	f	language:C++	struct:mshadow::expr::MirroringExp	access:public	signature:(const SrcExp &src)
mshadow::expr::MirroringExp::src_	include/mshadow/extension/mirror.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::MirroringExp	access:public
mshadow::expr::PackColToPatchXExp	include/mshadow/extension/pack_col2patch.h	/^struct PackColToPatchXExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::PackColToPatchXExp::PackColToPatchXExp	include/mshadow/extension/pack_col2patch.h	/^  PackColToPatchXExp(const SrcExp &src, Shape<dstdim> imshape,$/;"	f	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public	signature:(const SrcExp &src, Shape<dstdim> imshape, index_t psize_y, index_t psize_x, index_t pstride)
mshadow::expr::PackColToPatchXExp::o_height	include/mshadow/extension/pack_col2patch.h	/^    const index_t o_height = (imshape[dstdim - 2] - psize_y) \/ pstride + 1;$/;"	l	language:C++
mshadow::expr::PackColToPatchXExp::o_width	include/mshadow/extension/pack_col2patch.h	/^    const index_t o_width  = (imshape[dstdim - 1] - psize_x) \/ pstride + 1;$/;"	l	language:C++
mshadow::expr::PackColToPatchXExp::psize_x_	include/mshadow/extension/pack_col2patch.h	/^  index_t psize_x_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
mshadow::expr::PackColToPatchXExp::psize_y_	include/mshadow/extension/pack_col2patch.h	/^  index_t psize_y_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
mshadow::expr::PackColToPatchXExp::pstride_	include/mshadow/extension/pack_col2patch.h	/^  index_t pstride_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
mshadow::expr::PackColToPatchXExp::src_	include/mshadow/extension/pack_col2patch.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
mshadow::expr::PackColToPatchXExp::sshape	include/mshadow/extension/pack_col2patch.h	/^    Shape<2> sshape = ShapeCheck<2, SrcExp>::Check(src_);$/;"	l	language:C++
mshadow::expr::PackColToPatchXExp::utils::Check	include/mshadow/extension/pack_col2patch.h	/^    utils::Check(sshape[0] == psize_y * psize_x * imshape[dstdim - 3],$/;"	p	language:C++	class:mshadow::expr::PackColToPatchXExp::utils	signature:(sshape[0] == psize_y * psize_x * imshape[dstdim - 3], Ó)
mshadow::expr::PackColToPatchXExp::utils::Check	include/mshadow/extension/pack_col2patch.h	/^    utils::Check(sshape[1] == o_height * o_width *$/;"	p	language:C++	class:mshadow::expr::PackColToPatchXExp::utils	signature:(sshape[1] == o_height * o_width * imshape.ProdShape(0, dstdim - 3), Ó)
mshadow::expr::PaddingExp	include/mshadow/extension/pad.h	/^struct PaddingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::PaddingExp::PaddingExp	include/mshadow/extension/pad.h	/^  PaddingExp(const SrcExp &src, index_t pad_y, index_t pad_x)$/;"	f	language:C++	struct:mshadow::expr::PaddingExp	access:public	signature:(const SrcExp &src, index_t pad_y, index_t pad_x)
mshadow::expr::PaddingExp::pad_x_	include/mshadow/extension/pad.h	/^  index_t pad_x_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
mshadow::expr::PaddingExp::pad_y_	include/mshadow/extension/pad.h	/^  index_t pad_y_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
mshadow::expr::PaddingExp::src_	include/mshadow/extension/pad.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
mshadow::expr::PaddingExp::src_height_	include/mshadow/extension/pad.h	/^  index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
mshadow::expr::PaddingExp::src_width_	include/mshadow/extension/pad.h	/^  index_t src_width_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<BinaryMapExp<OP, TA, TB, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<ScalarExp<DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<Tensor<Device, 1, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<Tensor<Device, dim, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<TransposeExp<EType, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<TypecastExp<DstDType, SrcDType, EType, etype>, DstDType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^class Plan<UnaryMapExp<OP, TA, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/expr_engine-inl.h	/^struct Plan<MakeTensorExp<SubType, SrcExp, dim, DType>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/channel_pool.h	/^struct Plan<ChannelPoolingExp<Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/channel_unpool.h	/^struct Plan<ChannelUnpoolingExp<Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/concat.h	/^struct Plan<ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, 1>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/concat.h	/^struct Plan<ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, dimsrc_m_cat>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/crop.h	/^struct Plan<CroppingExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/mirror.h	/^struct Plan<MirroringExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/pack_col2patch.h	/^struct Plan<PackColToPatchXExp<SrcExp, DType, dstdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/pad.h	/^struct Plan<PaddingExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/reshape.h	/^struct Plan<ReshapeExp<SrcExp, DType, dimdst, 1>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/reshape.h	/^struct Plan<ReshapeExp<SrcExp, DType, dimdst, dimsrc>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/spatial_pool.h	/^struct Plan<PoolingExp< Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/spatial_unpool.h	/^struct Plan<UnPoolingExp<Reducer, SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/swapaxis.h	/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, 1, a2>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/swapaxis.h	/^struct Plan<SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan	include/mshadow/extension/unpack_patch2col.h	/^struct Plan<UnpackPatchToColXExp<SrcExp, DType, srcdim>, DType> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::Plan::Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const;$/;"	p	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DstDType Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE const DType &Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/extension/channel_pool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/channel_unpool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/extension/crop.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/mirror.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/pack_col2patch.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/pad.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/reshape.h	/^  MSHADOW_XINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/extension/spatial_pool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/spatial_unpool.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/swapaxis.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Eval	include/mshadow/extension/swapaxis.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t x) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t x) const
mshadow::expr::Plan::Eval	include/mshadow/extension/unpack_patch2col.h	/^  MSHADOW_XINLINE DType Eval(index_t i, index_t j) const {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j) const
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  Plan(const Plan<SubType, DType> &src) : src_(src) {}$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const Plan<SubType, DType> &src)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(DType scalar) : scalar_(scalar) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(DType scalar)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<EType, DType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<EType, DType> &src)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<EType, SrcDType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<EType, SrcDType> &src)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<TA, DType> &lhs, const Plan<TB, DType> &rhs)$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<TA, DType> &lhs, const Plan<TB, DType> &rhs)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Plan<TA, DType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Plan<TA, DType> &src)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Tensor<Device, 1, DType> &t) : dptr_(t.dptr_) {}$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Tensor<Device, 1, DType> &t)
mshadow::expr::Plan::Plan	include/mshadow/expr_engine-inl.h	/^  explicit Plan(const Tensor<Device, dim, DType> &t)$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(const Tensor<Device, dim, DType> &t)
mshadow::expr::Plan::Plan	include/mshadow/extension/channel_pool.h	/^  explicit Plan(const ChannelPoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ChannelPoolingExp<Reducer, SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/channel_unpool.h	/^  explicit Plan(const ChannelUnpoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ChannelUnpoolingExp<Reducer, SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/concat.h	/^  explicit Plan(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, 1> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, 1> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/concat.h	/^  explicit Plan(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, dimsrc_m_cat> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ConcatExp<LhsExp, RhsExp, Device, DType, srcdim, dimsrc_m_cat> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/crop.h	/^  explicit Plan(const CroppingExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const CroppingExp<SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/mirror.h	/^  explicit Plan(const MirroringExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const MirroringExp<SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/pack_col2patch.h	/^  explicit Plan(const PackColToPatchXExp<SrcExp, DType, dstdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const PackColToPatchXExp<SrcExp, DType, dstdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/pad.h	/^  explicit Plan(const PaddingExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const PaddingExp<SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/reshape.h	/^  explicit Plan(const ReshapeExp<SrcExp, DType, dimdst, 1> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ReshapeExp<SrcExp, DType, dimdst, 1> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/reshape.h	/^  explicit Plan(const ReshapeExp<SrcExp, DType, dimdst, dimsrc> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const ReshapeExp<SrcExp, DType, dimdst, dimsrc> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/spatial_pool.h	/^  explicit Plan(const PoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const PoolingExp<Reducer, SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/spatial_unpool.h	/^  explicit Plan(const UnPoolingExp<Reducer, SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnPoolingExp<Reducer, SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/swapaxis.h	/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, 1, a2> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/swapaxis.h	/^  explicit Plan(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const SwapAxisExp<SrcExp, DType, dimsrc, m_a1, a2> &e)
mshadow::expr::Plan::Plan	include/mshadow/extension/unpack_patch2col.h	/^  explicit Plan(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(const UnpackPatchToColXExp<SrcExp, DType, srcdim> &e)
mshadow::expr::Plan::REval	include/mshadow/expr_engine-inl.h	/^  MSHADOW_XINLINE DType &REval(index_t y, index_t x) {$/;"	f	language:C++	class:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x)
mshadow::expr::Plan::REval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType &REval(index_t i, index_t j) {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t i, index_t j)
mshadow::expr::Plan::REval	include/mshadow/extension/concat.h	/^  MSHADOW_XINLINE DType &REval(index_t y, index_t x) {$/;"	f	language:C++	struct:mshadow::expr::Plan	access:public	signature:(index_t y, index_t x)
mshadow::expr::Plan::Reducer::Reduce	include/mshadow/extension/spatial_pool.h	/^        Reducer::Reduce(res, src_.Eval(c * src_height_ + y, x));$/;"	p	language:C++	class:mshadow::expr::Plan::Reducer	signature:(res, src_.Eval(c * src_height_ + y, x))
mshadow::expr::Plan::Reducer::SetInitValue	include/mshadow/extension/spatial_pool.h	/^    DType res; Reducer::SetInitValue(res);$/;"	p	language:C++	class:mshadow::expr::Plan::Reducer	signature:(res)
mshadow::expr::Plan::a1	include/mshadow/extension/swapaxis.h	/^  static const int a1 = dimsrc - m_a1;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:public
mshadow::expr::Plan::b	include/mshadow/extension/concat.h	/^    const index_t b = i \/ ch_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/channel_pool.h	/^    const index_t c = i % channel_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/channel_unpool.h	/^    const index_t c = i % channel_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/concat.h	/^    const index_t c = i % ch_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/crop.h	/^    const index_t c = i \/ new_height_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/pack_col2patch.h	/^    const index_t c = idivh % i_channel_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/pad.h	/^    const index_t c = i \/ new_height_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/spatial_pool.h	/^    const index_t c = i \/ new_height_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/spatial_unpool.h	/^    const index_t c = i \/ sshape_y_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/swapaxis.h	/^    const index_t c = i % shapec_;$/;"	l	language:C++
mshadow::expr::Plan::c	include/mshadow/extension/unpack_patch2col.h	/^    const index_t c = idivp \/ psize_y_;$/;"	l	language:C++
mshadow::expr::Plan::ch_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::ch_src1_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::ch_src2_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::dimcat	include/mshadow/extension/concat.h	/^  static const int dimcat = srcdim - dimsrc_m_cat;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:public
mshadow::expr::Plan::dptr_	include/mshadow/expr_engine-inl.h	/^  DType  *dptr_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::h	include/mshadow/extension/crop.h	/^    const index_t h = y + pad_height_;$/;"	l	language:C++
mshadow::expr::Plan::h	include/mshadow/extension/pad.h	/^    const index_t h = y - pad_y_;$/;"	l	language:C++
mshadow::expr::Plan::height_	include/mshadow/extension/concat.h	/^  const index_t height_, ch_src1_, ch_src2_, ch_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::i_channel_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::i_height_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::i_width_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::idivh	include/mshadow/extension/pack_col2patch.h	/^    const index_t idivh = i \/ i_height_;$/;"	l	language:C++
mshadow::expr::Plan::idivp	include/mshadow/extension/unpack_patch2col.h	/^    const index_t idivp    = i \/ psize_x_;$/;"	l	language:C++
mshadow::expr::Plan::idx	include/mshadow/extension/reshape.h	/^    const index_t idx = y * oshapex_ + x;$/;"	l	language:C++
mshadow::expr::Plan::ishapex_	include/mshadow/extension/reshape.h	/^  const index_t oshapex_, ishapex_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::jdivw	include/mshadow/extension/unpack_patch2col.h	/^    const index_t jdivw = j \/ o_width_;$/;"	l	language:C++
mshadow::expr::Plan::ksize_x_	include/mshadow/extension/spatial_pool.h	/^  const index_t ksize_y_, ksize_x_, kstride_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::ksize_y_	include/mshadow/extension/spatial_pool.h	/^  const index_t ksize_y_, ksize_x_, kstride_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::kstride_	include/mshadow/extension/spatial_pool.h	/^  const index_t ksize_y_, ksize_x_, kstride_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::lhs_	include/mshadow/expr_engine-inl.h	/^  Plan<TA, DType> lhs_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::n	include/mshadow/extension/channel_pool.h	/^    const index_t n = i \/ channel_;$/;"	l	language:C++
mshadow::expr::Plan::n	include/mshadow/extension/channel_unpool.h	/^    const index_t n = i \/ channel_;$/;"	l	language:C++
mshadow::expr::Plan::n	include/mshadow/extension/pack_col2patch.h	/^    const index_t n = idivh \/ i_channel_;$/;"	l	language:C++
mshadow::expr::Plan::n	include/mshadow/extension/swapaxis.h	/^    const index_t n = i % shapen_;$/;"	l	language:C++
mshadow::expr::Plan::n	include/mshadow/extension/swapaxis.h	/^    const index_t n = i \/ shapez_;$/;"	l	language:C++
mshadow::expr::Plan::n	include/mshadow/extension/unpack_patch2col.h	/^    const index_t n = jdivw \/ o_height_;$/;"	l	language:C++
mshadow::expr::Plan::new_height_	include/mshadow/extension/crop.h	/^  const index_t new_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::new_height_	include/mshadow/extension/pad.h	/^  const index_t new_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::new_height_	include/mshadow/extension/spatial_pool.h	/^  const index_t new_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::o_height_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::o_width_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::oshapex_	include/mshadow/extension/reshape.h	/^  const index_t oshapex_, ishapex_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::oshapex_	include/mshadow/extension/reshape.h	/^  const index_t oshapex_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::pad_height_	include/mshadow/extension/crop.h	/^  const index_t pad_height_, pad_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::pad_width_	include/mshadow/extension/crop.h	/^  const index_t pad_height_, pad_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::pad_x_	include/mshadow/extension/pad.h	/^  const index_t pad_x_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::pad_y_	include/mshadow/extension/pad.h	/^  const index_t pad_y_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::psize_x_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::psize_y_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::pstride_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::px	include/mshadow/extension/spatial_pool.h	/^    const index_t px = j;$/;"	l	language:C++
mshadow::expr::Plan::py	include/mshadow/extension/spatial_pool.h	/^    const index_t py = i % new_height_;$/;"	l	language:C++
mshadow::expr::Plan::res	include/mshadow/extension/spatial_pool.h	/^    DType res; Reducer::SetInitValue(res);$/;"	l	language:C++
mshadow::expr::Plan::rhs_	include/mshadow/expr_engine-inl.h	/^  Plan<TB, DType> rhs_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::scalar_	include/mshadow/expr_engine-inl.h	/^  DType scalar_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapec_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapen_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapex_	include/mshadow/extension/swapaxis.h	/^  const index_t shapex_, shapey_, shapez_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapey_	include/mshadow/extension/swapaxis.h	/^  const index_t shapex_, shapey_, shapez_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapey_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapez_	include/mshadow/extension/swapaxis.h	/^  const index_t shapex_, shapey_, shapez_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::shapez_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src1_	include/mshadow/extension/concat.h	/^  Plan<LhsExp, DType> src1_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src2_	include/mshadow/extension/concat.h	/^  Plan<RhsExp, DType> src2_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/expr_engine-inl.h	/^  Plan<EType, DType> src_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/expr_engine-inl.h	/^  Plan<EType, SrcDType> src_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/expr_engine-inl.h	/^  Plan<SubType, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/expr_engine-inl.h	/^  Plan<TA, DType> src_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/crop.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/mirror.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/pad.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/reshape.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/spatial_pool.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/swapaxis.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_	include/mshadow/extension/unpack_patch2col.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_height_	include/mshadow/extension/crop.h	/^  const index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_height_	include/mshadow/extension/pad.h	/^  const index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_height_	include/mshadow/extension/spatial_pool.h	/^  const index_t src_height_, src_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_width_	include/mshadow/extension/pad.h	/^  const index_t src_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::src_width_	include/mshadow/extension/spatial_pool.h	/^  const index_t src_height_, src_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::stride_	include/mshadow/expr_engine-inl.h	/^  index_t stride_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
mshadow::expr::Plan::vsrc	include/mshadow/extension/channel_unpool.h	/^    const DType vsrc = data_src_.Eval(i, j);$/;"	l	language:C++
mshadow::expr::Plan::vsrc	include/mshadow/extension/spatial_unpool.h	/^    const DType vsrc = data_src_.Eval(i, j);$/;"	l	language:C++
mshadow::expr::Plan::w	include/mshadow/extension/crop.h	/^    const index_t w = x + pad_width_;$/;"	l	language:C++
mshadow::expr::Plan::w	include/mshadow/extension/pad.h	/^    const index_t w = x - pad_x_;$/;"	l	language:C++
mshadow::expr::Plan::width_	include/mshadow/extension/mirror.h	/^  const index_t width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::width_src1_	include/mshadow/extension/concat.h	/^  const index_t width_src1_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
mshadow::expr::Plan::x	include/mshadow/extension/channel_pool.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/channel_unpool.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/concat.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/crop.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/pack_col2patch.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/pad.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/spatial_unpool.h	/^    const index_t x = j;$/;"	l	language:C++
mshadow::expr::Plan::x	include/mshadow/extension/unpack_patch2col.h	/^    const index_t x = (j % o_width_) * pstride_ + x_offset;$/;"	l	language:C++
mshadow::expr::Plan::x_end	include/mshadow/extension/spatial_pool.h	/^    const index_t x_end = min(x_start + ksize_x_, src_width_);$/;"	l	language:C++
mshadow::expr::Plan::x_offset	include/mshadow/extension/unpack_patch2col.h	/^    const index_t x_offset = i % psize_x_;$/;"	l	language:C++
mshadow::expr::Plan::x_start	include/mshadow/extension/spatial_pool.h	/^    const index_t x_start = px * kstride_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/channel_pool.h	/^    const index_t y = i % height_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/channel_unpool.h	/^    const index_t y = i % height_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/concat.h	/^    const index_t y = i % height_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/crop.h	/^    const index_t y = i % new_height_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/pack_col2patch.h	/^    const index_t y = i % i_height_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/pad.h	/^    const index_t y = i % new_height_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/spatial_unpool.h	/^    const index_t y = i % sshape_y_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/swapaxis.h	/^    const index_t y = i % shapey_;$/;"	l	language:C++
mshadow::expr::Plan::y	include/mshadow/extension/unpack_patch2col.h	/^    const index_t y = (jdivw % o_height_) * pstride_ + y_offset;$/;"	l	language:C++
mshadow::expr::Plan::y_end	include/mshadow/extension/spatial_pool.h	/^    const index_t y_end = min(y_start + ksize_y_, src_height_);$/;"	l	language:C++
mshadow::expr::Plan::y_offset	include/mshadow/extension/unpack_patch2col.h	/^    const index_t y_offset = idivp % psize_y_;$/;"	l	language:C++
mshadow::expr::Plan::y_start	include/mshadow/extension/spatial_pool.h	/^    const index_t y_start = py * kstride_;$/;"	l	language:C++
mshadow::expr::Plan::z	include/mshadow/extension/swapaxis.h	/^    const index_t z = i % shapez_;$/;"	l	language:C++
mshadow::expr::PoolingExp	include/mshadow/extension/spatial_pool.h	/^struct PoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::PoolingExp::PoolingExp	include/mshadow/extension/spatial_pool.h	/^  PoolingExp(const SrcExp &src, Shape<2> pshape,$/;"	f	language:C++	struct:mshadow::expr::PoolingExp	access:public	signature:(const SrcExp &src, Shape<2> pshape, index_t ksize_y, index_t ksize_x, index_t kstride)
mshadow::expr::PoolingExp::PoolingExp	include/mshadow/extension/spatial_pool.h	/^  PoolingExp(const SrcExp &src,$/;"	f	language:C++	struct:mshadow::expr::PoolingExp	access:public	signature:(const SrcExp &src, index_t ksize_y, index_t ksize_x, index_t kstride)
mshadow::expr::PoolingExp::ksize_x_	include/mshadow/extension/spatial_pool.h	/^  index_t ksize_x_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
mshadow::expr::PoolingExp::ksize_y_	include/mshadow/extension/spatial_pool.h	/^  index_t ksize_y_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
mshadow::expr::PoolingExp::kstride_	include/mshadow/extension/spatial_pool.h	/^  index_t kstride_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
mshadow::expr::PoolingExp::src_	include/mshadow/extension/spatial_pool.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
mshadow::expr::PoolingExp::src_height_	include/mshadow/extension/spatial_pool.h	/^  index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
mshadow::expr::PoolingExp::src_width_	include/mshadow/extension/spatial_pool.h	/^  index_t src_width_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
mshadow::expr::PoolingExp::sshape	include/mshadow/extension/spatial_pool.h	/^    Shape<srcdim> sshape = ShapeCheck<srcdim, SrcExp>::Check(src_);$/;"	l	language:C++
mshadow::expr::RValueExp	include/mshadow/expression.h	/^class RValueExp: public Exp<Container, DType, type::kRValue> {$/;"	c	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::divto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::divto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::minusto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::minusto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::multo, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::multo, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::plusto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::plusto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::saveto, Container, DType>::Eval(this->ptrself(), exp.self());$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), exp.self())
mshadow::expr::RValueExp::ExpEngine::Eval	include/mshadow/expression.h	/^    ExpEngine<sv::saveto, Container, DType>::Eval(this->ptrself(), scalar<DType>(s));$/;"	p	language:C++	class:mshadow::expr::RValueExp::ExpEngine	signature:(this->ptrself(), scalar<DType>(s))
mshadow::expr::RValueExp::T	include/mshadow/expression.h	/^  inline const TransposeExp<Container, DType> T(void) const {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(void) const
mshadow::expr::RValueExp::__assign	include/mshadow/expression.h	/^  inline Container &__assign(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
mshadow::expr::RValueExp::__assign	include/mshadow/expression.h	/^  inline Container &__assign(const Exp<Container, DType, type::kRValue> &exp);$/;"	p	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<Container, DType, type::kRValue> &exp)
mshadow::expr::RValueExp::__assign	include/mshadow/expression.h	/^  inline Container &__assign(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
mshadow::expr::RValueExp::operator *=	include/mshadow/expression.h	/^  inline Container &operator*=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
mshadow::expr::RValueExp::operator *=	include/mshadow/expression.h	/^  inline Container &operator*=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
mshadow::expr::RValueExp::operator +=	include/mshadow/expression.h	/^  inline Container &operator+=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
mshadow::expr::RValueExp::operator +=	include/mshadow/expression.h	/^  inline Container &operator+=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
mshadow::expr::RValueExp::operator -=	include/mshadow/expression.h	/^  inline Container &operator-=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
mshadow::expr::RValueExp::operator -=	include/mshadow/expression.h	/^  inline Container &operator-=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
mshadow::expr::RValueExp::operator /=	include/mshadow/expression.h	/^  inline Container &operator\/=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
mshadow::expr::RValueExp::operator /=	include/mshadow/expression.h	/^  inline Container &operator\/=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
mshadow::expr::ReduceTo1DExp	include/mshadow/extension/reduceto1d.h	/^struct ReduceTo1DExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::ReduceTo1DExp::ReduceTo1DExp	include/mshadow/extension/reduceto1d.h	/^  ReduceTo1DExp(const SrcExp& src, DType scale) : src_(src), scale_(scale) {}$/;"	f	language:C++	struct:mshadow::expr::ReduceTo1DExp	access:public	signature:(const SrcExp& src, DType scale)
mshadow::expr::ReduceTo1DExp::scale_	include/mshadow/extension/reduceto1d.h	/^  DType scale_;$/;"	m	language:C++	struct:mshadow::expr::ReduceTo1DExp	access:public
mshadow::expr::ReduceTo1DExp::src_	include/mshadow/extension/reduceto1d.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::ReduceTo1DExp	access:public
mshadow::expr::ReshapeExp	include/mshadow/extension/reshape.h	/^struct ReshapeExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::ReshapeExp::ReshapeExp	include/mshadow/extension/reshape.h	/^  ReshapeExp(const SrcExp &src, Shape<dimdst> shape)$/;"	f	language:C++	struct:mshadow::expr::ReshapeExp	access:public	signature:(const SrcExp &src, Shape<dimdst> shape)
mshadow::expr::ReshapeExp::ishape	include/mshadow/extension/reshape.h	/^    Shape<dimsrc> ishape = ShapeCheck<dimsrc, SrcExp>::Check(src_);$/;"	l	language:C++
mshadow::expr::ReshapeExp::ishapex_	include/mshadow/extension/reshape.h	/^  index_t ishapex_;$/;"	m	language:C++	struct:mshadow::expr::ReshapeExp	access:public
mshadow::expr::ReshapeExp::src_	include/mshadow/extension/reshape.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::ReshapeExp	access:public
mshadow::expr::ReshapeExp::utils::Check	include/mshadow/extension/reshape.h	/^    utils::Check(ishape.Size() == shape.Size(), "reshape size must match");$/;"	p	language:C++	class:mshadow::expr::ReshapeExp::utils	signature:(ishape.Size() == shape.Size(), Ó)
mshadow::expr::SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, Tensor<cpu, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSEAlignCheck	include/mshadow/sse-inl.h	/^struct SSEAlignCheck<dim, UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSEAlignCheck::Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const BinaryMapExp<OP, TA, TB, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &t)
mshadow::expr::SSEAlignCheck::Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const E &exp) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const E &exp)
mshadow::expr::SSEAlignCheck::Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const ScalarExp<DType> &exp) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const ScalarExp<DType> &exp)
mshadow::expr::SSEAlignCheck::Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const Tensor<cpu, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const Tensor<cpu, dim, DType> &t)
mshadow::expr::SSEAlignCheck::Check	include/mshadow/sse-inl.h	/^  inline static bool Check(const UnaryMapExp<OP, TA, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::SSEAlignCheck	access:public	signature:(const UnaryMapExp<OP, TA, DType, etype> &t)
mshadow::expr::SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck< BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck<ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck<Tensor<cpu, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck<UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSECheck	include/mshadow/sse-inl.h	/^struct SSECheck{$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::SSECheck::kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = SSECheck<TA>::kPass && sse2::SSEOp<OP>::kEnabled;$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
mshadow::expr::SSECheck::kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = SSECheck<TA>::kPass &&$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
mshadow::expr::SSECheck::kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = false;$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
mshadow::expr::SSECheck::kPass	include/mshadow/sse-inl.h	/^  static const bool kPass = sse2::FVec<DType>::kEnabled;$/;"	m	language:C++	struct:mshadow::expr::SSECheck	access:public
mshadow::expr::SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<BinaryMapExp<OP, TA, TB, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<ScalarExp<DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<Tensor<Device, dim, DType>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::SSEPlan	include/mshadow/sse-inl.h	/^class SSEPlan<UnaryMapExp<OP, TA, DType, etype>, DType> {$/;"	c	language:C++	namespace:mshadow::expr
mshadow::expr::SSEPlan::Eval	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE DType Eval(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::SSEPlan::Eval	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE DType Eval(index_t y, index_t x) const;$/;"	p	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::SSEPlan::EvalSSE	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE sse2::FVec<DType> EvalSSE(index_t y, index_t x) const {$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::SSEPlan::EvalSSE	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE sse2::FVec<DType> EvalSSE(index_t y, index_t x) const;$/;"	p	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(index_t y, index_t x) const
mshadow::expr::SSEPlan::SSEPlan	include/mshadow/sse-inl.h	/^  SSEPlan(const SSEPlan<TA, DType> &lhs, const SSEPlan<TB, DType> &rhs)$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(const SSEPlan<TA, DType> &lhs, const SSEPlan<TB, DType> &rhs)
mshadow::expr::SSEPlan::SSEPlan	include/mshadow/sse-inl.h	/^  SSEPlan(const SSEPlan<TA, DType> &src) : src_(src) {}$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(const SSEPlan<TA, DType> &src)
mshadow::expr::SSEPlan::SSEPlan	include/mshadow/sse-inl.h	/^  explicit SSEPlan(DType scalar) : scalar_(scalar) {}$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(DType scalar)
mshadow::expr::SSEPlan::SSEPlan	include/mshadow/sse-inl.h	/^  explicit SSEPlan(const Tensor<Device, dim, DType> &t)$/;"	f	language:C++	class:mshadow::expr::SSEPlan	access:public	signature:(const Tensor<Device, dim, DType> &t)
mshadow::expr::SSEPlan::dptr_	include/mshadow/sse-inl.h	/^  const DType  *dptr_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
mshadow::expr::SSEPlan::lhs_	include/mshadow/sse-inl.h	/^  SSEPlan<TA, DType> lhs_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
mshadow::expr::SSEPlan::rhs_	include/mshadow/sse-inl.h	/^  SSEPlan<TB, DType> rhs_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
mshadow::expr::SSEPlan::scalar_	include/mshadow/sse-inl.h	/^  DType scalar_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
mshadow::expr::SSEPlan::src_	include/mshadow/sse-inl.h	/^  SSEPlan<TA, DType> src_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
mshadow::expr::SSEPlan::stride_	include/mshadow/sse-inl.h	/^  index_t stride_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
mshadow::expr::SV::Save	include/mshadow/sse-inl.h	/^      SV::Save(dst[y][x], plan.Eval(y, x));$/;"	p	language:C++	class:mshadow::expr::SV	signature:(dst[y][x], plan.Eval(y, x))
mshadow::expr::ScalarExp	include/mshadow/expression.h	/^struct ScalarExp: public Exp<ScalarExp<DType>, DType, type::kMapper> {$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::ScalarExp::ScalarExp	include/mshadow/expression.h	/^  ScalarExp(DType scalar) : scalar_(scalar) {}  \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::expr::ScalarExp	access:public	signature:(DType scalar)
mshadow::expr::ScalarExp::scalar_	include/mshadow/expression.h	/^  DType scalar_;$/;"	m	language:C++	struct:mshadow::expr::ScalarExp	access:public
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, BinaryMapExp<OP, TA, TB, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, MakeTensorExp<T, SrcExp, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, ScalarExp<DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, Tensor<Device, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, TransposeExp<E, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, TypecastExp<DstDType, SrcDType, EType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck	include/mshadow/expr_engine-inl.h	/^struct ShapeCheck<dim, UnaryMapExp<OP, TA, DType, etype> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  Check(const BinaryMapExp<OP, TA, TB, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const BinaryMapExp<OP, TA, TB, DType, etype> &t)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  Check(const MakeTensorExp<T, SrcExp, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const MakeTensorExp<T, SrcExp, dim, DType> &t)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  Check(const TypecastExp<DstDType, SrcDType, EType, etype> &exp) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const TypecastExp<DstDType, SrcDType, EType, etype> &exp)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const E &t);$/;"	p	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const E &t)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const ScalarExp<DType> &exp) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const ScalarExp<DType> &exp)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const Tensor<Device, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const Tensor<Device, dim, DType> &t)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const TransposeExp<E, DType> &e) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const TransposeExp<E, DType> &e)
mshadow::expr::ShapeCheck::Check	include/mshadow/expr_engine-inl.h	/^  inline static Shape<dim> Check(const UnaryMapExp<OP, TA, DType, etype> &t) {$/;"	f	language:C++	struct:mshadow::expr::ShapeCheck	access:public	signature:(const UnaryMapExp<OP, TA, DType, etype> &t)
mshadow::expr::ShapeCheck::s	include/mshadow/expr_engine-inl.h	/^    Shape<dim> s = ShapeCheck<dim, E>::Check(e.exp);$/;"	l	language:C++
mshadow::expr::ShapeCheck::s	include/mshadow/expr_engine-inl.h	/^    Shape<dim> s = ShapeCheck<dim, TA>::Check(t.src_);$/;"	l	language:C++
mshadow::expr::ShapeCheck::shape	include/mshadow/expr_engine-inl.h	/^    Shape<dim> shape; shape[0] = 0;$/;"	l	language:C++
mshadow::expr::ShapeCheck::shape1	include/mshadow/expr_engine-inl.h	/^    Shape<dim> shape1 = ShapeCheck<dim, TA>::Check(t.lhs_);$/;"	l	language:C++
mshadow::expr::ShapeCheck::shape2	include/mshadow/expr_engine-inl.h	/^    Shape<dim> shape2 = ShapeCheck<dim, TB>::Check(t.rhs_);$/;"	l	language:C++
mshadow::expr::ShapeCheck::std::swap	include/mshadow/expr_engine-inl.h	/^    std::swap(s[0], s[1]);$/;"	p	language:C++	class:mshadow::expr::ShapeCheck::std	signature:(s[0], s[1])
mshadow::expr::StreamInfo	include/mshadow/expr_engine-inl.h	/^struct StreamInfo {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::StreamInfo	include/mshadow/expr_engine-inl.h	/^struct StreamInfo<Device, Tensor<Device, dim, DType> > {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::StreamInfo::Get	include/mshadow/expr_engine-inl.h	/^  inline static Stream<Device> *Get(const E &t);$/;"	p	language:C++	struct:mshadow::expr::StreamInfo	access:public	signature:(const E &t)
mshadow::expr::StreamInfo::Get	include/mshadow/expr_engine-inl.h	/^  inline static Stream<Device> *Get(const Tensor<Device, dim, DType> &t) {$/;"	f	language:C++	struct:mshadow::expr::StreamInfo	access:public	signature:(const Tensor<Device, dim, DType> &t)
mshadow::expr::SwapAxisExp	include/mshadow/extension/swapaxis.h	/^struct SwapAxisExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::SwapAxisExp::SwapAxisExp	include/mshadow/extension/swapaxis.h	/^  explicit SwapAxisExp(const SrcExp &src) : src_(src) {$/;"	f	language:C++	struct:mshadow::expr::SwapAxisExp	access:public	signature:(const SrcExp &src)
mshadow::expr::SwapAxisExp::a1	include/mshadow/extension/swapaxis.h	/^  static const int a1 = dimsrc - m_a1;$/;"	m	language:C++	struct:mshadow::expr::SwapAxisExp	access:public
mshadow::expr::SwapAxisExp::src_	include/mshadow/extension/swapaxis.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::SwapAxisExp	access:public
mshadow::expr::SwapAxisExp::std::swap	include/mshadow/extension/swapaxis.h	/^    std::swap(this->shape_[a1], this->shape_[a2]);$/;"	p	language:C++	class:mshadow::expr::SwapAxisExp::std	signature:(this->shape_[a1], this->shape_[a2])
mshadow::expr::TransposeExp	include/mshadow/expression.h	/^struct TransposeExp: public Exp<TransposeExp<EType, DType>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::TransposeExp::T	include/mshadow/expression.h	/^  inline const EType &T(void) const {$/;"	f	language:C++	struct:mshadow::expr::TransposeExp	access:public	signature:(void) const
mshadow::expr::TransposeExp::TransposeExp	include/mshadow/expression.h	/^  explicit TransposeExp(const EType &e) : exp(e) {}$/;"	f	language:C++	struct:mshadow::expr::TransposeExp	access:public	signature:(const EType &e)
mshadow::expr::TransposeExp::exp	include/mshadow/expression.h	/^  const EType &exp;$/;"	m	language:C++	struct:mshadow::expr::TransposeExp	access:public
mshadow::expr::TypeCheck	include/mshadow/expr_engine-inl.h	/^struct TypeCheck {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::TypeCheck::kDevPass	include/mshadow/expr_engine-inl.h	/^  static const bool kDevPass = (ExpInfo<E>::kDevMask & Device::kDevMask) != 0;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
mshadow::expr::TypeCheck::kExpDim	include/mshadow/expr_engine-inl.h	/^  static const int kExpDim = ExpInfo<E>::kDim;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
mshadow::expr::TypeCheck::kMapPass	include/mshadow/expr_engine-inl.h	/^  static const bool kMapPass = (kExpDim == 0 || kExpDim == dim) && kDevPass;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
mshadow::expr::TypeCheck::kRedPass	include/mshadow/expr_engine-inl.h	/^  static const bool kRedPass = (kExpDim > dim) && kDevPass;$/;"	m	language:C++	struct:mshadow::expr::TypeCheck	access:public
mshadow::expr::TypeCheckPass	include/mshadow/expr_engine-inl.h	/^struct TypeCheckPass;$/;"	x	language:C++
mshadow::expr::TypeCheckPass	include/mshadow/expr_engine-inl.h	/^struct TypeCheckPass<false> {};$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::TypeCheckPass	include/mshadow/expr_engine-inl.h	/^struct TypeCheckPass<true> {$/;"	s	language:C++	namespace:mshadow::expr
mshadow::expr::TypeCheckPass::Error_All_Tensor_in_Exp_Must_Have_Same_Type	include/mshadow/expr_engine-inl.h	/^  inline static void Error_All_Tensor_in_Exp_Must_Have_Same_Type(void) {}$/;"	f	language:C++	struct:mshadow::expr::TypeCheckPass	access:public	signature:(void)
mshadow::expr::TypeCheckPass::Error_All_Tensor_in_Exp_Must_Have_Same_Type	include/mshadow/tensor_cpu-inl.h	/^      ::Error_All_Tensor_in_Exp_Must_Have_Same_Type();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypeCheckPass::Error_All_Tensor_in_Exp_Must_Have_Same_Type	include/mshadow/tensor_gpu-inl.h	/^      ::Error_All_Tensor_in_Exp_Must_Have_Same_Type();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypeCheckPass::Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/expr_engine-inl.h	/^  inline static void Error_Expression_Does_Not_Meet_Dimension_Req(void) {}$/;"	f	language:C++	struct:mshadow::expr::TypeCheckPass	access:public	signature:(void)
mshadow::expr::TypeCheckPass::Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/concat.h	/^      ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypeCheckPass::Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/pack_col2patch.h	/^      ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypeCheckPass::Error_Expression_Does_Not_Meet_Dimension_Req	include/mshadow/extension/reduceto1d.h	/^      ::Error_Expression_Does_Not_Meet_Dimension_Req();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypeCheckPass::Error_TypeCheck_Not_Pass_For_Reduce_Exp	include/mshadow/expr_engine-inl.h	/^  inline static void Error_TypeCheck_Not_Pass_For_Reduce_Exp(void) {}$/;"	f	language:C++	struct:mshadow::expr::TypeCheckPass	access:public	signature:(void)
mshadow::expr::TypeCheckPass::Error_TypeCheck_Not_Pass_For_Reduce_Exp	include/mshadow/tensor_cpu-inl.h	/^      ::Error_TypeCheck_Not_Pass_For_Reduce_Exp();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypeCheckPass::Error_TypeCheck_Not_Pass_For_Reduce_Exp	include/mshadow/tensor_gpu-inl.h	/^      ::Error_TypeCheck_Not_Pass_For_Reduce_Exp();$/;"	p	language:C++	class:mshadow::expr::TypeCheckPass	signature:()
mshadow::expr::TypecastExp	include/mshadow/expression.h	/^struct TypecastExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::TypecastExp::TypecastExp	include/mshadow/expression.h	/^  explicit TypecastExp(const EType &e) : exp(e) {}$/;"	f	language:C++	struct:mshadow::expr::TypecastExp	access:public	signature:(const EType &e)
mshadow::expr::TypecastExp::exp	include/mshadow/expression.h	/^  const EType &exp;$/;"	m	language:C++	struct:mshadow::expr::TypecastExp	access:public
mshadow::expr::UnPoolingExp	include/mshadow/extension/spatial_unpool.h	/^struct UnPoolingExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::UnPoolingExp::UnPoolingExp	include/mshadow/extension/spatial_unpool.h	/^  UnPoolingExp(const SrcExp &data_src,$/;"	f	language:C++	struct:mshadow::expr::UnPoolingExp	access:public	signature:(const SrcExp &data_src, const SrcExp &data_pooled, const SrcExp &grad_pooled, index_t ksize_y, index_t ksize_x, index_t kstride)
mshadow::expr::UnPoolingExp::data_pooled_	include/mshadow/extension/spatial_unpool.h	/^  const SrcExp &data_pooled_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::data_src_	include/mshadow/extension/spatial_unpool.h	/^  const SrcExp &data_src_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::grad_pooled_	include/mshadow/extension/spatial_unpool.h	/^  const SrcExp &grad_pooled_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::ksize_x_	include/mshadow/extension/spatial_unpool.h	/^  index_t ksize_x_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::ksize_y_	include/mshadow/extension/spatial_unpool.h	/^  index_t ksize_y_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::kstride_	include/mshadow/extension/spatial_unpool.h	/^  index_t kstride_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::pshape	include/mshadow/extension/spatial_unpool.h	/^    Shape<srcdim> pshape = ShapeCheck<srcdim, SrcExp>::Check(grad_pooled);$/;"	l	language:C++
mshadow::expr::UnPoolingExp::pshape_x_	include/mshadow/extension/spatial_unpool.h	/^  index_t pshape_x_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::pshape_y_	include/mshadow/extension/spatial_unpool.h	/^  index_t pshape_y_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
mshadow::expr::UnPoolingExp::sshape	include/mshadow/extension/spatial_unpool.h	/^    Shape<srcdim> sshape = ShapeCheck<srcdim, SrcExp>::Check(data_src);$/;"	l	language:C++
mshadow::expr::UnPoolingExp::utils::Check	include/mshadow/extension/spatial_unpool.h	/^      utils::Check(pshape[k] == sshape[k],$/;"	p	language:C++	class:mshadow::expr::UnPoolingExp::utils	signature:(pshape[k] == sshape[k], Ó)
mshadow::expr::UnPoolingExp::utils::Check	include/mshadow/extension/spatial_unpool.h	/^    utils::Check(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled),$/;"	p	language:C++	class:mshadow::expr::UnPoolingExp::utils	signature:(pshape == ShapeCheck<srcdim, SrcExp>::Check(data_pooled), Ó)
mshadow::expr::UnaryMapExp	include/mshadow/expression.h	/^struct UnaryMapExp: public Exp<UnaryMapExp<OP, TA, DType, etype>,$/;"	s	language:C++	namespace:mshadow::expr	inherits:Exp
mshadow::expr::UnaryMapExp::UnaryMapExp	include/mshadow/expression.h	/^  explicit UnaryMapExp(const TA &src) : src_(src) {}$/;"	f	language:C++	struct:mshadow::expr::UnaryMapExp	access:public	signature:(const TA &src)
mshadow::expr::UnaryMapExp::src_	include/mshadow/expression.h	/^  const TA &src_;$/;"	m	language:C++	struct:mshadow::expr::UnaryMapExp	access:public
mshadow::expr::UnpackPatchToColXExp	include/mshadow/extension/unpack_patch2col.h	/^struct UnpackPatchToColXExp:$/;"	s	language:C++	namespace:mshadow::expr	inherits:MakeTensorExp
mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include/mshadow/extension/unpack_patch2col.h	/^  UnpackPatchToColXExp(const SrcExp &img,$/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)
mshadow::expr::UnpackPatchToColXExp::i_channel_	include/mshadow/extension/unpack_patch2col.h	/^  index_t i_channel_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::UnpackPatchToColXExp::i_height_	include/mshadow/extension/unpack_patch2col.h	/^  index_t i_height_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::UnpackPatchToColXExp::i_width_	include/mshadow/extension/unpack_patch2col.h	/^  index_t i_width_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::UnpackPatchToColXExp::img_	include/mshadow/extension/unpack_patch2col.h	/^  const SrcExp &img_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::UnpackPatchToColXExp::imshape	include/mshadow/extension/unpack_patch2col.h	/^    Shape<srcdim> imshape = ShapeCheck<srcdim, SrcExp>::Check(img_);$/;"	l	language:C++
mshadow::expr::UnpackPatchToColXExp::num	include/mshadow/extension/unpack_patch2col.h	/^    const index_t num = imshape.ProdShape(0, srcdim - 3);$/;"	l	language:C++
mshadow::expr::UnpackPatchToColXExp::o_height	include/mshadow/extension/unpack_patch2col.h	/^    const index_t o_height = (i_height_ - psize_y) \/ pstride + 1;$/;"	l	language:C++
mshadow::expr::UnpackPatchToColXExp::o_width	include/mshadow/extension/unpack_patch2col.h	/^    const index_t o_width  = (i_width_  - psize_x) \/ pstride + 1;$/;"	l	language:C++
mshadow::expr::UnpackPatchToColXExp::psize_x_	include/mshadow/extension/unpack_patch2col.h	/^  index_t psize_x_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::UnpackPatchToColXExp::psize_y_	include/mshadow/extension/unpack_patch2col.h	/^  index_t psize_y_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::UnpackPatchToColXExp::pstride_	include/mshadow/extension/unpack_patch2col.h	/^  index_t pstride_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
mshadow::expr::broadcast	include/mshadow/extension/broadcast.h	/^broadcast(const expr::Exp<SrcExp, DType, etype> &src, Shape<dimdst> shape) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const expr::Exp<SrcExp, DType, etype> &src, Shape<dimdst> shape)
mshadow::expr::ch_unpool	include/mshadow/extension/channel_unpool.h	/^ch_unpool(const Exp<SrcExp, DType, etype> &data_src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &data_src, const Exp<SrcExp, DType, etype> &data_pooled, const Exp<SrcExp, DType, etype> &grad_pooled, index_t nsize)
mshadow::expr::ch_unpool	include/mshadow/extension/channel_unpool.h	/^ch_unpool(const Exp<SrcExp, DType, etype> &data_src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &data_src, const Exp<SrcExp, DType, etype> &data_pooled, const Exp<SrcExp, DType, etype> &grad_pooled, index_t nsize, index_t stride, index_t pad)
mshadow::expr::chpool	include/mshadow/extension/channel_pool.h	/^chpool(const Exp<SrcExp, DType, etype> &src, index_t nsize) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t nsize)
mshadow::expr::chpool	include/mshadow/extension/channel_pool.h	/^chpool(const Exp<SrcExp, DType, etype> &src, index_t nsize, index_t stride, index_t pad) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t nsize, index_t stride, index_t pad)
mshadow::expr::concat	include/mshadow/extension/concat.h	/^concat(const TRValue<LhsExp, Device, srcdim, DType> &src1,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TRValue<LhsExp, Device, srcdim, DType> &src1, const TRValue<RhsExp, Device, srcdim, DType> &src2)
mshadow::expr::crop	include/mshadow/extension/crop.h	/^crop(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape)
mshadow::expr::crop	include/mshadow/extension/crop.h	/^crop(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<2> oshape, index_t start_height, index_t start_width)
mshadow::expr::dot	include/mshadow/expression.h	/^dot(const RValueExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs)
mshadow::expr::dot	include/mshadow/expression.h	/^dot(const RValueExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const RValueExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs)
mshadow::expr::dot	include/mshadow/expression.h	/^dot(const TransposeExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TransposeExp<TA, DType> &lhs, const RValueExp<TB, DType> &rhs)
mshadow::expr::dot	include/mshadow/expression.h	/^dot(const TransposeExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const TransposeExp<TA, DType> &lhs, const TransposeExp<TB, DType> &rhs)
mshadow::expr::dst	include/mshadow/sse-inl.h	/^  Tensor<cpu, 2, DType> dst = _dst.FlatTo2D();$/;"	l	language:C++
mshadow::expr::kDevMask	include/mshadow/extension/concat.h	/^  static const int kDevMask = ExpInfo<LhsExp>::kDevMask & ExpInfo<RhsExp>::kDevMask;$/;"	l	language:C++
mshadow::expr::mirror	include/mshadow/extension/mirror.h	/^mirror(const Exp<SrcExp, DType, etype> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src)
mshadow::expr::operator *	include/mshadow/expr_scalar-inl.h	/^operator*(MSHADOW_SCALAR_ lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(MSHADOW_SCALAR_ lhs, const DotExp<TA, TB, ltrans, rtrans, MSHADOW_SCALAR_> &rhs)
mshadow::expr::operator *	include/mshadow/expr_scalar-inl.h	/^operator*(MSHADOW_SCALAR_ scale, const ReduceTo1DExp<E, DType, R, d> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(MSHADOW_SCALAR_ scale, const ReduceTo1DExp<E, DType, R, d> &e)
mshadow::expr::operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const DotExp<TA, TB, ltrans, rtrans, MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const DotExp<TA, TB, ltrans, rtrans, MSHADOW_SCALAR_> &lhs, MSHADOW_SCALAR_ rhs)
mshadow::expr::operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
mshadow::expr::operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const ReduceTo1DExp<E, DType, R, d> &e, MSHADOW_SCALAR_ scale) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ReduceTo1DExp<E, DType, R, d> &e, MSHADOW_SCALAR_ scale)
mshadow::expr::operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const ScalarExp<MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
mshadow::expr::operator *	include/mshadow/expression.h	/^operator*(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
mshadow::expr::operator +	include/mshadow/expr_scalar-inl.h	/^operator+(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
mshadow::expr::operator +	include/mshadow/expr_scalar-inl.h	/^operator+(const ScalarExp<MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
mshadow::expr::operator +	include/mshadow/expression.h	/^operator+(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
mshadow::expr::operator -	include/mshadow/expr_scalar-inl.h	/^operator-(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
mshadow::expr::operator -	include/mshadow/expr_scalar-inl.h	/^operator-(const ScalarExp<MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
mshadow::expr::operator -	include/mshadow/expression.h	/^operator-(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
mshadow::expr::operator /	include/mshadow/expr_scalar-inl.h	/^operator\/(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
mshadow::expr::operator /	include/mshadow/expr_scalar-inl.h	/^operator\/(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
mshadow::expr::operator /	include/mshadow/expression.h	/^operator\/(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
mshadow::expr::pack_col2patch	include/mshadow/extension/pack_col2patch.h	/^pack_col2patch(const expr::Exp<SrcExp, DType, etype> &src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const expr::Exp<SrcExp, DType, etype> &src, Shape<dstdim> imshape, index_t psize_y, index_t psize_x, index_t pstride)
mshadow::expr::pad	include/mshadow/extension/pad.h	/^pad(const Exp<SrcExp, DType, etype> &src, index_t pad) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t pad)
mshadow::expr::pad	include/mshadow/extension/pad.h	/^pad(const Exp<SrcExp, DType, etype> &src, index_t pad_y, index_t pad_x) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t pad_y, index_t pad_x)
mshadow::expr::pool	include/mshadow/extension/spatial_pool.h	/^pool(const Exp<SrcExp, DType, etype> &src, Shape<2> pshape,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<2> pshape, index_t ksize_y, index_t ksize_x, index_t kstride)
mshadow::expr::pool	include/mshadow/extension/spatial_pool.h	/^pool(const Exp<SrcExp, DType, etype> &src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t ksize_y, index_t ksize_x, index_t kstride)
mshadow::expr::reshape	include/mshadow/extension/reshape.h	/^reshape(const Exp<SrcExp, DType, etype> &src, Shape<dimdst> oshape) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<dimdst> oshape)
mshadow::expr::scalar	include/mshadow/expression.h	/^inline ScalarExp<DType> scalar(DType s) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(DType s)
mshadow::expr::sum_rows	include/mshadow/extension/reduceto1d.h	/^sum_rows(const Exp<SrcExp, DType, etype> &exp) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &exp)
mshadow::expr::sumall_except_dim	include/mshadow/extension/reduceto1d.h	/^sumall_except_dim(const Exp<SrcExp, DType, etype> &exp) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &exp)
mshadow::expr::swapaxis	include/mshadow/extension/swapaxis.h	/^swapaxis(const Exp<SrcExp, DType, etype> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src)
mshadow::expr::tcast	include/mshadow/expression.h	/^tcast(const Exp<EType, SrcDType, etype> &exp) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<EType, SrcDType, etype> &exp)
mshadow::expr::type	include/mshadow/expression.h	/^namespace type {$/;"	n	language:C++	namespace:mshadow::expr
mshadow::expr::type::kChainer	include/mshadow/expression.h	/^const int kChainer = 3;$/;"	m	language:C++	namespace:mshadow::expr::type
mshadow::expr::type::kComplex	include/mshadow/expression.h	/^const int kComplex = 7;$/;"	m	language:C++	namespace:mshadow::expr::type
mshadow::expr::type::kMapper	include/mshadow/expression.h	/^const int kMapper = 1;$/;"	m	language:C++	namespace:mshadow::expr::type
mshadow::expr::type::kRValue	include/mshadow/expression.h	/^const int kRValue = 0;$/;"	m	language:C++	namespace:mshadow::expr::type
mshadow::expr::unpack_patch2col	include/mshadow/extension/unpack_patch2col.h	/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)
mshadow::expr::unpool	include/mshadow/extension/spatial_unpool.h	/^unpool(const Exp<SrcExp, DType, etype> &data_src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &data_src, const Exp<SrcExp, DType, etype> &data_pooled, const Exp<SrcExp, DType, etype> &grad_pooled, index_t ksize_y, index_t ksize_x, index_t kstride)
mshadow::expr::xlen	include/mshadow/sse-inl.h	/^  const index_t xlen = sse2::LowerAlign(dst.size(1), sizeof(DType));$/;"	l	language:C++
mshadow::gpu	include/mshadow/tensor.h	/^struct gpu {$/;"	s	language:C++	namespace:mshadow
mshadow::gpu::kDevCPU	include/mshadow/tensor.h	/^  static const bool kDevCPU = false;$/;"	m	language:C++	struct:mshadow::gpu	access:public
mshadow::gpu::kDevMask	include/mshadow/tensor.h	/^  static const int kDevMask = 1 << 1;$/;"	m	language:C++	struct:mshadow::gpu	access:public
mshadow::index_t	include/mshadow/base.h	/^typedef unsigned index_t;$/;"	t	language:C++	namespace:mshadow
mshadow::kPi	include/mshadow/base.h	/^const float kPi = 3.1415926f;$/;"	m	language:C++	namespace:mshadow
mshadow::kRandBufferSize	include/mshadow/base.h	/^const unsigned kRandBufferSize = 1000000;$/;"	m	language:C++	namespace:mshadow
mshadow::mmax	include/mshadow/tensor_cpu-inl.h	/^  DType mmax = energy[0];$/;"	l	language:C++
mshadow::obj	include/mshadow/tensor_cpu-inl.h	/^  Tensor<Device, dim, DType> obj(shape);$/;"	p	language:C++	signature:(shape)
mshadow::op	include/mshadow/base.h	/^namespace op {$/;"	n	language:C++	namespace:mshadow
mshadow::op::div	include/mshadow/base.h	/^struct div {$/;"	s	language:C++	namespace:mshadow::op
mshadow::op::div::Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::div	access:public	signature:(DType a, DType b)
mshadow::op::identity	include/mshadow/base.h	/^struct identity{$/;"	s	language:C++	namespace:mshadow::op
mshadow::op::identity::Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a) {$/;"	f	language:C++	struct:mshadow::op::identity	access:public	signature:(DType a)
mshadow::op::minus	include/mshadow/base.h	/^struct minus {$/;"	s	language:C++	namespace:mshadow::op
mshadow::op::minus::Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::minus	access:public	signature:(DType a, DType b)
mshadow::op::mul	include/mshadow/base.h	/^struct mul{$/;"	s	language:C++	namespace:mshadow::op
mshadow::op::mul::Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::mul	access:public	signature:(DType a, DType b)
mshadow::op::plus	include/mshadow/base.h	/^struct plus {$/;"	s	language:C++	namespace:mshadow::op
mshadow::op::plus::Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::plus	access:public	signature:(DType a, DType b)
mshadow::op::right	include/mshadow/base.h	/^struct right {$/;"	s	language:C++	namespace:mshadow::op
mshadow::op::right::Map	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType Map(DType a, DType b) {$/;"	f	language:C++	struct:mshadow::op::right	access:public	signature:(DType a, DType b)
mshadow::pitch	include/mshadow/tensor_cpu-inl.h	/^  size_t pitch;$/;"	l	language:C++
mshadow::prop	include/mshadow/tensor_gpu-inl.h	/^  cudaDeviceProp prop;$/;"	l	language:C++
mshadow::ps	include/mshadow-ps/mshadow_ps.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
mshadow::ps	include/mshadow-ps/ps_dist-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
mshadow::ps	include/mshadow-ps/ps_local-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
mshadow::ps	include/mshadow-ps/ps_rabit-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
mshadow::ps	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
mshadow::ps	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
mshadow::ps	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^namespace ps {$/;"	n	language:C++	namespace:mshadow	file:
mshadow::ps::CreateModelUpdater	include/mshadow-ps/mshadow_ps.h	/^IModelUpdater<DType> *CreateModelUpdater(void);$/;"	p	language:C++	namespace:mshadow::ps	signature:(void)
mshadow::ps::CreateModelUpdater	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^IModelUpdater<DType> *CreateModelUpdater(void) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(void)
mshadow::ps::CreateModelUpdater	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^IModelUpdater<float> *CreateModelUpdater(void) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(void)
mshadow::ps::CreateModelUpdater	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^IModelUpdater<float> *CreateModelUpdater(void) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(void)
mshadow::ps::CreateSharedModel	include/mshadow-ps/mshadow_ps.h	/^inline ISharedModel<xpu, DType> *CreateSharedModel(const char *type) {$/;"	f	language:C++	namespace:mshadow::ps	signature:(const char *type)
mshadow::ps::DistModel	include/mshadow-ps/ps_dist-inl.h	/^class DistModel : public LocalModel<xpu, DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:LocalModel
mshadow::ps::DistModel::HandlePushFinish	include/mshadow-ps/ps_dist-inl.h	/^  virtual void HandlePushFinish(Tensor<cpu, 3, DType> data,$/;"	f	language:C++	class:mshadow::ps::DistModel	access:protected	signature:(Tensor<cpu, 3, DType> data, int key)
mshadow::ps::DistModel::Init	include/mshadow-ps/ps_dist-inl.h	/^  virtual void Init(const std::vector<int> &devices) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:public	signature:(const std::vector<int> &devices)
mshadow::ps::DistModel::InitCustomerServer	include/mshadow-ps/ps_dist-inl.h	/^  virtual void InitCustomerServer(void) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:protected	signature:(void)
mshadow::ps::DistModel::LocalModel::ReduceSum	include/mshadow-ps/ps_dist-inl.h	/^    LocalModel<xpu, DType>::ReduceSum(data);$/;"	p	language:C++	class:mshadow::ps::DistModel::LocalModel	signature:(data)
mshadow::ps::DistModel::MSize	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key), weight.dptr_, weight.MSize(),$/;"	p	language:C++	signature:()
mshadow::ps::DistModel::MSize	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key, -1, {ts}), sendrecv.dptr_, sendrecv.MSize(),$/;"	p	language:C++	signature:()
mshadow::ps::DistModel::Parent	include/mshadow-ps/ps_dist-inl.h	/^  typedef LocalModel<xpu, DType> Parent;$/;"	t	language:C++	class:mshadow::ps::DistModel	access:public
mshadow::ps::DistModel::Parent::Init	include/mshadow-ps/ps_dist-inl.h	/^    Parent::Init(devices);$/;"	p	language:C++	class:mshadow::ps::DistModel::Parent	signature:(devices)
mshadow::ps::DistModel::Request	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key), weight.dptr_, weight.MSize(),$/;"	p	language:C++	signature:(key)
mshadow::ps::DistModel::Request	include/mshadow-ps/ps_dist-inl.h	/^        ::ps::Parameter::Request(key, -1, {ts}), sendrecv.dptr_, sendrecv.MSize(),$/;"	p	language:C++	signature:(key, -1, {ts})
mshadow::ps::DistModel::ServerInitKey	include/mshadow-ps/ps_dist-inl.h	/^  virtual void ServerInitKey(Tensor<cpu, 2> weight, int key) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:protected	signature:(Tensor<cpu, 2> weight, int key)
mshadow::ps::DistModel::sendrecv	include/mshadow-ps/ps_dist-inl.h	/^    Tensor<cpu, 2> sendrecv = data[0];$/;"	l	language:C++
mshadow::ps::DistModel::shared_model_	include/mshadow-ps/ps_dist-inl.h	/^  ::ps::KVLayer<DType, UpdaterWrapper<DType> > shared_model_;$/;"	m	language:C++	class:mshadow::ps::DistModel	access:private
mshadow::ps::DistModel::ts	include/mshadow-ps/ps_dist-inl.h	/^    int ts = shared_model_.Push($/;"	l	language:C++
mshadow::ps::DistModel::utils::Assert	include/mshadow-ps/ps_dist-inl.h	/^    utils::Assert(data[0].CheckContiguous(), "data must be contiguous");$/;"	p	language:C++	class:mshadow::ps::DistModel::utils	signature:(data[0].CheckContiguous(), Ó)
mshadow::ps::DistModel::~DistModel	include/mshadow-ps/ps_dist-inl.h	/^  virtual ~DistModel(void) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:public	signature:(void)
mshadow::ps::IModelUpdater	include/mshadow-ps/mshadow_ps.h	/^class IModelUpdater {$/;"	c	language:C++	namespace:mshadow::ps
mshadow::ps::IModelUpdater::InitModel	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitModel(int key, DType *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(int key, DType *dptr, size_t size)
mshadow::ps::IModelUpdater::InitModel_	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitModel_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
mshadow::ps::IModelUpdater::InitUpdater	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitUpdater(int rank, int argc, char *argv[]) {}$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(int rank, int argc, char *argv[])
mshadow::ps::IModelUpdater::SetParam	include/mshadow-ps/mshadow_ps.h	/^  virtual void SetParam(const char *name, const char *val) {}$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(const char *name, const char *val)
mshadow::ps::IModelUpdater::Update	include/mshadow-ps/mshadow_ps.h	/^  virtual void Update(int key, DType *dptr, size_t size) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(int key, DType *dptr, size_t size)
mshadow::ps::IModelUpdater::Update_	include/mshadow-ps/mshadow_ps.h	/^  virtual void Update_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
mshadow::ps::IModelUpdater::~IModelUpdater	include/mshadow-ps/mshadow_ps.h	/^  virtual ~IModelUpdater(void) {}$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(void)
mshadow::ps::ISharedModel	include/mshadow-ps/mshadow_ps.h	/^class ISharedModel {$/;"	c	language:C++	namespace:mshadow::ps
mshadow::ps::ISharedModel::CallbackFunction	include/mshadow-ps/mshadow_ps.h	/^  typedef void (CallbackFunction) (Stream<xpu> *stream, void *arg);$/;"	t	language:C++	class:mshadow::ps::ISharedModel	access:public
mshadow::ps::ISharedModel::CheckWeight	include/mshadow-ps/mshadow_ps.h	/^  inline void CheckWeight(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid)
mshadow::ps::ISharedModel::CheckWeight_	include/mshadow-ps/mshadow_ps.h	/^  virtual void CheckWeight_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
mshadow::ps::ISharedModel::Init	include/mshadow-ps/mshadow_ps.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(void)
mshadow::ps::ISharedModel::Init	include/mshadow-ps/mshadow_ps.h	/^  virtual void Init(const std::vector<int> &devices) {}$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(const std::vector<int> &devices)
mshadow::ps::ISharedModel::InitKey	include/mshadow-ps/mshadow_ps.h	/^  inline void InitKey(Shape<dim> shape,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Shape<dim> shape, int key, int devid)
mshadow::ps::ISharedModel::InitKey_	include/mshadow-ps/mshadow_ps.h	/^  virtual void InitKey_(Shape<2> shape,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:protected	signature:(Shape<2> shape, int key, int devid)
mshadow::ps::ISharedModel::InvokeLambda_	include/mshadow-ps/mshadow_ps.h	/^  inline static void InvokeLambda_(Stream<xpu> *stream, void *fun) {$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:private	signature:(Stream<xpu> *stream, void *fun)
mshadow::ps::ISharedModel::PullReq	include/mshadow-ps/mshadow_ps.h	/^  inline void PullReq(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid, int priority = 0, CallbackFunction callback = NULL, void *callback_arg = NULL)
mshadow::ps::ISharedModel::PullReq	include/mshadow-ps/mshadow_ps.h	/^  inline void PullReq(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid, int priority, std::function<void(Stream<xpu> *stream)> callback)
mshadow::ps::ISharedModel::PullReq_	include/mshadow-ps/mshadow_ps.h	/^  virtual void PullReq_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority, CallbackFunction callback, void *callback_arg)
mshadow::ps::ISharedModel::PullWait	include/mshadow-ps/mshadow_ps.h	/^  virtual void PullWait(int key, int devid) = 0;$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(int key, int devid)
mshadow::ps::ISharedModel::Push	include/mshadow-ps/mshadow_ps.h	/^  inline void Push(Tensor<xpu, dim, DType> data,$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, dim, DType> data, int key, int devid, int priority = 0)
mshadow::ps::ISharedModel::Push_	include/mshadow-ps/mshadow_ps.h	/^  virtual void Push_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority = 0)
mshadow::ps::ISharedModel::SetParam	include/mshadow-ps/mshadow_ps.h	/^  virtual void SetParam(const char *name, const char *val) {}$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(const char *name, const char *val)
mshadow::ps::ISharedModel::SetWeight_	include/mshadow-ps/mshadow_ps.h	/^  virtual void SetWeight_(Tensor<xpu, 2, DType> data,$/;"	p	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
mshadow::ps::ISharedModel::calbk	include/mshadow-ps/mshadow_ps.h	/^    auto calbk = new std::function<void(Stream<xpu> *stream)>();$/;"	l	language:C++
mshadow::ps::ISharedModel::dev	include/mshadow-ps/mshadow_ps.h	/^    std::vector<int> dev;$/;"	l	language:C++
mshadow::ps::ISharedModel::fp	include/mshadow-ps/mshadow_ps.h	/^    auto *fp = static_cast<std::function<void(Stream<xpu> *stream)>*>(fun);$/;"	l	language:C++
mshadow::ps::ISharedModel::~ISharedModel	include/mshadow-ps/mshadow_ps.h	/^  virtual ~ISharedModel(void) {}$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(void)
mshadow::ps::LocalModel	include/mshadow-ps/ps_local-inl.h	/^class LocalModel : public ISharedModel<xpu, DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:ISharedModel
mshadow::ps::LocalModel::Broadcast	include/mshadow-ps/ps_local-inl.h	/^            wait_cond.Broadcast();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::CallbackFunction	include/mshadow-ps/ps_local-inl.h	/^  CallbackFunction;$/;"	t	language:C++	class:mshadow::ps::LocalModel	access:public
mshadow::ps::LocalModel::CheckWeight_	include/mshadow-ps/ps_local-inl.h	/^  virtual void CheckWeight_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^        pull_queues[i].Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^        push_queues[i].Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^      pull_map.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^      push_lock.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^      push_map.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^      request_lock.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^      wait_cond.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^      wait_lock.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Destroy	include/mshadow-ps/ps_local-inl.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(void)
mshadow::ps::LocalModel::GetWorkIndex	include/mshadow-ps/ps_local-inl.h	/^  inline int GetWorkIndex(int devid) const {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(int devid) const
mshadow::ps::LocalModel::HandlePushFinish	include/mshadow-ps/ps_local-inl.h	/^  virtual void HandlePushFinish(Tensor<cpu, 3, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 3, DType> data, int key)
mshadow::ps::LocalModel::HandleReduceFinish	include/mshadow-ps/ps_local-inl.h	/^  inline void HandleReduceFinish(Tensor<cpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 2, DType> data, int key)
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^      e.Init(devices.size(), shape,$/;"	p	language:C++	signature:(devices.size(), shape, use_pin_memory != 0, update_on_server != 0 || test_on_server != 0)
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^      pull_queues[i].Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    pull_map.Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    pull_map.Init(key);$/;"	p	language:C++	signature:(key)
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    push_lock.Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    push_map.Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    push_map.Init(key);$/;"	p	language:C++	signature:(key)
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    request_lock.Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    wait_cond.Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^    wait_lock.Init();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Init	include/mshadow-ps/ps_local-inl.h	/^  virtual void Init(const std::vector<int> &devices) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(const std::vector<int> &devices)
mshadow::ps::LocalModel::InitCustomerServer	include/mshadow-ps/ps_local-inl.h	/^  virtual void InitCustomerServer(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(void)
mshadow::ps::LocalModel::InitKey_	include/mshadow-ps/ps_local-inl.h	/^  virtual void InitKey_(Shape<2> shape,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Shape<2> shape, int key, int devid)
mshadow::ps::LocalModel::InitModel	include/mshadow-ps/ps_local-inl.h	/^      custom_server->InitModel(key, weight.dptr_, weight.MSize());$/;"	p	language:C++	signature:(key, weight.dptr_, weight.MSize())
mshadow::ps::LocalModel::InitPullMap	include/mshadow-ps/ps_local-inl.h	/^  inline void InitPullMap(int key) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(int key)
mshadow::ps::LocalModel::InitPushMap	include/mshadow-ps/ps_local-inl.h	/^  inline void InitPushMap(int key, Shape<2> shape) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(int key, Shape<2> shape)
mshadow::ps::LocalModel::Join	include/mshadow-ps/ps_local-inl.h	/^        thread_pull_handler[i].Join();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Join	include/mshadow-ps/ps_local-inl.h	/^        thread_push_handler[i].Join();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::LocalModel	include/mshadow-ps/ps_local-inl.h	/^  LocalModel(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(void)
mshadow::ps::LocalModel::LocalOp	include/mshadow-ps/ps_local-inl.h	/^  enum LocalOp {$/;"	g	language:C++	class:mshadow::ps::LocalModel	access:protected
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^          wait_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^        push_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^        request_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^      wait_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^    push_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^    request_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Lock	include/mshadow-ps/ps_local-inl.h	/^    wait_lock.Lock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::PullEntry	include/mshadow-ps/ps_local-inl.h	/^  struct PullEntry {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::PullEntry::PullEntry	include/mshadow-ps/ps_local-inl.h	/^    PullEntry(void) {$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public	signature:(void)
mshadow::ps::LocalModel::PullEntry::req	include/mshadow-ps/ps_local-inl.h	/^    std::vector<PullReqRecord> req;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public
mshadow::ps::LocalModel::PullEntry::src	include/mshadow-ps/ps_local-inl.h	/^    Tensor<cpu, 2, DType> src;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public
mshadow::ps::LocalModel::PullEntry::wait	include/mshadow-ps/ps_local-inl.h	/^    std::vector<PullWaitRecord> wait;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public
mshadow::ps::LocalModel::PullGlobalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PullGlobalThread(void *arg) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *arg)
mshadow::ps::LocalModel::PullHandlerGlobal	include/mshadow-ps/ps_local-inl.h	/^  inline void PullHandlerGlobal(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void)
mshadow::ps::LocalModel::PullHandlerLocal	include/mshadow-ps/ps_local-inl.h	/^  inline void PullHandlerLocal(size_t tid) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(size_t tid)
mshadow::ps::LocalModel::PullLocalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PullLocalThread(void *arg) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *arg)
mshadow::ps::LocalModel::PullProc	include/mshadow-ps/ps_local-inl.h	/^  inline void PullProc(utils::ThreadPQueue<std::pair<int, int> > *queue) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(utils::ThreadPQueue<std::pair<int, int> > *queue)
mshadow::ps::LocalModel::PullReady	include/mshadow-ps/ps_local-inl.h	/^  virtual void PullReady(Tensor<cpu, 2> data, int key) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 2> data, int key)
mshadow::ps::LocalModel::PullReqRecord	include/mshadow-ps/ps_local-inl.h	/^  struct PullReqRecord {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::PullReqRecord::PullReqRecord	include/mshadow-ps/ps_local-inl.h	/^    PullReqRecord(void) : ready(false), pending(false) {$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public	signature:(void)
mshadow::ps::LocalModel::PullReqRecord::callback	include/mshadow-ps/ps_local-inl.h	/^    CallbackFunction *callback;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
mshadow::ps::LocalModel::PullReqRecord::callback_arg	include/mshadow-ps/ps_local-inl.h	/^    void *callback_arg;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
mshadow::ps::LocalModel::PullReqRecord::dest	include/mshadow-ps/ps_local-inl.h	/^    Tensor<xpu, 2, DType> dest;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
mshadow::ps::LocalModel::PullReqRecord::pending	include/mshadow-ps/ps_local-inl.h	/^    bool pending;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
mshadow::ps::LocalModel::PullReqRecord::priority	include/mshadow-ps/ps_local-inl.h	/^    int priority;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
mshadow::ps::LocalModel::PullReqRecord::ready	include/mshadow-ps/ps_local-inl.h	/^    bool ready;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
mshadow::ps::LocalModel::PullReq_	include/mshadow-ps/ps_local-inl.h	/^  virtual void PullReq_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority, CallbackFunction callback, void *callback_arg)
mshadow::ps::LocalModel::PullTask	include/mshadow-ps/ps_local-inl.h	/^      push_queues[0].Push(PullTask(data, key, devid), priority);$/;"	p	language:C++	signature:(data, key, devid)
mshadow::ps::LocalModel::PullTask	include/mshadow-ps/ps_local-inl.h	/^      push_queues[wid].Push(PullTask(data, key, devid), priority);$/;"	p	language:C++	signature:(data, key, devid)
mshadow::ps::LocalModel::PullTask	include/mshadow-ps/ps_local-inl.h	/^  struct PullTask {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::PullTask::PullTask	include/mshadow-ps/ps_local-inl.h	/^    PullTask(Tensor<xpu, 2, DType> data, int key, int devid)$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
mshadow::ps::LocalModel::PullTask::PullTask	include/mshadow-ps/ps_local-inl.h	/^    PullTask(void) {}$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public	signature:(void)
mshadow::ps::LocalModel::PullTask::data	include/mshadow-ps/ps_local-inl.h	/^    Tensor<xpu, 2, DType> data;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public
mshadow::ps::LocalModel::PullTask::devid	include/mshadow-ps/ps_local-inl.h	/^    int devid;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public
mshadow::ps::LocalModel::PullTask::key	include/mshadow-ps/ps_local-inl.h	/^    int key;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullTask	access:public
mshadow::ps::LocalModel::PullWait	include/mshadow-ps/ps_local-inl.h	/^  virtual void PullWait(int key, int devid) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(int key, int devid)
mshadow::ps::LocalModel::PullWaitRecord	include/mshadow-ps/ps_local-inl.h	/^  struct PullWaitRecord {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::PullWaitRecord::PullWaitRecord	include/mshadow-ps/ps_local-inl.h	/^    PullWaitRecord(void)$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PullWaitRecord	access:public	signature:(void)
mshadow::ps::LocalModel::PullWaitRecord::finished	include/mshadow-ps/ps_local-inl.h	/^    bool finished;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullWaitRecord	access:public
mshadow::ps::LocalModel::PullWaitRecord::nwait	include/mshadow-ps/ps_local-inl.h	/^    int nwait;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullWaitRecord	access:public
mshadow::ps::LocalModel::PushEntry	include/mshadow-ps/ps_local-inl.h	/^  struct PushEntry {$/;"	s	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::PushEntry::Init	include/mshadow-ps/ps_local-inl.h	/^    inline void Init(int ndevice, Shape<2> shape,$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public	signature:(int ndevice, Shape<2> shape, bool pin_memory, bool need_weight)
mshadow::ps::LocalModel::PushEntry::PushEntry	include/mshadow-ps/ps_local-inl.h	/^    PushEntry(void)$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public	signature:(void)
mshadow::ps::LocalModel::PushEntry::copied	include/mshadow-ps/ps_local-inl.h	/^    std::vector<bool> copied;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
mshadow::ps::LocalModel::PushEntry::copyin_version	include/mshadow-ps/ps_local-inl.h	/^    int copyin_version;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
mshadow::ps::LocalModel::PushEntry::data	include/mshadow-ps/ps_local-inl.h	/^    Tensor<cpu, 4, DType> data;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
mshadow::ps::LocalModel::PushEntry::num_copied	include/mshadow-ps/ps_local-inl.h	/^    int num_copied;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
mshadow::ps::LocalModel::PushEntry::pin_memory	include/mshadow-ps/ps_local-inl.h	/^    bool pin_memory;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
mshadow::ps::LocalModel::PushEntry::resize	include/mshadow-ps/ps_local-inl.h	/^      copied.resize(ndevice, false);$/;"	p	language:C++	signature:(ndevice, false)
mshadow::ps::LocalModel::PushEntry::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^      utils::Assert(data.CheckContiguous(), "Init");$/;"	p	language:C++	class:mshadow::ps::LocalModel::PushEntry::utils	signature:(data.CheckContiguous(), Ó)
mshadow::ps::LocalModel::PushEntry::weight	include/mshadow-ps/ps_local-inl.h	/^    Tensor<cpu, 2, DType> weight;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
mshadow::ps::LocalModel::PushEntry::~PushEntry	include/mshadow-ps/ps_local-inl.h	/^    ~PushEntry(void) {$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public	signature:(void)
mshadow::ps::LocalModel::PushGlobalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PushGlobalThread(void *pthread) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *pthread)
mshadow::ps::LocalModel::PushHandlerGlobal	include/mshadow-ps/ps_local-inl.h	/^  inline void PushHandlerGlobal(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void)
mshadow::ps::LocalModel::PushHandlerLocal	include/mshadow-ps/ps_local-inl.h	/^  inline void PushHandlerLocal(size_t tid) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(size_t tid)
mshadow::ps::LocalModel::PushLocalThread	include/mshadow-ps/ps_local-inl.h	/^  inline static MSHADOW_THREAD_PREFIX PushLocalThread(void *arg) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(void *arg)
mshadow::ps::LocalModel::PushProc	include/mshadow-ps/ps_local-inl.h	/^  inline void PushProc(utils::ThreadPQueue<PullTask> *queue) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:private	signature:(utils::ThreadPQueue<PullTask> *queue)
mshadow::ps::LocalModel::Push_	include/mshadow-ps/ps_local-inl.h	/^  virtual void Push_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<xpu, 2, DType> data, int key, int devid, int priority)
mshadow::ps::LocalModel::ReduceSum	include/mshadow-ps/ps_local-inl.h	/^  inline void ReduceSum(Tensor<cpu, 3, DType> data) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 3, DType> data)
mshadow::ps::LocalModel::Resize	include/mshadow-ps/ps_local-inl.h	/^    tmp.Resize(data.shape_);$/;"	p	language:C++	signature:(data.shape_)
mshadow::ps::LocalModel::ServerInitKey	include/mshadow-ps/ps_local-inl.h	/^  virtual void ServerInitKey(Tensor<cpu, 2> weight, int key) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:protected	signature:(Tensor<cpu, 2> weight, int key)
mshadow::ps::LocalModel::SetParam	include/mshadow-ps/ps_local-inl.h	/^        custom_server->SetParam(cfgvec[j].first.c_str(),$/;"	p	language:C++	signature:(cfgvec[j].first.c_str(), cfgvec[j].second.c_str())
mshadow::ps::LocalModel::SetParam	include/mshadow-ps/ps_local-inl.h	/^  virtual void SetParam(const char *name, const char *val) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(const char *name, const char *val)
mshadow::ps::LocalModel::SetWeight_	include/mshadow-ps/ps_local-inl.h	/^  virtual void SetWeight_(Tensor<xpu, 2, DType> data,$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(Tensor<xpu, 2, DType> data, int key, int devid)
mshadow::ps::LocalModel::Start	include/mshadow-ps/ps_local-inl.h	/^        thread_pull_handler[i].Start(PullLocalThread, p);$/;"	p	language:C++	signature:(PullLocalThread, p)
mshadow::ps::LocalModel::Start	include/mshadow-ps/ps_local-inl.h	/^        thread_push_handler[i].Start(PushLocalThread, p);$/;"	p	language:C++	signature:(PushLocalThread, p)
mshadow::ps::LocalModel::Start	include/mshadow-ps/ps_local-inl.h	/^      thread_pull_handler[0].Start(PullGlobalThread, this);$/;"	p	language:C++	signature:(PullGlobalThread, this)
mshadow::ps::LocalModel::Start	include/mshadow-ps/ps_local-inl.h	/^      thread_push_handler[0].Start(PushGlobalThread, this);$/;"	p	language:C++	signature:(PushGlobalThread, this)
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^          wait_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^        push_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^        request_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^      wait_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^    push_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^    request_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Unlock	include/mshadow-ps/ps_local-inl.h	/^    wait_lock.Unlock();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Update	include/mshadow-ps/ps_local-inl.h	/^      custom_server->Update(key, data.dptr_, data.MSize());$/;"	p	language:C++	signature:(key, data.dptr_, data.MSize())
mshadow::ps::LocalModel::Update	include/mshadow-ps/ps_local-inl.h	/^      custom_server->Update(key, data[0].dptr_, data[0].MSize());$/;"	p	language:C++	signature:(key, data[0].dptr_, data[0].MSize())
mshadow::ps::LocalModel::Wait	include/mshadow-ps/ps_local-inl.h	/^          pull_stream[wid]->Wait();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::Wait	include/mshadow-ps/ps_local-inl.h	/^        push_stream[wid]->Wait();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::bigarray_bound	include/mshadow-ps/ps_local-inl.h	/^  size_t bigarray_bound;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::callback	include/mshadow-ps/ps_local-inl.h	/^            (*r.callback)(pull_stream[wid], r.callback_arg);$/;"	p	language:C++	signature:(pull_stream[wid], r.callback_arg)
mshadow::ps::LocalModel::cfgvec	include/mshadow-ps/ps_local-inl.h	/^  std::vector< std::pair<std::string, std::string> > cfgvec;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::clear	include/mshadow-ps/ps_local-inl.h	/^    dev2index.clear();$/;"	p	language:C++	signature:()
mshadow::ps::LocalModel::count	include/mshadow-ps/ps_local-inl.h	/^    index_t count = tmp.shape_.Size();$/;"	l	language:C++
mshadow::ps::LocalModel::cp_version	include/mshadow-ps/ps_local-inl.h	/^        int cp_version = e.copyin_version;$/;"	l	language:C++
mshadow::ps::LocalModel::custom_server	include/mshadow-ps/ps_local-inl.h	/^  IModelUpdater<DType> *custom_server;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:protected
mshadow::ps::LocalModel::d	include/mshadow-ps/ps_local-inl.h	/^      double d = std::abs(tmp.dptr_[i] - e.weight.dptr_[i]);$/;"	l	language:C++
mshadow::ps::LocalModel::destroy_signal	include/mshadow-ps/ps_local-inl.h	/^  bool destroy_signal;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::dev2index	include/mshadow-ps/ps_local-inl.h	/^  std::vector<int> dev2index;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::devices	include/mshadow-ps/ps_local-inl.h	/^  std::vector<int> devices;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::devid	include/mshadow-ps/ps_local-inl.h	/^        const int devid = tsk.second;$/;"	l	language:C++
mshadow::ps::LocalModel::devid	include/mshadow-ps/ps_local-inl.h	/^      int devid = devices[i];$/;"	l	language:C++
mshadow::ps::LocalModel::diff	include/mshadow-ps/ps_local-inl.h	/^    double diff = 0.0, ssum = 0.0, maxdiff = 0.0;$/;"	l	language:C++
mshadow::ps::LocalModel::e	include/mshadow-ps/ps_local-inl.h	/^        PullEntry &e = pull_map.GetRef(key);$/;"	l	language:C++
mshadow::ps::LocalModel::e	include/mshadow-ps/ps_local-inl.h	/^        PushEntry &e = push_map.GetRef(key);$/;"	l	language:C++
mshadow::ps::LocalModel::e	include/mshadow-ps/ps_local-inl.h	/^        PushEntry &e = push_map.GetRef(tsk.key);$/;"	l	language:C++
mshadow::ps::LocalModel::e	include/mshadow-ps/ps_local-inl.h	/^    PullEntry &e = pull_map.GetRef(key);$/;"	l	language:C++
mshadow::ps::LocalModel::e	include/mshadow-ps/ps_local-inl.h	/^    PushEntry &e = push_map.GetRef(key);$/;"	l	language:C++
mshadow::ps::LocalModel::init_end	include/mshadow-ps/ps_local-inl.h	/^  int init_end;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::it	include/mshadow-ps/ps_local-inl.h	/^        it = push_operation.find(key);$/;"	l	language:C++
mshadow::ps::LocalModel::kGather	include/mshadow-ps/ps_local-inl.h	/^    kGather = 1$/;"	e	language:C++	enum:mshadow::ps::LocalModel::LocalOp
mshadow::ps::LocalModel::kSum	include/mshadow-ps/ps_local-inl.h	/^    kSum = 0,$/;"	e	language:C++	enum:mshadow::ps::LocalModel::LocalOp
mshadow::ps::LocalModel::key	include/mshadow-ps/ps_local-inl.h	/^        const int key = tsk.first;$/;"	l	language:C++
mshadow::ps::LocalModel::key	include/mshadow-ps/ps_local-inl.h	/^    int key;$/;"	l	language:C++
mshadow::ps::LocalModel::make_pair	include/mshadow-ps/ps_local-inl.h	/^          pull_queues[0].Push(std::make_pair(key, devices[i]));$/;"	p	language:C++	signature:(key, devices[i])
mshadow::ps::LocalModel::make_pair	include/mshadow-ps/ps_local-inl.h	/^          pull_queues[i].Push(std::make_pair(key, devices[i]));$/;"	p	language:C++	signature:(key, devices[i])
mshadow::ps::LocalModel::make_pair	include/mshadow-ps/ps_local-inl.h	/^        pull_queues[0].Push(std::make_pair(key, devid));$/;"	p	language:C++	signature:(key, devid)
mshadow::ps::LocalModel::make_pair	include/mshadow-ps/ps_local-inl.h	/^        pull_queues[wid].Push(std::make_pair(key, devid));$/;"	p	language:C++	signature:(key, devid)
mshadow::ps::LocalModel::maxdiff	include/mshadow-ps/ps_local-inl.h	/^    double diff = 0.0, ssum = 0.0, maxdiff = 0.0;$/;"	l	language:C++
mshadow::ps::LocalModel::mshadow::Copy	include/mshadow-ps/ps_local-inl.h	/^    mshadow::Copy(e.weight, data, &s);$/;"	p	language:C++	class:mshadow::ps::LocalModel::mshadow	signature:(e.weight, data, &s)
mshadow::ps::LocalModel::mshadow::Copy	include/mshadow-ps/ps_local-inl.h	/^    mshadow::Copy(tmp, data, &s);$/;"	p	language:C++	class:mshadow::ps::LocalModel::mshadow	signature:(tmp, data, &s)
mshadow::ps::LocalModel::mxidx	include/mshadow-ps/ps_local-inl.h	/^    index_t mxidx = 0;$/;"	l	language:C++
mshadow::ps::LocalModel::ntask	include/mshadow-ps/ps_local-inl.h	/^      ms_omp_uint ntask = static_cast<ms_omp_uint>(data.size(1));$/;"	l	language:C++
mshadow::ps::LocalModel::nthread_reduction	include/mshadow-ps/ps_local-inl.h	/^  int nthread_reduction;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::op	include/mshadow-ps/ps_local-inl.h	/^    LocalOp op = kSum;$/;"	l	language:C++
mshadow::ps::LocalModel::p	include/mshadow-ps/ps_local-inl.h	/^        std::pair<LocalModel*, size_t> *p$/;"	l	language:C++
mshadow::ps::LocalModel::p	include/mshadow-ps/ps_local-inl.h	/^    PullEntry *p = pull_map.Get(key);$/;"	l	language:C++
mshadow::ps::LocalModel::p	include/mshadow-ps/ps_local-inl.h	/^    std::pair<LocalModel*, size_t> *p$/;"	l	language:C++
mshadow::ps::LocalModel::perdev_pull_thread	include/mshadow-ps/ps_local-inl.h	/^  int perdev_pull_thread;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::perdev_push_thread	include/mshadow-ps/ps_local-inl.h	/^  int perdev_push_thread;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::priority	include/mshadow-ps/ps_local-inl.h	/^      push_queues[0].Push(PullTask(data, key, devid), priority);$/;"	l	language:C++
mshadow::ps::LocalModel::priority	include/mshadow-ps/ps_local-inl.h	/^      push_queues[wid].Push(PullTask(data, key, devid), priority);$/;"	l	language:C++
mshadow::ps::LocalModel::pull_map	include/mshadow-ps/ps_local-inl.h	/^  utils::ThreadSafeMap<PullEntry> pull_map;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::pull_queues	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::ThreadPQueue<std::pair<int, int> > > pull_queues;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::pull_stream	include/mshadow-ps/ps_local-inl.h	/^  std::vector<Stream<xpu>*> pull_stream;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::push_finish	include/mshadow-ps/ps_local-inl.h	/^        bool push_finish = e.num_copied >= static_cast<int>(devices.size());$/;"	l	language:C++
mshadow::ps::LocalModel::push_lock	include/mshadow-ps/ps_local-inl.h	/^  utils::Mutex push_lock;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::push_map	include/mshadow-ps/ps_local-inl.h	/^  utils::ThreadSafeMap<PushEntry> push_map;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::push_operation	include/mshadow-ps/ps_local-inl.h	/^  std::map<int, LocalOp> push_operation;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::push_queues	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::ThreadPQueue<PullTask> > push_queues;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::push_stream	include/mshadow-ps/ps_local-inl.h	/^  std::vector<Stream<xpu>*> push_stream;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::r	include/mshadow-ps/ps_local-inl.h	/^          PullReqRecord &r = e.req[wid];$/;"	l	language:C++
mshadow::ps::LocalModel::r	include/mshadow-ps/ps_local-inl.h	/^    PullReqRecord &r = e.req[wid];$/;"	l	language:C++
mshadow::ps::LocalModel::request_lock	include/mshadow-ps/ps_local-inl.h	/^  utils::Mutex request_lock;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::rerr	include/mshadow-ps/ps_local-inl.h	/^    double rerr = diff \/ ssum;$/;"	l	language:C++
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^      e.req.resize(devices.size(), PullReqRecord());$/;"	p	language:C++	signature:(devices.size(), PullReqRecord())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^      e.wait.resize(devices.size(), PullWaitRecord());$/;"	p	language:C++	signature:(devices.size(), PullWaitRecord())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^      pull_queues.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^      push_queues.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^      thread_pull_handler.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^      thread_push_handler.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^    pull_stream.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
mshadow::ps::LocalModel::resize	include/mshadow-ps/ps_local-inl.h	/^    push_stream.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
mshadow::ps::LocalModel::s	include/mshadow-ps/ps_local-inl.h	/^    Stream<xpu> s;$/;"	l	language:C++
mshadow::ps::LocalModel::ssum	include/mshadow-ps/ps_local-inl.h	/^    double diff = 0.0, ssum = 0.0, maxdiff = 0.0;$/;"	l	language:C++
mshadow::ps::LocalModel::std::fill	include/mshadow-ps/ps_local-inl.h	/^          std::fill(e.copied.begin(), e.copied.end(), false);$/;"	p	language:C++	class:mshadow::ps::LocalModel::std	signature:(e.copied.begin(), e.copied.end(), false)
mshadow::ps::LocalModel::std::string	include/mshadow-ps/ps_local-inl.h	/^                                    std::string(val)));$/;"	p	language:C++	class:mshadow::ps::LocalModel::std	signature:(val)
mshadow::ps::LocalModel::test_on_server	include/mshadow-ps/ps_local-inl.h	/^  int test_on_server;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::thread_pull_handler	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::Thread> thread_pull_handler;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::thread_push_handler	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::Thread> thread_push_handler;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::tmp	include/mshadow-ps/ps_local-inl.h	/^    mshadow::TensorContainer<cpu, 2, DType> tmp(false);$/;"	p	language:C++	signature:(false)
mshadow::ps::LocalModel::tsk	include/mshadow-ps/ps_local-inl.h	/^      PullTask tsk;$/;"	l	language:C++
mshadow::ps::LocalModel::tsk	include/mshadow-ps/ps_local-inl.h	/^      std::pair<int, int> tsk;$/;"	l	language:C++
mshadow::ps::LocalModel::update_on_server	include/mshadow-ps/ps_local-inl.h	/^  int update_on_server;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::use_fifo_push_queue	include/mshadow-ps/ps_local-inl.h	/^  int use_fifo_push_queue;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:protected
mshadow::ps::LocalModel::use_pin_memory	include/mshadow-ps/ps_local-inl.h	/^  int use_pin_memory;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^          utils::Assert(e.req.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.req.size() == devices.size(), Ó)
mshadow::ps::LocalModel::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^          utils::Assert(e.wait.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.wait.size() == devices.size(), Ó)
mshadow::ps::LocalModel::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^        utils::Assert(destroy_signal, "abort but not destroy");$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(destroy_signal, Ó)
mshadow::ps::LocalModel::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^      utils::Assert(w.nwait >= 0, "boundary check");$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(w.nwait >= 0, Ó)
mshadow::ps::LocalModel::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^    utils::Assert(e.req.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.req.size() == devices.size(), Ó)
mshadow::ps::LocalModel::utils::Assert	include/mshadow-ps/ps_local-inl.h	/^    utils::Assert(e.wait.size() == devices.size(),$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.wait.size() == devices.size(), Ó)
mshadow::ps::LocalModel::utils::Check	include/mshadow-ps/ps_local-inl.h	/^        utils::Check(e.data[0][0].shape_ == tsk.data.shape_,$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(e.data[0][0].shape_ == tsk.data.shape_, Ó)
mshadow::ps::LocalModel::utils::Check	include/mshadow-ps/ps_local-inl.h	/^    utils::Check(devices.size() != 0,$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(devices.size() != 0, Ó)
mshadow::ps::LocalModel::utils::Check	include/mshadow-ps/ps_local-inl.h	/^    utils::Check(init_end == 0,$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(init_end == 0, Ó)
mshadow::ps::LocalModel::utils::ThreadExit	include/mshadow-ps/ps_local-inl.h	/^    utils::ThreadExit(NULL);$/;"	p	language:C++	class:mshadow::ps::LocalModel::utils	signature:(NULL)
mshadow::ps::LocalModel::w	include/mshadow-ps/ps_local-inl.h	/^          PullWaitRecord &w = e.wait[wid];$/;"	l	language:C++
mshadow::ps::LocalModel::w	include/mshadow-ps/ps_local-inl.h	/^    PullWaitRecord &w = e.wait[wid];$/;"	l	language:C++
mshadow::ps::LocalModel::wait_cond	include/mshadow-ps/ps_local-inl.h	/^  utils::ConditionVariable wait_cond;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::wait_lock	include/mshadow-ps/ps_local-inl.h	/^  utils::Mutex wait_lock;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
mshadow::ps::LocalModel::wid	include/mshadow-ps/ps_local-inl.h	/^        const int wid = GetWorkIndex(devid);$/;"	l	language:C++
mshadow::ps::LocalModel::wid	include/mshadow-ps/ps_local-inl.h	/^        const int wid = GetWorkIndex(tsk.devid);$/;"	l	language:C++
mshadow::ps::LocalModel::wid	include/mshadow-ps/ps_local-inl.h	/^      int wid = GetWorkIndex(devid);$/;"	l	language:C++
mshadow::ps::LocalModel::wid	include/mshadow-ps/ps_local-inl.h	/^    const int wid = GetWorkIndex(devid);$/;"	l	language:C++
mshadow::ps::LocalModel::~LocalModel	include/mshadow-ps/ps_local-inl.h	/^  virtual ~LocalModel(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(void)
mshadow::ps::MShadowServerNode	include/mshadow-ps/ps_dist-inl.h	/^class MShadowServerNode {$/;"	c	language:C++	namespace:mshadow::ps
mshadow::ps::MShadowServerNode::CHECK_NOTNULL	include/mshadow-ps/ps_dist-inl.h	/^         CHECK_NOTNULL(shared_model_));$/;"	p	language:C++	signature:(shared_model_)
mshadow::ps::MShadowServerNode::MShadowServerNode	include/mshadow-ps/ps_dist-inl.h	/^  MShadowServerNode(int argc, char *argv[]) {$/;"	f	language:C++	class:mshadow::ps::MShadowServerNode	access:public	signature:(int argc, char *argv[])
mshadow::ps::MShadowServerNode::MyRank	include/mshadow-ps/ps_dist-inl.h	/^    updater->InitUpdater(::ps::MyRank(), argc, argv);$/;"	p	language:C++	signature:()
mshadow::ps::MShadowServerNode::PSServer	include/mshadow-ps/ps_dist-inl.h	/^    typedef ::ps::KVLayer<DType, UpdaterWrapper<DType> > PSServer;$/;"	t	language:C++
mshadow::ps::MShadowServerNode::argc	include/mshadow-ps/ps_dist-inl.h	/^    updater->InitUpdater(::ps::MyRank(), argc, argv);$/;"	l	language:C++
mshadow::ps::MShadowServerNode::argv	include/mshadow-ps/ps_dist-inl.h	/^    updater->InitUpdater(::ps::MyRank(), argc, argv);$/;"	l	language:C++
mshadow::ps::MShadowServerNode::set_updater	include/mshadow-ps/ps_dist-inl.h	/^    shared_model_->set_updater(wrapper);$/;"	p	language:C++	signature:(wrapper)
mshadow::ps::MShadowServerNode::shared_model_	include/mshadow-ps/ps_dist-inl.h	/^    PSServer *shared_model_ = new PSServer();$/;"	l	language:C++
mshadow::ps::MShadowServerNode::updater	include/mshadow-ps/ps_dist-inl.h	/^    IModelUpdater<DType> *updater = CreateModelUpdater<DType>();$/;"	l	language:C++
mshadow::ps::MShadowServerNode::wrapper	include/mshadow-ps/ps_dist-inl.h	/^    UpdaterWrapper<DType> *wrapper = new UpdaterWrapper<DType>(updater);$/;"	l	language:C++
mshadow::ps::MShadowServerNode::~MShadowServerNode	include/mshadow-ps/ps_dist-inl.h	/^  virtual ~MShadowServerNode() { }$/;"	f	language:C++	class:mshadow::ps::MShadowServerNode	access:public	signature:()
mshadow::ps::RabitModel	include/mshadow-ps/ps_rabit-inl.h	/^class RabitModel : public LocalModel<xpu, DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:LocalModel
mshadow::ps::RabitModel::Destroy	include/mshadow-ps/ps_rabit-inl.h	/^      reduce_queue_.Destroy();$/;"	p	language:C++	signature:()
mshadow::ps::RabitModel::HandlePushFinish	include/mshadow-ps/ps_rabit-inl.h	/^  virtual void HandlePushFinish(Tensor<cpu, 3, DType> data,$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(Tensor<cpu, 3, DType> data, int key)
mshadow::ps::RabitModel::Init	include/mshadow-ps/ps_rabit-inl.h	/^    reduce_queue_.Init(true);$/;"	p	language:C++	signature:(true)
mshadow::ps::RabitModel::Init	include/mshadow-ps/ps_rabit-inl.h	/^  virtual void Init(const std::vector<int> &devices) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(const std::vector<int> &devices)
mshadow::ps::RabitModel::Join	include/mshadow-ps/ps_rabit-inl.h	/^      thread_reduce_handler_.Join();$/;"	p	language:C++	signature:()
mshadow::ps::RabitModel::LocalModel::ReduceSum	include/mshadow-ps/ps_rabit-inl.h	/^    LocalModel<xpu, DType>::ReduceSum(data);$/;"	p	language:C++	class:mshadow::ps::RabitModel::LocalModel	signature:(data)
mshadow::ps::RabitModel::Parent	include/mshadow-ps/ps_rabit-inl.h	/^  typedef LocalModel<xpu, DType> Parent;$/;"	t	language:C++	class:mshadow::ps::RabitModel	access:public
mshadow::ps::RabitModel::Parent::Destroy	include/mshadow-ps/ps_rabit-inl.h	/^    Parent::Destroy();$/;"	p	language:C++	class:mshadow::ps::RabitModel::Parent	signature:()
mshadow::ps::RabitModel::Parent::Init	include/mshadow-ps/ps_rabit-inl.h	/^    Parent::Init(devices);$/;"	p	language:C++	class:mshadow::ps::RabitModel::Parent	signature:(devices)
mshadow::ps::RabitModel::Parent::SetParam	include/mshadow-ps/ps_rabit-inl.h	/^    Parent::SetParam(name, val);$/;"	p	language:C++	class:mshadow::ps::RabitModel::Parent	signature:(name, val)
mshadow::ps::RabitModel::Push	include/mshadow-ps/ps_rabit-inl.h	/^    reduce_queue_.Push(tsk, 0);$/;"	p	language:C++	signature:(tsk, 0)
mshadow::ps::RabitModel::RabitModel	include/mshadow-ps/ps_rabit-inl.h	/^  RabitModel() {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:()
mshadow::ps::RabitModel::ReduceGlobalThread	include/mshadow-ps/ps_rabit-inl.h	/^  inline static MSHADOW_THREAD_PREFIX ReduceGlobalThread(void *pthread) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:private	signature:(void *pthread)
mshadow::ps::RabitModel::ReduceHandler	include/mshadow-ps/ps_rabit-inl.h	/^  inline void ReduceHandler(void) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:private	signature:(void)
mshadow::ps::RabitModel::ReduceTask	include/mshadow-ps/ps_rabit-inl.h	/^  struct ReduceTask {$/;"	s	language:C++	class:mshadow::ps::RabitModel	access:private
mshadow::ps::RabitModel::ReduceTask::data	include/mshadow-ps/ps_rabit-inl.h	/^    mshadow::Tensor<cpu, 2> data;$/;"	m	language:C++	struct:mshadow::ps::RabitModel::ReduceTask	access:public
mshadow::ps::RabitModel::ReduceTask::key	include/mshadow-ps/ps_rabit-inl.h	/^    int key;$/;"	m	language:C++	struct:mshadow::ps::RabitModel::ReduceTask	access:public
mshadow::ps::RabitModel::SetParam	include/mshadow-ps/ps_rabit-inl.h	/^  virtual void SetParam(const char *name, const char *val) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(const char *name, const char *val)
mshadow::ps::RabitModel::Start	include/mshadow-ps/ps_rabit-inl.h	/^    thread_reduce_handler_.Start(ReduceGlobalThread, this);$/;"	p	language:C++	signature:(ReduceGlobalThread, this)
mshadow::ps::RabitModel::destroy_reduce_thread_	include/mshadow-ps/ps_rabit-inl.h	/^  bool destroy_reduce_thread_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
mshadow::ps::RabitModel::disable_allreduce_	include/mshadow-ps/ps_rabit-inl.h	/^  int disable_allreduce_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
mshadow::ps::RabitModel::init_reducer_	include/mshadow-ps/ps_rabit-inl.h	/^  int init_reducer_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
mshadow::ps::RabitModel::key	include/mshadow-ps/ps_rabit-inl.h	/^        int key = tsk.key;$/;"	l	language:C++
mshadow::ps::RabitModel::rabit::Allreduce	include/mshadow-ps/ps_rabit-inl.h	/^        rabit::Allreduce<rabit::op::Sum>$/;"	p	language:C++	class:mshadow::ps::RabitModel::rabit	signature:(tsk.data.dptr_, tsk.data.MSize())
mshadow::ps::RabitModel::reduce_queue_	include/mshadow-ps/ps_rabit-inl.h	/^  utils::ThreadPQueue<ReduceTask> reduce_queue_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
mshadow::ps::RabitModel::thread_reduce_handler_	include/mshadow-ps/ps_rabit-inl.h	/^  utils::Thread thread_reduce_handler_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
mshadow::ps::RabitModel::tsk	include/mshadow-ps/ps_rabit-inl.h	/^      ReduceTask tsk;$/;"	l	language:C++
mshadow::ps::RabitModel::tsk	include/mshadow-ps/ps_rabit-inl.h	/^    ReduceTask tsk;$/;"	l	language:C++
mshadow::ps::RabitModel::utils::Assert	include/mshadow-ps/ps_rabit-inl.h	/^        utils::Assert(destroy_reduce_thread_, "abort but not destroy");$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(destroy_reduce_thread_, Ó)
mshadow::ps::RabitModel::utils::Assert	include/mshadow-ps/ps_rabit-inl.h	/^    utils::Assert(data[0].CheckContiguous(), "data must be contiguous");$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(data[0].CheckContiguous(), Ó)
mshadow::ps::RabitModel::utils::Check	include/mshadow-ps/ps_rabit-inl.h	/^        utils::Check(disable_allreduce_ == 0,$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(disable_allreduce_ == 0, Ó)
mshadow::ps::RabitModel::utils::Check	include/mshadow-ps/ps_rabit-inl.h	/^        utils::Check(key == tsk.key, "Allreduce not concensus");$/;"	p	language:C++	class:mshadow::ps::RabitModel::utils	signature:(key == tsk.key, Ó)
mshadow::ps::RabitModel::~RabitModel	include/mshadow-ps/ps_rabit-inl.h	/^  virtual ~RabitModel(void) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(void)
mshadow::ps::Updater	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^class Updater : public IModelUpdater<DType> {$/;"	c	language:C++	namespace:mshadow::ps	inherits:IModelUpdater
mshadow::ps::Updater::InitModel_	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  void InitModel_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::Updater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
mshadow::ps::Updater::Update_	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  void Update_(int key, Tensor<cpu, 1, DType> data) {$/;"	f	language:C++	class:mshadow::ps::Updater	access:protected	signature:(int key, Tensor<cpu, 1, DType> data)
mshadow::ps::Updater::data_	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  std::map<int, Tensor<cpu, 1, DType> > data_;$/;"	m	language:C++	class:mshadow::ps::Updater	access:protected
mshadow::ps::UpdaterWrapper	include/mshadow-ps/ps_dist-inl.h	/^class UpdaterWrapper {$/;"	c	language:C++	namespace:mshadow::ps
mshadow::ps::UpdaterWrapper::Init	include/mshadow-ps/ps_dist-inl.h	/^  void Init(int id, size_t size, DType* data) {$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:(int id, size_t size, DType* data)
mshadow::ps::UpdaterWrapper::InitModel	include/mshadow-ps/ps_dist-inl.h	/^    updater_->InitModel(id, data, size);$/;"	p	language:C++	signature:(id, data, size)
mshadow::ps::UpdaterWrapper::Update	include/mshadow-ps/ps_dist-inl.h	/^    updater_->Update(id, (DType*)recv_data, size);  \/\/ NOLINT(*)$/;"	p	language:C++	signature:(id, (DType*)recv_data, size)
mshadow::ps::UpdaterWrapper::Update	include/mshadow-ps/ps_dist-inl.h	/^  void Update(int id, size_t size, const DType* recv_data, DType* data) {$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:(int id, size_t size, const DType* recv_data, DType* data)
mshadow::ps::UpdaterWrapper::UpdaterWrapper	include/mshadow-ps/ps_dist-inl.h	/^  explicit UpdaterWrapper(IModelUpdater<DType> * updater)$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:(IModelUpdater<DType> * updater)
mshadow::ps::UpdaterWrapper::updater_	include/mshadow-ps/ps_dist-inl.h	/^  IModelUpdater<DType> *updater_;$/;"	m	language:C++	class:mshadow::ps::UpdaterWrapper	access:private
mshadow::ps::UpdaterWrapper::~UpdaterWrapper	include/mshadow-ps/ps_dist-inl.h	/^  ~UpdaterWrapper() { delete updater_; }$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:()
mshadow::pshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<4> pshape = Shape4(eshape.ProdShape(0, dimkeep),$/;"	l	language:C++
mshadow::pshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<4> pshape = Shape4(eshape.ProdShape(0, dimkeep),$/;"	l	language:C++
mshadow::red	include/mshadow/base.h	/^namespace red {$/;"	n	language:C++	namespace:mshadow
mshadow::red::limits	include/mshadow/base.h	/^namespace limits {$/;"	n	language:C++	namespace:mshadow::red
mshadow::red::limits::MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE DType MinValue(void);$/;"	p	language:C++	namespace:mshadow::red::limits	signature:(void)
mshadow::red::limits::MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE double MinValue<double>(void) {$/;"	f	language:C++	namespace:mshadow::red::limits	signature:(void)
mshadow::red::limits::MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE float MinValue<float>(void) {$/;"	f	language:C++	namespace:mshadow::red::limits	signature:(void)
mshadow::red::limits::MinValue	include/mshadow/base.h	/^MSHADOW_XINLINE int MinValue<int>(void) {$/;"	f	language:C++	namespace:mshadow::red::limits	signature:(void)
mshadow::red::maximum	include/mshadow/base.h	/^struct maximum {$/;"	s	language:C++	namespace:mshadow::red
mshadow::red::maximum::PartialGrad	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType PartialGrad(DType redres, DType redsrc) {$/;"	f	language:C++	struct:mshadow::red::maximum	access:public	signature:(DType redres, DType redsrc)
mshadow::red::maximum::Reduce	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Reduce(volatile DType& dst,  volatile DType src) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::maximum	access:public	signature:(volatile DType& dst, volatile DType src)
mshadow::red::maximum::SetInitValue	include/mshadow/base.h	/^  MSHADOW_XINLINE static void SetInitValue(DType &initv) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::maximum	access:public	signature:(DType &initv)
mshadow::red::sum	include/mshadow/base.h	/^struct sum {$/;"	s	language:C++	namespace:mshadow::red
mshadow::red::sum::PartialGrad	include/mshadow/base.h	/^  MSHADOW_XINLINE static DType PartialGrad(DType redres, DType redsrc) {$/;"	f	language:C++	struct:mshadow::red::sum	access:public	signature:(DType redres, DType redsrc)
mshadow::red::sum::Reduce	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Reduce(volatile DType& dst,  volatile DType src) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::sum	access:public	signature:(volatile DType& dst, volatile DType src)
mshadow::red::sum::SetInitValue	include/mshadow/base.h	/^  MSHADOW_XINLINE static void SetInitValue(DType &initv) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::red::sum	access:public	signature:(DType &initv)
mshadow::res	include/mshadow/tensor_cpu-inl.h	/^    DType res = splan.Eval(0, x);$/;"	l	language:C++
mshadow::res	include/mshadow/tensor_cpu-inl.h	/^    DType res; Reducer::SetInitValue(res);$/;"	l	language:C++
mshadow::s	include/mshadow/tensor.h	/^  Shape<1> s; s[0] = s0;$/;"	l	language:C++
mshadow::s	include/mshadow/tensor.h	/^  Shape<2> s; s[0] = s0; s[1] = s1;$/;"	l	language:C++
mshadow::s	include/mshadow/tensor.h	/^  Shape<3> s;$/;"	l	language:C++
mshadow::s	include/mshadow/tensor.h	/^  Shape<4> s;$/;"	l	language:C++
mshadow::shape	include/mshadow/io.h	/^  Shape<dim> shape;$/;"	l	language:C++
mshadow::shape	include/mshadow/tensor_cpu-inl.h	/^  Shape<2> shape = expr::ShapeCheck<dim, R>::Check(dst->self()).FlatTo2D();$/;"	l	language:C++
mshadow::splan	include/mshadow/tensor_cpu-inl.h	/^  expr::Plan<E, DType> splan = MakePlan(exp.self());$/;"	l	language:C++
mshadow::src	include/mshadow/io.h	/^  Tensor<cpu, 2, DType> src = src_.FlatTo2D();$/;"	l	language:C++
mshadow::src	include/mshadow/tensor_cpu-inl.h	/^  Tensor<cpu, 2, DType> src = _src.FlatTo2D();$/;"	l	language:C++
mshadow::src	include/mshadow/tensor_gpu-inl.h	/^  Tensor<B, 2, DType> src = _src.FlatTo2D();$/;"	l	language:C++
mshadow::sse2	include/mshadow/sse-inl.h	/^namespace sse2 {$/;"	n	language:C++	namespace:mshadow
mshadow::sse2::AlignedFree	include/mshadow/sse-inl.h	/^inline void AlignedFree(void *ptr) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(void *ptr)
mshadow::sse2::AlignedFree	include/mshadow/tensor_cpu-inl.h	/^  sse2::AlignedFree(dptr);$/;"	p	language:C++	class:mshadow::sse2	signature:(dptr)
mshadow::sse2::AlignedMallocPitch	include/mshadow/sse-inl.h	/^inline void* AlignedMallocPitch(size_t *out_pitch,$/;"	f	language:C++	namespace:mshadow::sse2	signature:(size_t *out_pitch, size_t lspace, size_t num_line)
mshadow::sse2::CheckAlign	include/mshadow/sse-inl.h	/^inline bool CheckAlign(size_t pitch) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(size_t pitch)
mshadow::sse2::CheckAlign	include/mshadow/sse-inl.h	/^inline bool CheckAlign(void *ptr) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(void *ptr)
mshadow::sse2::FVec	include/mshadow/sse-inl.h	/^struct FVec {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::FVec	include/mshadow/sse-inl.h	/^struct FVec<double> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::FVec	include/mshadow/sse-inl.h	/^struct FVec<float> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::FVec::DType	include/mshadow/sse-inl.h	/^  typedef __m128 DType;$/;"	t	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::DType	include/mshadow/sse-inl.h	/^  typedef __m128d DType;$/;"	t	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::FVec	include/mshadow/sse-inl.h	/^  FVec(void) {}$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(void)
mshadow::sse2::FVec::FVec	include/mshadow/sse-inl.h	/^  explicit FVec(DType data) : data_(data) {}$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(DType data)
mshadow::sse2::FVec::FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const double &s) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const double &s)
mshadow::sse2::FVec::FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const double *src) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const double *src)
mshadow::sse2::FVec::FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const float &s) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const float &s)
mshadow::sse2::FVec::FVec	include/mshadow/sse-inl.h	/^  explicit FVec(const float *src) {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(const float *src)
mshadow::sse2::FVec::Store	include/mshadow/sse-inl.h	/^  inline void Store(double *dst) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(double *dst) const
mshadow::sse2::FVec::Store	include/mshadow/sse-inl.h	/^  inline void Store(float *dst) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(float *dst) const
mshadow::sse2::FVec::Sum	include/mshadow/sse-inl.h	/^  inline double Sum(void) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(void) const
mshadow::sse2::FVec::Sum	include/mshadow/sse-inl.h	/^  inline float Sum(void) const {$/;"	f	language:C++	struct:mshadow::sse2::FVec	access:public	signature:(void) const
mshadow::sse2::FVec::ans	include/mshadow/sse-inl.h	/^    DType ans  = _mm_add_ps(data_, _mm_movehl_ps(data_, data_));$/;"	l	language:C++
mshadow::sse2::FVec::data_	include/mshadow/sse-inl.h	/^  DType data_;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = false;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = true;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::kSize	include/mshadow/sse-inl.h	/^  static const index_t kSize = 2;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::kSize	include/mshadow/sse-inl.h	/^  static const index_t kSize = 4;$/;"	m	language:C++	struct:mshadow::sse2::FVec	access:public
mshadow::sse2::FVec::rst	include/mshadow/sse-inl.h	/^    DType rst  = _mm_add_ss(ans, _mm_shuffle_ps(ans, ans, 1));$/;"	l	language:C++
mshadow::sse2::FVec::tmp	include/mshadow/sse-inl.h	/^    DType tmp =  _mm_add_sd(data_, _mm_unpackhi_pd(data_, data_));$/;"	l	language:C++
mshadow::sse2::LowerAlign	include/mshadow/sse-inl.h	/^inline index_t LowerAlign(index_t size, size_t fsize) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(index_t size, size_t fsize)
mshadow::sse2::SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::div> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::identity> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::minus> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::mul> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp<op::plus> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::SSEOp	include/mshadow/sse-inl.h	/^struct SSEOp{$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::SSEOp::Map	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE static FVec<double> Map(const FVec<double> &src) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<double> &src)
mshadow::sse2::SSEOp::Map	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE static FVec<float> Map(const FVec<float> &src) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<float> &src)
mshadow::sse2::SSEOp::Map	include/mshadow/sse-inl.h	/^  Map(const FVec<double> &lhs, const FVec<double> &rhs) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<double> &lhs, const FVec<double> &rhs)
mshadow::sse2::SSEOp::Map	include/mshadow/sse-inl.h	/^  Map(const FVec<float> &lhs, const FVec<float> &rhs) {$/;"	f	language:C++	struct:mshadow::sse2::SSEOp	access:public	signature:(const FVec<float> &lhs, const FVec<float> &rhs)
mshadow::sse2::SSEOp::kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = false;$/;"	m	language:C++	struct:mshadow::sse2::SSEOp	access:public
mshadow::sse2::SSEOp::kEnabled	include/mshadow/sse-inl.h	/^  static const bool kEnabled = true;$/;"	m	language:C++	struct:mshadow::sse2::SSEOp	access:public
mshadow::sse2::Saver	include/mshadow/sse-inl.h	/^struct Saver<sv::saveto, TFloat> {$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::Saver	include/mshadow/sse-inl.h	/^struct Saver{$/;"	s	language:C++	namespace:mshadow::sse2
mshadow::sse2::Saver::Save	include/mshadow/sse-inl.h	/^  MSHADOW_CINLINE static void Save(TFloat *dst, const FVec<TFloat> &src) {$/;"	f	language:C++	struct:mshadow::sse2::Saver	access:public	signature:(TFloat *dst, const FVec<TFloat> &src)
mshadow::sse2::Saver::Store	include/mshadow/sse-inl.h	/^    ans.Store(dst);$/;"	p	language:C++	signature:(dst)
mshadow::sse2::Saver::Store	include/mshadow/sse-inl.h	/^    src.Store(dst);$/;"	p	language:C++	signature:(dst)
mshadow::sse2::Saver::ans	include/mshadow/sse-inl.h	/^    FVec<TFloat> ans = SSEOp<typename SV::OPType>::Map(lhs, src);$/;"	l	language:C++
mshadow::sse2::Saver::lhs	include/mshadow/sse-inl.h	/^    FVec<TFloat> lhs(dst);$/;"	p	language:C++	signature:(dst)
mshadow::sse2::UpperAlign	include/mshadow/sse-inl.h	/^inline index_t UpperAlign(index_t size, size_t fsize) {$/;"	f	language:C++	namespace:mshadow::sse2	signature:(index_t size, size_t fsize)
mshadow::sse2::pitch	include/mshadow/sse-inl.h	/^  size_t pitch = ((lspace+15) >> 4) << 4;$/;"	l	language:C++
mshadow::sse2::res	include/mshadow/sse-inl.h	/^  void *res = _aligned_malloc(pitch * num_line, 16);$/;"	l	language:C++
mshadow::sse2::res	include/mshadow/sse-inl.h	/^  void *res = malloc(pitch * num_line);$/;"	l	language:C++
mshadow::sse2::res	include/mshadow/sse-inl.h	/^  void *res = memalign(16, pitch * num_line);$/;"	l	language:C++
mshadow::st	include/mshadow/stream_gpu-inl.h	/^  Stream<gpu> *st = new Stream<gpu>();$/;"	l	language:C++
mshadow::stream	include/mshadow/io.h	/^  Stream<gpu> stream;$/;"	l	language:C++
mshadow::sum	include/mshadow/tensor_cpu-inl.h	/^  DType sum = 0.0f;$/;"	l	language:C++
mshadow::sum	include/mshadow/tensor_cpu-inl.h	/^  DType sum = static_cast<DType>(0);$/;"	l	language:C++
mshadow::sv	include/mshadow/base.h	/^namespace sv {$/;"	n	language:C++	namespace:mshadow
mshadow::sv::divto	include/mshadow/base.h	/^struct divto {$/;"	s	language:C++	namespace:mshadow::sv
mshadow::sv::divto::OPType	include/mshadow/base.h	/^  typedef op::div OPType;$/;"	t	language:C++	struct:mshadow::sv::divto	access:public
mshadow::sv::divto::Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType& a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::divto	access:public	signature:(DType& a, DType b)
mshadow::sv::minusto	include/mshadow/base.h	/^struct minusto {$/;"	s	language:C++	namespace:mshadow::sv
mshadow::sv::minusto::AlphaBLAS	include/mshadow/base.h	/^  inline static default_real_t AlphaBLAS(void) { return -1.0f; }$/;"	f	language:C++	struct:mshadow::sv::minusto	access:public	signature:(void)
mshadow::sv::minusto::BetaBLAS	include/mshadow/base.h	/^  inline static default_real_t BetaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::minusto	access:public	signature:(void)
mshadow::sv::minusto::OPType	include/mshadow/base.h	/^  typedef op::minus OPType;$/;"	t	language:C++	struct:mshadow::sv::minusto	access:public
mshadow::sv::minusto::Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::minusto	access:public	signature:(DType &a, DType b)
mshadow::sv::multo	include/mshadow/base.h	/^struct multo {$/;"	s	language:C++	namespace:mshadow::sv
mshadow::sv::multo::OPType	include/mshadow/base.h	/^  typedef op::mul OPType;$/;"	t	language:C++	struct:mshadow::sv::multo	access:public
mshadow::sv::multo::Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::multo	access:public	signature:(DType &a, DType b)
mshadow::sv::plusto	include/mshadow/base.h	/^struct plusto {$/;"	s	language:C++	namespace:mshadow::sv
mshadow::sv::plusto::AlphaBLAS	include/mshadow/base.h	/^  inline static default_real_t AlphaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::plusto	access:public	signature:(void)
mshadow::sv::plusto::BetaBLAS	include/mshadow/base.h	/^  inline static default_real_t BetaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::plusto	access:public	signature:(void)
mshadow::sv::plusto::OPType	include/mshadow/base.h	/^  typedef op::plus OPType;$/;"	t	language:C++	struct:mshadow::sv::plusto	access:public
mshadow::sv::plusto::Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::plusto	access:public	signature:(DType &a, DType b)
mshadow::sv::saveto	include/mshadow/base.h	/^struct saveto {$/;"	s	language:C++	namespace:mshadow::sv
mshadow::sv::saveto::AlphaBLAS	include/mshadow/base.h	/^  inline static default_real_t AlphaBLAS(void) { return 1.0f; }$/;"	f	language:C++	struct:mshadow::sv::saveto	access:public	signature:(void)
mshadow::sv::saveto::BetaBLAS	include/mshadow/base.h	/^  inline static default_real_t BetaBLAS(void) { return 0.0f; }$/;"	f	language:C++	struct:mshadow::sv::saveto	access:public	signature:(void)
mshadow::sv::saveto::OPType	include/mshadow/base.h	/^  typedef op::right OPType;$/;"	t	language:C++	struct:mshadow::sv::saveto	access:public
mshadow::sv::saveto::Save	include/mshadow/base.h	/^  MSHADOW_XINLINE static void Save(DType &a, DType b) { \/\/ NOLINT(*)$/;"	f	language:C++	struct:mshadow::sv::saveto	access:public	signature:(DType &a, DType b)
mshadow::tmp	include/mshadow/io.h	/^  Tensor<cpu, dim, DType> tmp(src.shape_);$/;"	p	language:C++	signature:(src.shape_)
mshadow::tmp	include/mshadow/io.h	/^  Tensor<cpu, dim, DType> tmp;$/;"	l	language:C++
mshadow::tres	include/mshadow/tensor_cpu-inl.h	/^      DType tres; Reducer::SetInitValue(tres);$/;"	l	language:C++
mshadow::utils	include/mshadow-ps/thread.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
mshadow::utils	include/mshadow-ps/thread_util.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
mshadow::utils	include/mshadow/io.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
mshadow::utils	include/mshadow/utils.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
mshadow::utils::Assert	include/mshadow/utils.h	/^inline void Assert(bool exp, const char *fmt, ...) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(bool exp, const char *fmt, ...)
mshadow::utils::Check	include/mshadow/io.h	/^    utils::Check(fi.Read(dst[i].dptr_, sizeof(DType) * dst.size(1)) != 0,$/;"	p	language:C++	class:mshadow::utils	signature:(fi.Read(dst[i].dptr_, sizeof(DType) * dst.size(1)) != 0, Ó)
mshadow::utils::Check	include/mshadow/io.h	/^    utils::Check(shape == dst_->shape_,$/;"	p	language:C++	class:mshadow::utils	signature:(shape == dst_->shape_, Ó)
mshadow::utils::Check	include/mshadow/io.h	/^    utils::Check(tmp.shape == dst->shape_,$/;"	p	language:C++	class:mshadow::utils	signature:(tmp.shape == dst->shape_, Ó)
mshadow::utils::Check	include/mshadow/io.h	/^  utils::Check(fi.Read(&shape, sizeof(shape)) != 0, "mshadow::LoadBinary");$/;"	p	language:C++	class:mshadow::utils	signature:(fi.Read(&shape, sizeof(shape)) != 0, Ó)
mshadow::utils::Check	include/mshadow/stream_gpu-inl.h	/^  utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
mshadow::utils::Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(_dst.shape_ == _src.shape_, "Copy:shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(_dst.shape_ == _src.shape_, Ó)
mshadow::utils::Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(dst.shape_ == energy.shape_, "Softmax: shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(dst.shape_ == energy.shape_, Ó)
mshadow::utils::Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(eshape[0] == 0 || eshape == dshape,$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[0] == 0 || eshape == dshape, Ó)
mshadow::utils::Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(eshape[1] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[1] == dshape[0], Ó)
mshadow::utils::Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(eshape[dimkeep] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[dimkeep] == dshape[0], Ó)
mshadow::utils::Check	include/mshadow/tensor_cpu-inl.h	/^  utils::Check(lhs.shape_ == rhs.shape_, "VDot: shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(lhs.shape_ == rhs.shape_, Ó)
mshadow::utils::Check	include/mshadow/tensor_gpu-inl.h	/^    utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
mshadow::utils::Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(_dst.shape_ == _src.shape_, "Copy:shape mismatch");$/;"	p	language:C++	class:mshadow::utils	signature:(_dst.shape_ == _src.shape_, Ó)
mshadow::utils::Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(err == cudaSuccess, cudaGetErrorString(err));$/;"	p	language:C++	class:mshadow::utils	signature:(err == cudaSuccess, cudaGetErrorString(err))
mshadow::utils::Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(eshape[0] == 0 || eshape == dshape,$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[0] == 0 || eshape == dshape, Ó)
mshadow::utils::Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(eshape[1] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[1] == dshape[0], Ó)
mshadow::utils::Check	include/mshadow/tensor_gpu-inl.h	/^  utils::Check(eshape[dimkeep] == dshape[0],$/;"	p	language:C++	class:mshadow::utils	signature:(eshape[dimkeep] == dshape[0], Ó)
mshadow::utils::Check	include/mshadow/utils.h	/^inline void Check(bool exp, const char *fmt, ...) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(bool exp, const char *fmt, ...)
mshadow::utils::ConditionVariable	include/mshadow-ps/thread.h	/^class ConditionVariable {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::ConditionVariable::Broadcast	include/mshadow-ps/thread.h	/^  inline void Broadcast(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
mshadow::utils::ConditionVariable::Destroy	include/mshadow-ps/thread.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
mshadow::utils::ConditionVariable::Init	include/mshadow-ps/thread.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
mshadow::utils::ConditionVariable::Signal	include/mshadow-ps/thread.h	/^  inline void Signal(void) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(void)
mshadow::utils::ConditionVariable::Wait	include/mshadow-ps/thread.h	/^  inline void Wait(Mutex *mutex) {$/;"	f	language:C++	class:mshadow::utils::ConditionVariable	access:public	signature:(Mutex *mutex)
mshadow::utils::ConditionVariable::cond	include/mshadow-ps/thread.h	/^  CONDITION_VARIABLE cond;$/;"	m	language:C++	class:mshadow::utils::ConditionVariable	access:private
mshadow::utils::Error	include/mshadow/utils.h	/^inline void Error(const char *fmt, ...) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(const char *fmt, ...)
mshadow::utils::HandleAssertError	include/mshadow/utils.h	/^inline void HandleAssertError(const char *msg) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(const char *msg)
mshadow::utils::HandleAssertError	include/mshadow/utils.h	/^void HandleAssertError(const char *msg);$/;"	p	language:C++	namespace:mshadow::utils	signature:(const char *msg)
mshadow::utils::HandleCheckError	include/mshadow/utils.h	/^inline void HandleCheckError(const char *msg) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(const char *msg)
mshadow::utils::HandleCheckError	include/mshadow/utils.h	/^void HandleCheckError(const char *msg);$/;"	p	language:C++	namespace:mshadow::utils	signature:(const char *msg)
mshadow::utils::HandlePrint	include/mshadow/utils.h	/^void HandlePrint(const char *msg);$/;"	p	language:C++	namespace:mshadow::utils	signature:(const char *msg)
mshadow::utils::IStream	include/mshadow/io.h	/^class IStream {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::IStream::Read	include/mshadow/io.h	/^  virtual size_t Read(void *ptr, size_t size) = 0;$/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(void *ptr, size_t size)
mshadow::utils::IStream::Write	include/mshadow/io.h	/^  virtual void Write(const void *ptr, size_t size) = 0;$/;"	p	language:C++	class:mshadow::utils::IStream	access:public	signature:(const void *ptr, size_t size)
mshadow::utils::IStream::~IStream	include/mshadow/io.h	/^  virtual ~IStream(void) {}$/;"	f	language:C++	class:mshadow::utils::IStream	access:public	signature:(void)
mshadow::utils::Mutex	include/mshadow-ps/thread.h	/^class Mutex {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::Mutex::ConditionVariable	include/mshadow-ps/thread.h	/^  friend class ConditionVariable;$/;"	x	language:C++
mshadow::utils::Mutex::Destroy	include/mshadow-ps/thread.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
mshadow::utils::Mutex::Init	include/mshadow-ps/thread.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
mshadow::utils::Mutex::Lock	include/mshadow-ps/thread.h	/^  inline void Lock(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
mshadow::utils::Mutex::Unlock	include/mshadow-ps/thread.h	/^  inline void Unlock(void) {$/;"	f	language:C++	class:mshadow::utils::Mutex	access:public	signature:(void)
mshadow::utils::Mutex::mutex	include/mshadow-ps/thread.h	/^  CRITICAL_SECTION mutex;$/;"	m	language:C++	class:mshadow::utils::Mutex	access:private
mshadow::utils::Semaphore	include/mshadow-ps/thread.h	/^class Semaphore {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::Semaphore::Destroy	include/mshadow-ps/thread.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(void)
mshadow::utils::Semaphore::Init	include/mshadow-ps/thread.h	/^  inline void Init(int init_val) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(int init_val)
mshadow::utils::Semaphore::Post	include/mshadow-ps/thread.h	/^  inline void Post(void) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(void)
mshadow::utils::Semaphore::Wait	include/mshadow-ps/thread.h	/^  inline void Wait(void) {$/;"	f	language:C++	class:mshadow::utils::Semaphore	access:public	signature:(void)
mshadow::utils::Semaphore::sem	include/mshadow-ps/thread.h	/^  HANDLE sem;$/;"	m	language:C++	class:mshadow::utils::Semaphore	access:private
mshadow::utils::Semaphore::utils::ReleaseSemaphore	include/mshadow-ps/thread.h	/^    utils::Check(ReleaseSemaphore(sem, 1, NULL) != 0, "ReleaseSemaphore error");$/;"	p	language:C++	class:mshadow::utils::Semaphore::utils	signature:(sem, 1, NULL)
mshadow::utils::Thread	include/mshadow-ps/thread.h	/^class Thread {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::Thread::Join	include/mshadow-ps/thread.h	/^  inline int Join(void) {$/;"	f	language:C++	class:mshadow::utils::Thread	access:public	signature:(void)
mshadow::utils::Thread::Start	include/mshadow-ps/thread.h	/^  inline void Start(unsigned int __stdcall entry(void*p), void *param) {$/;"	f	language:C++	class:mshadow::utils::Thread	access:public	signature:(unsigned int __stdcall entry(void*p), void *param)
mshadow::utils::Thread::thread_handle	include/mshadow-ps/thread.h	/^  HANDLE    thread_handle;$/;"	m	language:C++	class:mshadow::utils::Thread	access:private
mshadow::utils::Thread::thread_id	include/mshadow-ps/thread.h	/^  unsigned  thread_id;$/;"	m	language:C++	class:mshadow::utils::Thread	access:private
mshadow::utils::ThreadExit	include/mshadow-ps/thread.h	/^inline void ThreadExit(void *status) {$/;"	f	language:C++	namespace:mshadow::utils	signature:(void *status)
mshadow::utils::ThreadPQueue	include/mshadow-ps/thread_util.h	/^class ThreadPQueue {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::ThreadPQueue::Abort	include/mshadow-ps/thread_util.h	/^  inline void Abort(int max_nthread = 1) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(int max_nthread = 1)
mshadow::utils::ThreadPQueue::Destroy	include/mshadow-ps/thread_util.h	/^    counter_.Destroy();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Destroy	include/mshadow-ps/thread_util.h	/^    lock_.Destroy();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Destroy	include/mshadow-ps/thread_util.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(void)
mshadow::utils::ThreadPQueue::Entry	include/mshadow-ps/thread_util.h	/^      pqueue_.push(Entry(data, priority));$/;"	p	language:C++	signature:(data, priority)
mshadow::utils::ThreadPQueue::Entry	include/mshadow-ps/thread_util.h	/^  struct Entry {$/;"	s	language:C++	class:mshadow::utils::ThreadPQueue	access:private
mshadow::utils::ThreadPQueue::Entry::Entry	include/mshadow-ps/thread_util.h	/^    Entry(const DType &data, int priority)$/;"	f	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public	signature:(const DType &data, int priority)
mshadow::utils::ThreadPQueue::Entry::data	include/mshadow-ps/thread_util.h	/^    DType data;$/;"	m	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public
mshadow::utils::ThreadPQueue::Entry::operator <	include/mshadow-ps/thread_util.h	/^    inline bool operator<(const Entry &b) const {$/;"	f	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public	signature:(const Entry &b) const
mshadow::utils::ThreadPQueue::Entry::priority	include/mshadow-ps/thread_util.h	/^    int priority;$/;"	m	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public
mshadow::utils::ThreadPQueue::Init	include/mshadow-ps/thread_util.h	/^    lock_.Init();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Init	include/mshadow-ps/thread_util.h	/^  inline void Init(bool use_fifo = false) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(bool use_fifo = false)
mshadow::utils::ThreadPQueue::Lock	include/mshadow-ps/thread_util.h	/^    lock_.Lock();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Pop	include/mshadow-ps/thread_util.h	/^  inline bool Pop(DType *data_out) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(DType *data_out)
mshadow::utils::ThreadPQueue::Post	include/mshadow-ps/thread_util.h	/^      counter_.Post();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Post	include/mshadow-ps/thread_util.h	/^    counter_.Post();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Push	include/mshadow-ps/thread_util.h	/^  inline void Push(const DType &data, int priority = 0) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:(const DType &data, int priority = 0)
mshadow::utils::ThreadPQueue::ThreadPQueue	include/mshadow-ps/thread_util.h	/^  ThreadPQueue() : use_fifo_(false) {$/;"	f	language:C++	class:mshadow::utils::ThreadPQueue	access:public	signature:()
mshadow::utils::ThreadPQueue::Unlock	include/mshadow-ps/thread_util.h	/^        lock_.Unlock(); return false;$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Unlock	include/mshadow-ps/thread_util.h	/^    lock_.Unlock();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::Wait	include/mshadow-ps/thread_util.h	/^    counter_.Wait();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::counter_	include/mshadow-ps/thread_util.h	/^  utils::Semaphore counter_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
mshadow::utils::ThreadPQueue::fqueue_	include/mshadow-ps/thread_util.h	/^  std::queue<DType> fqueue_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
mshadow::utils::ThreadPQueue::lock_	include/mshadow-ps/thread_util.h	/^  utils::Mutex lock_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
mshadow::utils::ThreadPQueue::pop	include/mshadow-ps/thread_util.h	/^      fqueue_.pop();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::pop	include/mshadow-ps/thread_util.h	/^      pqueue_.pop();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadPQueue::pqueue_	include/mshadow-ps/thread_util.h	/^  std::priority_queue<Entry> pqueue_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
mshadow::utils::ThreadPQueue::push	include/mshadow-ps/thread_util.h	/^      fqueue_.push(data);$/;"	p	language:C++	signature:(data)
mshadow::utils::ThreadPQueue::use_fifo_	include/mshadow-ps/thread_util.h	/^  bool use_fifo_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
mshadow::utils::ThreadPQueue::utils::Assert	include/mshadow-ps/thread_util.h	/^      utils::Assert(fqueue_.size() != 0, "Queue.Pop");$/;"	p	language:C++	class:mshadow::utils::ThreadPQueue::utils	signature:(fqueue_.size() != 0, Ó)
mshadow::utils::ThreadPQueue::utils::Assert	include/mshadow-ps/thread_util.h	/^      utils::Assert(pqueue_.size() != 0, "Queue.Pop");$/;"	p	language:C++	class:mshadow::utils::ThreadPQueue::utils	signature:(pqueue_.size() != 0, Ó)
mshadow::utils::ThreadSafeMap	include/mshadow-ps/thread_util.h	/^class ThreadSafeMap {$/;"	c	language:C++	namespace:mshadow::utils
mshadow::utils::ThreadSafeMap::Destroy	include/mshadow-ps/thread_util.h	/^    lock_.Destroy();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadSafeMap::Destroy	include/mshadow-ps/thread_util.h	/^  inline void Destroy(void) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(void)
mshadow::utils::ThreadSafeMap::Get	include/mshadow-ps/thread_util.h	/^  inline TValue *Get(int key) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(int key)
mshadow::utils::ThreadSafeMap::GetRef	include/mshadow-ps/thread_util.h	/^  inline TValue &GetRef(int key) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(int key)
mshadow::utils::ThreadSafeMap::Init	include/mshadow-ps/thread_util.h	/^    lock_.Init();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadSafeMap::Init	include/mshadow-ps/thread_util.h	/^  inline void Init(int key) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(int key)
mshadow::utils::ThreadSafeMap::Init	include/mshadow-ps/thread_util.h	/^  inline void Init(void) {$/;"	f	language:C++	class:mshadow::utils::ThreadSafeMap	access:public	signature:(void)
mshadow::utils::ThreadSafeMap::Lock	include/mshadow-ps/thread_util.h	/^    lock_.Lock();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadSafeMap::Unlock	include/mshadow-ps/thread_util.h	/^    lock_.Unlock();$/;"	p	language:C++	signature:()
mshadow::utils::ThreadSafeMap::it	include/mshadow-ps/thread_util.h	/^        it = map_.find(key);$/;"	l	language:C++
mshadow::utils::ThreadSafeMap::lock_	include/mshadow-ps/thread_util.h	/^  utils::Mutex lock_;$/;"	m	language:C++	class:mshadow::utils::ThreadSafeMap	access:private
mshadow::utils::ThreadSafeMap::map_	include/mshadow-ps/thread_util.h	/^  std::map<int, TValue*> map_;$/;"	m	language:C++	class:mshadow::utils::ThreadSafeMap	access:private
mshadow::utils::ThreadSafeMap::ret	include/mshadow-ps/thread_util.h	/^    TValue *ret = this->Get(key);$/;"	l	language:C++
mshadow::utils::ThreadSafeMap::ret	include/mshadow-ps/thread_util.h	/^    TValue *ret;$/;"	l	language:C++
mshadow::utils::args	include/mshadow/utils.h	/^    va_list args;$/;"	l	language:C++
mshadow::utils::kPrintBuffer	include/mshadow/utils.h	/^const int kPrintBuffer = 1 << 12;$/;"	m	language:C++	namespace:mshadow::utils
mshadow::utils::msg	include/mshadow/utils.h	/^    std::string msg(kPrintBuffer, '\\0');$/;"	p	language:C++	signature:(kPrintBuffer, Ã)
mul	include/mshadow/base.h	/^struct mul{$/;"	s	language:C++	namespace:mshadow::op
multiThread_miniBtach_data	depparser/Depparser.cpp	/^		std::vector<std::vector<GlobalExample*>> multiThread_miniBtach_data;$/;"	l	language:C++
multo	include/mshadow/base.h	/^struct multo {$/;"	s	language:C++	namespace:mshadow::sv
mutex	include/mshadow-ps/thread.h	/^  CRITICAL_SECTION mutex;$/;"	m	language:C++	class:mshadow::utils::Mutex	access:private
mxidx	include/mshadow-ps/ps_local-inl.h	/^    index_t mxidx = 0;$/;"	l	language:C++
n	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      const index_t n = i \/ pshape[2];$/;"	l	language:C++
n	include/mshadow/extension/channel_pool.h	/^    const index_t n = i \/ channel_;$/;"	l	language:C++
n	include/mshadow/extension/channel_unpool.h	/^    const index_t n = i \/ channel_;$/;"	l	language:C++
n	include/mshadow/extension/pack_col2patch.h	/^    const index_t n = idivh \/ i_channel_;$/;"	l	language:C++
n	include/mshadow/extension/swapaxis.h	/^    const index_t n = i % shapen_;$/;"	l	language:C++
n	include/mshadow/extension/swapaxis.h	/^    const index_t n = i \/ shapez_;$/;"	l	language:C++
n	include/mshadow/extension/unpack_patch2col.h	/^    const index_t n = jdivw \/ o_height_;$/;"	l	language:C++
nBatchNum	depparser/Config.cpp	/^			CConfig::nBatchNum = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nBatchNum	depparser/Config.cpp	/^int		CConfig::nBatchNum = 100;$/;"	m	language:C++	class:CConfig	file:
nBatchSize	depparser/Config.cpp	/^			CConfig::nBatchSize = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nBatchSize	depparser/Config.cpp	/^int 	CConfig::nBatchSize = 100;$/;"	m	language:C++	class:CConfig	file:
nBatchSize	depparser/Config.h	/^	static int nBatchSize;$/;"	m	language:C++	class:CConfig	access:public
nBeamSize	depparser/Config.h	/^	static int nBeamSize;$/;"	m	language:C++	class:CConfig	access:public
nEmbeddingDim	depparser/Config.cpp	/^            CConfig::nEmbeddingDim = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nEmbeddingDim	depparser/Config.cpp	/^int     CConfig::nEmbeddingDim;$/;"	m	language:C++	class:CConfig	file:
nEmbeddingDim	depparser/Config.h	/^    static int nEmbeddingDim;$/;"	m	language:C++	class:CConfig	access:public
nFeatureNum	depparser/Config.h	/^    static int nFeatureNum;$/;"	m	language:C++	class:CConfig	access:public
nHiddenSize	depparser/Config.h	/^	static int nHiddenSize;$/;"	m	language:C++	class:CConfig	access:public
nLabelNum	depparser/Config.h	/^	static int nLabelNum;$/;"	m	language:C++	class:CConfig	access:public
nLeft	depparser/Config.cpp	/^			CConfig::nLeft = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nLeft	depparser/Config.cpp	/^int		CConfig::nLeft = 3;$/;"	m	language:C++	class:CConfig	file:
nRight	depparser/Config.cpp	/^			CConfig::nRight = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nRight	depparser/Config.cpp	/^int		CConfig::nRight = 3;$/;"	m	language:C++	class:CConfig	file:
nRound	depparser/Config.cpp	/^			CConfig::nRound = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nRound	depparser/Config.cpp	/^int		CConfig::nRound		 = -1;$/;"	m	language:C++	class:CConfig	file:
nRound	depparser/Config.h	/^	static int nRound;$/;"	m	language:C++	class:CConfig	access:public
nThread	depparser/Config.cpp	/^			CConfig::nThread = atoi(pVal);$/;"	m	language:C++	class:CConfig	file:
nThread	depparser/Config.cpp	/^int		CConfig::nThread = 3;$/;"	m	language:C++	class:CConfig	file:
nThread	depparser/Config.h	/^	static int nThread;$/;"	m	language:C++	class:CConfig	access:public
nbatch	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t nbatch   = in.size(0);$/;"	l	language:C++
nchannel	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t nchannel = out.size(1);$/;"	l	language:C++
nchannel	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int nchannel = 10;$/;"	l	language:C++
ndev	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int ndev = argc - 2;$/;"	l	language:C++
ndim	include/mshadow/tensor_blob.h	/^  inline index_t ndim(void) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(void) const
ndim	include/mshadow/tensor_blob.h	/^  inline int ndim(void) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(void) const
ndim_	include/mshadow/tensor_blob.h	/^  index_t ndim_;$/;"	m	language:C++	struct:mshadow::TShape	access:private
nerr	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    long nerr = 0;$/;"	l	language:C++
nerr	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    long nerr = 0;$/;"	l	language:C++
nerr	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    long nerr = 0;$/;"	l	language:C++
net	depparser/Depparser.cpp	/^			    	NNet *net = new NNet<cpu>(beamSize, num_in, num_hidden, num_out);$/;"	l	language:C++
net	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  INNet *net;$/;"	l	language:C++
net	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  INNet *net;$/;"	l	language:C++
nets	depparser/Depparser.cpp	/^				std::vector<NNet*> nets;$/;"	l	language:C++
nets	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  std::vector<INNet *> nets(ndev);$/;"	p	language:C++	file:	signature:(ndev)
new_height_	include/mshadow/extension/crop.h	/^  const index_t new_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
new_height_	include/mshadow/extension/pad.h	/^  const index_t new_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
new_height_	include/mshadow/extension/spatial_pool.h	/^  const index_t new_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
next_correct_state	depparser/Depparser.cpp	/^						State* next_correct_state = lattice_index[round] + currentBeamSize;$/;"	l	language:C++
nflat	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> nflat, nout;$/;"	m	language:C++	class:ConvNet	file:	access:private
nhidden	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
nhidden	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
nhidden	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
nhidden	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
nhiddenbak	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
nhiddenbak	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
nhiddenbak	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
nhiddenbak	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
ninput	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
ninput	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
ninput	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
ninput	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
nlabel	thirdparty/mshadow/guide/neuralnet/util.h	/^  int num_image, width, height, nlabel;            $/;"	l	language:C++
node	depparser/DepTree.h	/^			is >> node;$/;"	l	language:C++
node	depparser/DepTree.h	/^		DepTreeNode node();$/;"	p	language:C++	signature:()
node	depparser/DepTree.h	/^		DepTreeNode node(root, root);$/;"	p	language:C++	signature:(root, root)
node	depparser/DepTree.h	/^		is >> node;$/;"	l	language:C++
node	thirdparty/mshadow/guide/mshadow-ps/README.md	/^in the following figure. Typically, a GPU card or a cpu core runs a worker node,$/;"	v	language:C++
nodes	depparser/DepTree.h	/^			os << nodes[i];$/;"	l	language:C++
nodes	depparser/DepTree.h	/^	std::vector<DepTreeNode> nodes;$/;"	m	language:C++	class:DepTree	access:private
nout	include/NNet.h	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	access:private
nout	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> nflat, nout;$/;"	m	language:C++	class:ConvNet	file:	access:private
nout	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
nout	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 2, real_t> ninput, nhidden, nhiddenbak, nout;$/;"	m	language:C++	class:NNet	file:	access:private
npool	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
npoolbak	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 4, real_t> ninput, nhidden, nhiddenbak, npool, npoolbak;$/;"	m	language:C++	class:ConvNet	file:	access:private
nsize_	include/mshadow/extension/channel_pool.h	/^  index_t nsize_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
nsize_	include/mshadow/extension/channel_unpool.h	/^  index_t nsize_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
ntask	include/mshadow-ps/ps_local-inl.h	/^      ms_omp_uint ntask = static_cast<ms_omp_uint>(data.size(1));$/;"	l	language:C++
nthread_reduction	include/mshadow-ps/ps_local-inl.h	/^  int nthread_reduction;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
null	depparser/DepAction.h	/^static std::string null = "-NULL-";$/;"	v	language:C++
num	include/mshadow/extension/unpack_patch2col.h	/^    const index_t num = imshape.ProdShape(0, srcdim - 3);$/;"	l	language:C++
num	include/mshadow/tensor.h	/^    index_t num = 1;$/;"	l	language:C++
num_block	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int num_block = (dshape[0] * xstride + kBaseThreadNum-1) \/ kBaseThreadNum;$/;"	l	language:C++
num_copied	include/mshadow-ps/ps_local-inl.h	/^    int num_copied;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
num_heap_allocated_	include/mshadow/tensor_blob.h	/^  index_t num_heap_allocated_;$/;"	m	language:C++	struct:mshadow::TShape	access:private
num_hidden	depparser/Depparser.cpp	/^	const int num_hidden = CConfig::nHiddenSize;$/;"	l	language:C++
num_hidden	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  int num_hidden = 100;$/;"	l	language:C++
num_hidden	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int num_hidden = 100;$/;"	l	language:C++
num_image	thirdparty/mshadow/guide/neuralnet/util.h	/^  int num_image, width, height, nlabel;            $/;"	l	language:C++
num_in	depparser/Depparser.cpp	/^	const int num_in = CConfig::nEmbeddingDim * CConfig::nFeatureNum;$/;"	l	language:C++
num_in	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  int num_in = 28 * 28;$/;"	l	language:C++
num_in	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int num_in = 28 * 28;$/;"	l	language:C++
num_iter	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int num_iter = 20;$/;"	l	language:C++
num_iter	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  int num_iter = 20;$/;"	l	language:C++
num_iter	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int num_iter = 20;$/;"	l	language:C++
num_out	depparser/Depparser.cpp	/^	const int num_out = kActNum;$/;"	l	language:C++
num_out	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int num_out = 10;$/;"	l	language:C++
num_out	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  int num_out = 10;$/;"	l	language:C++
num_out	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  int num_out = 10;$/;"	l	language:C++
num_results	depparser/Depparser.cpp	/^				int num_results = 0;$/;"	l	language:C++
num_servers	thirdparty/mshadow/guide/mshadow-ps/local.sh	/^num_servers=$1$/;"	v	language:C++
nwait	include/mshadow-ps/ps_local-inl.h	/^    int nwait;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullWaitRecord	access:public
o_height	include/mshadow/extension/pack_col2patch.h	/^    const index_t o_height = (imshape[dstdim - 2] - psize_y) \/ pstride + 1;$/;"	l	language:C++
o_height	include/mshadow/extension/unpack_patch2col.h	/^    const index_t o_height = (i_height_ - psize_y) \/ pstride + 1;$/;"	l	language:C++
o_height_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
o_width	include/mshadow/extension/pack_col2patch.h	/^    const index_t o_width  = (imshape[dstdim - 1] - psize_x) \/ pstride + 1;$/;"	l	language:C++
o_width	include/mshadow/extension/unpack_patch2col.h	/^    const index_t o_width  = (i_width_  - psize_x) \/ pstride + 1;$/;"	l	language:C++
o_width_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t i_height_, i_width_, o_height_, o_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
obias	include/NNet.h	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	access:private
obias	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:ConvNet	file:	access:private
obias	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
obias	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<xpu, 1, real_t> hbias, obias, g_hbias, g_obias;$/;"	m	language:C++	class:NNet	file:	access:private
obj	include/mshadow/tensor_cpu-inl.h	/^  Tensor<Device, dim, DType> obj(shape);$/;"	p	language:C++	signature:(shape)
oheight	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t oheight  = (in.size(2) - ksize)\/kstride + 1;$/;"	l	language:C++
op	include/mshadow-ps/ps_local-inl.h	/^    LocalOp op = kSum;$/;"	l	language:C++
op	include/mshadow/base.h	/^namespace op {$/;"	n	language:C++	namespace:mshadow
operator !=	include/mshadow/tensor.h	/^  MSHADOW_XINLINE bool operator!=(const Shape<kDimension> &s) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(const Shape<kDimension> &s) const
operator !=	include/mshadow/tensor_blob.h	/^  inline bool operator!=(const Shape<dim> &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const Shape<dim> &s) const
operator !=	include/mshadow/tensor_blob.h	/^  inline bool operator!=(const TShape &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &s) const
operator *	include/mshadow/expr_scalar-inl.h	/^operator*(MSHADOW_SCALAR_ lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(MSHADOW_SCALAR_ lhs, const DotExp<TA, TB, ltrans, rtrans, MSHADOW_SCALAR_> &rhs)
operator *	include/mshadow/expr_scalar-inl.h	/^operator*(MSHADOW_SCALAR_ scale, const ReduceTo1DExp<E, DType, R, d> &e) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(MSHADOW_SCALAR_ scale, const ReduceTo1DExp<E, DType, R, d> &e)
operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const DotExp<TA, TB, ltrans, rtrans, MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const DotExp<TA, TB, ltrans, rtrans, MSHADOW_SCALAR_> &lhs, MSHADOW_SCALAR_ rhs)
operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const ReduceTo1DExp<E, DType, R, d> &e, MSHADOW_SCALAR_ scale) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ReduceTo1DExp<E, DType, R, d> &e, MSHADOW_SCALAR_ scale)
operator *	include/mshadow/expr_scalar-inl.h	/^operator*(const ScalarExp<MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
operator *	include/mshadow/expression.h	/^operator*(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
operator *=	include/mshadow/expression.h	/^  inline Container &operator*=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
operator *=	include/mshadow/expression.h	/^  inline Container &operator*=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
operator +	include/mshadow/expr_scalar-inl.h	/^operator+(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
operator +	include/mshadow/expr_scalar-inl.h	/^operator+(const ScalarExp<MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
operator +	include/mshadow/expression.h	/^operator+(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
operator +=	include/mshadow/expression.h	/^  inline Container &operator+=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
operator +=	include/mshadow/expression.h	/^  inline Container &operator+=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
operator -	include/mshadow/expr_scalar-inl.h	/^operator-(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
operator -	include/mshadow/expr_scalar-inl.h	/^operator-(const ScalarExp<MSHADOW_SCALAR_> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
operator -	include/mshadow/expression.h	/^operator-(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
operator -=	include/mshadow/expression.h	/^  inline Container &operator-=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
operator -=	include/mshadow/expression.h	/^  inline Container &operator-=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
operator /	include/mshadow/expr_scalar-inl.h	/^operator\/(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, MSHADOW_SCALAR_, ta> &lhs, const ScalarExp<MSHADOW_SCALAR_> &rhs)
operator /	include/mshadow/expr_scalar-inl.h	/^operator\/(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const ScalarExp<MSHADOW_SCALAR_> &lhs, const Exp<TB, MSHADOW_SCALAR_, tb> &rhs)
operator /	include/mshadow/expression.h	/^operator\/(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<TA, DType, ta> &lhs, const Exp<TB, DType, tb> &rhs)
operator /=	include/mshadow/expression.h	/^  inline Container &operator\/=(DType s) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(DType s)
operator /=	include/mshadow/expression.h	/^  inline Container &operator\/=(const Exp<E, DType, etype> &exp) {$/;"	f	language:C++	class:mshadow::expr::RValueExp	access:public	signature:(const Exp<E, DType, etype> &exp)
operator <	include/mshadow-ps/thread_util.h	/^    inline bool operator<(const Entry &b) const {$/;"	f	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public	signature:(const Entry &b) const
operator <<	depparser/DepTree.h	/^	inline std::ostream & operator << (std::ostream &os, const DepTree &tree) {$/;"	f	language:C++	class:DepTree	access:public	signature:(std::ostream &os, const DepTree &tree)
operator <<	depparser/DepTreeNode.h	/^	inline std::ostream & operator << (std::ostream &os, const DepTreeNode &node) {$/;"	f	language:C++	class:DepTreeNode	access:public	signature:(std::ostream &os, const DepTreeNode &node)
operator =	include/mshadow/extension/concat.h	/^  operator=(const DType &exp) {$/;"	f	language:C++	struct:mshadow::expr::ConcatExp	access:public	signature:(const DType &exp)
operator =	include/mshadow/extension/concat.h	/^  operator=(const expr::Exp<E, DType, etype> &exp) {$/;"	f	language:C++	struct:mshadow::expr::ConcatExp	access:public	signature:(const expr::Exp<E, DType, etype> &exp)
operator =	include/mshadow/tensor.h	/^  inline Tensor<Device, 1, DType> &operator=(const DType &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const DType &exp)
operator =	include/mshadow/tensor.h	/^  inline Tensor<Device, dimension, DType> &operator=(const DType &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const DType &exp)
operator =	include/mshadow/tensor.h	/^  operator=(const Tensor<Device, 1, DType> &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Tensor<Device, 1, DType> &exp)
operator =	include/mshadow/tensor.h	/^  operator=(const Tensor<Device, dimension, DType> &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const Tensor<Device, dimension, DType> &exp)
operator =	include/mshadow/tensor.h	/^  operator=(const expr::Exp<E, DType, etype> &exp) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(const expr::Exp<E, DType, etype> &exp)
operator =	include/mshadow/tensor_blob.h	/^  &operator=(const Tensor<Device, dim, DType> &src) {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(const Tensor<Device, dim, DType> &src)
operator =	include/mshadow/tensor_blob.h	/^  inline TShape &operator=(const Shape<dim> &shape) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const Shape<dim> &shape)
operator =	include/mshadow/tensor_blob.h	/^  inline TShape &operator=(const TShape &shape) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &shape)
operator =	include/mshadow/tensor_blob.h	/^  inline TShape &operator=(const std::vector<index_t> &shape) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const std::vector<index_t> &shape)
operator =	include/mshadow/tensor_container.h	/^  inline Tensor<Device, dimension, DType> &operator=(DType s) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(DType s)
operator =	include/mshadow/tensor_container.h	/^  inline TensorContainer &operator=$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const TensorContainer<Device, dimension, DType> &src)
operator =	include/mshadow/tensor_container.h	/^  operator=(const expr::Exp<E, DType, expr::type::kChainer> &exp) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const expr::Exp<E, DType, expr::type::kChainer> &exp)
operator =	include/mshadow/tensor_container.h	/^  operator=(const expr::Exp<E, DType, expr::type::kComplex> &exp) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const expr::Exp<E, DType, expr::type::kComplex> &exp)
operator =	include/mshadow/tensor_container.h	/^  operator=(const expr::Exp<E, DType, expr::type::kMapper> &exp) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(const expr::Exp<E, DType, expr::type::kMapper> &exp)
operator ==	include/mshadow/tensor.h	/^  MSHADOW_XINLINE bool operator==(const Shape<kDimension> &s) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(const Shape<kDimension> &s) const
operator ==	include/mshadow/tensor_blob.h	/^  inline bool operator==(const Shape<dim> &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const Shape<dim> &s) const
operator ==	include/mshadow/tensor_blob.h	/^  inline bool operator==(const TShape &s) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(const TShape &s) const
operator >>	depparser/DepTree.h	/^	inline std::istream & operator >> (std::istream &is, DepTree &tree) {$/;"	f	language:C++	class:DepTree	access:public	signature:(std::istream &is, DepTree &tree)
operator >>	depparser/DepTreeNode.h	/^	inline std::istream & operator >> (std::istream &is, DepTreeNode &node) {$/;"	f	language:C++	class:DepTreeNode	access:public	signature:(std::istream &is, DepTreeNode &node)
operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE DType &operator[](index_t idx) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx)
operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE Tensor<Device, kSubdim, DType> operator[](index_t idx) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx) const
operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE const DType &operator[](index_t idx) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx) const
operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE const index_t &operator[](index_t idx) const {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(index_t idx) const
operator []	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t &operator[](index_t idx) {$/;"	f	language:C++	struct:mshadow::Shape	access:public	signature:(index_t idx)
operator []	include/mshadow/tensor_blob.h	/^  inline const index_t &operator[](index_t i) const {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(index_t i) const
operator []	include/mshadow/tensor_blob.h	/^  inline index_t &operator[](index_t i) {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:(index_t i)
oshapex_	include/mshadow/extension/reshape.h	/^  const index_t oshapex_, ishapex_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
oshapex_	include/mshadow/extension/reshape.h	/^  const index_t oshapex_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
out	thirdparty/mshadow/guide/README.md	/^Also note that the defined operation can be **composited into expressions**, not only we can write ```out = F<sigmoid>(in)```,$/;"	v	language:C++
out	thirdparty/mshadow/guide/README.md	/^we can also write ```out = F<sigmoid>+2.0``` or ```out = F<sigmoid>(F<sigmoid>(in))```.$/;"	v	language:C++
owidth	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    index_t owidth   = (in.size(3) - ksize)\/kstride + 1;$/;"	l	language:C++
p	include/mshadow-ps/ps_local-inl.h	/^        std::pair<LocalModel*, size_t> *p$/;"	l	language:C++
p	include/mshadow-ps/ps_local-inl.h	/^    PullEntry *p = pull_map.Get(key);$/;"	l	language:C++
p	include/mshadow-ps/ps_local-inl.h	/^    std::pair<LocalModel*, size_t> *p$/;"	l	language:C++
p	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      DType p = expf(src.Eval(y, x + threadIdx.x) - smax);$/;"	l	language:C++
pBlock	include/Pool.h	/^		SBlock * pBlock = (SBlock *)std::malloc( allocSize + sizeof( SBlock ) );$/;"	l	language:C++
pCurBlock	include/Pool.h	/^	SBlock * pCurBlock;$/;"	m	language:C++	class:CPool	access:private
pKey	depparser/Config.cpp	/^		char *pKey = strtok(buf, " \\r\\t\\n");$/;"	l	language:C++
pSizes	depparser/Config.cpp	/^			char *pSizes = pVal; $/;"	l	language:C++
pType	depparser/Config.cpp	/^			char *pType = pVal; $/;"	l	language:C++
pVal	depparser/Config.cpp	/^		char *pVal = strtok(NULL, " \\r\\t\\n");$/;"	l	language:C++
pack	thirdparty/mshadow/guide/neuralnet/util.h	/^int pack(unsigned char zz[4]){$/;"	f	language:C++	signature:(unsigned char zz[4])
pack_col2patch	include/mshadow/extension/pack_col2patch.h	/^pack_col2patch(const expr::Exp<SrcExp, DType, etype> &src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const expr::Exp<SrcExp, DType, etype> &src, Shape<dstdim> imshape, index_t psize_y, index_t psize_x, index_t pstride)
pad	include/mshadow/extension/pad.h	/^pad(const Exp<SrcExp, DType, etype> &src, index_t pad) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t pad)
pad	include/mshadow/extension/pad.h	/^pad(const Exp<SrcExp, DType, etype> &src, index_t pad_y, index_t pad_x) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t pad_y, index_t pad_x)
pad_	include/mshadow/extension/channel_pool.h	/^  index_t pad_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
pad_	include/mshadow/extension/channel_unpool.h	/^  index_t pad_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
pad_	include/mshadow/tensor_container.h	/^  bool pad_;$/;"	m	language:C++	class:mshadow::TensorContainer	access:private
pad_height_	include/mshadow/extension/crop.h	/^  const index_t pad_height_, pad_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
pad_height_	include/mshadow/extension/crop.h	/^  index_t pad_height_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
pad_width_	include/mshadow/extension/crop.h	/^  const index_t pad_height_, pad_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
pad_width_	include/mshadow/extension/crop.h	/^  index_t pad_width_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
pad_x_	include/mshadow/extension/pad.h	/^  const index_t pad_x_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
pad_x_	include/mshadow/extension/pad.h	/^  index_t pad_x_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
pad_y_	include/mshadow/extension/pad.h	/^  const index_t pad_y_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
pad_y_	include/mshadow/extension/pad.h	/^  index_t pad_y_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
parse	depparser/Depparser.cpp	/^void Depparser::parse(std::vector<DepParseInput> inputs) {$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs)
parse	depparser/Depparser.h	/^	void parse(std::vector<DepParseInput> inputs);$/;"	p	language:C++	class:Depparser	access:public	signature:(std::vector<DepParseInput> inputs)
path	depparser/Config.cpp	/^	string path(buf);$/;"	p	language:C++	file:	signature:(buf)
pchannel_	include/mshadow/extension/channel_unpool.h	/^  index_t pchannel_;$/;"	m	language:C++	struct:mshadow::expr::ChannelUnpoolingExp	access:public
pending	include/mshadow-ps/ps_local-inl.h	/^    bool pending;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
perdev_pull_thread	include/mshadow-ps/ps_local-inl.h	/^  int perdev_pull_thread;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
perdev_push_thread	include/mshadow-ps/ps_local-inl.h	/^  int perdev_push_thread;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
pin_memory	include/mshadow-ps/ps_local-inl.h	/^    bool pin_memory;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
pitch	include/mshadow/sse-inl.h	/^  size_t pitch = ((lspace+15) >> 4) << 4;$/;"	l	language:C++
pitch	include/mshadow/tensor_cpu-inl.h	/^  size_t pitch;$/;"	l	language:C++
plus	include/mshadow/base.h	/^struct plus {$/;"	s	language:C++	namespace:mshadow::op
plusto	include/mshadow/base.h	/^struct plusto {$/;"	s	language:C++	namespace:mshadow::sv
pool	include/mshadow/extension/spatial_pool.h	/^pool(const Exp<SrcExp, DType, etype> &src, Shape<2> pshape,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<2> pshape, index_t ksize_y, index_t ksize_x, index_t kstride)
pool	include/mshadow/extension/spatial_pool.h	/^pool(const Exp<SrcExp, DType, etype> &src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, index_t ksize_y, index_t ksize_x, index_t kstride)
pop	include/mshadow-ps/thread_util.h	/^      fqueue_.pop();$/;"	p	language:C++	signature:()
pop	include/mshadow-ps/thread_util.h	/^      pqueue_.pop();$/;"	p	language:C++	signature:()
pop_front	include/Pool.cpp	/^		m_listFree.pop_front();$/;"	p	language:C++	file:	signature:()
pop_front	include/Pool.cpp	/^		m_listUsed.pop_front();$/;"	p	language:C++	file:	signature:()
pop_heap	depparser/Depparser.h	/^		      std::pop_heap(beamTransitsint, beamTransitsint + beamSize,$/;"	p	language:C++	class:Depparser::std	signature:(beamTransitsint, beamTransitsint + beamSize, ScoredTransitionMore)
pqueue_	include/mshadow-ps/thread_util.h	/^  std::priority_queue<Entry> pqueue_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
pred	depparser/Depparser.cpp	/^			TensorContainer<cpu, 2> pred;$/;"	l	language:C++
pred	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<cpu, 2, real_t> pred;$/;"	l	language:C++
pred	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<cpu, 2, real_t> pred;$/;"	l	language:C++
pred	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      TensorContainer<cpu, 2, real_t> pred;$/;"	l	language:C++
previous_	depparser/State.h	/^	const State * previous_;$/;"	m	language:C++	class:State	access:public
priority	include/mshadow-ps/ps_local-inl.h	/^      push_queues[0].Push(PullTask(data, key, devid), priority);$/;"	l	language:C++
priority	include/mshadow-ps/ps_local-inl.h	/^      push_queues[wid].Push(PullTask(data, key, devid), priority);$/;"	l	language:C++
priority	include/mshadow-ps/ps_local-inl.h	/^    int priority;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
priority	include/mshadow-ps/thread_util.h	/^    int priority;$/;"	m	language:C++	struct:mshadow::utils::ThreadPQueue::Entry	access:public
product	thirdparty/mshadow/guide/README.md	/^We also have short hands for dot product, as like follows. The code will be translated to call standard packages such as MKL and CuBLAS.$/;"	v	language:C++
prop	include/mshadow/tensor_gpu-inl.h	/^  cudaDeviceProp prop;$/;"	l	language:C++
ps	include/mshadow-ps/mshadow_ps.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
ps	include/mshadow-ps/ps_dist-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
ps	include/mshadow-ps/ps_local-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
ps	include/mshadow-ps/ps_rabit-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
ps	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^      *ps = mshadow::ps::CreateSharedModel<xpu, float>("dist");$/;"	l	language:C++
ps	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
ps	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^      *ps = mshadow::ps::CreateSharedModel<xpu, float>("local");$/;"	l	language:C++
ps	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^namespace ps {$/;"	n	language:C++	namespace:mshadow
ps	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      *ps = mshadow::ps::CreateSharedModel<xpu, real_t>("local");$/;"	l	language:C++
ps	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  mshadow::ps::ISharedModel<xpu, real_t> *ps;$/;"	m	language:C++	class:NNet	file:	access:private
ps	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^namespace ps {$/;"	n	language:C++	namespace:mshadow	file:
pshape	include/mshadow/extension/channel_unpool.h	/^    Shape<srcdim> pshape = ShapeCheck<srcdim, SrcExp>::Check(grad_pooled);$/;"	l	language:C++
pshape	include/mshadow/extension/spatial_unpool.h	/^    Shape<srcdim> pshape = ShapeCheck<srcdim, SrcExp>::Check(grad_pooled);$/;"	l	language:C++
pshape	include/mshadow/tensor_cpu-inl.h	/^  Shape<4> pshape = Shape4(eshape.ProdShape(0, dimkeep),$/;"	l	language:C++
pshape	include/mshadow/tensor_gpu-inl.h	/^  Shape<4> pshape = Shape4(eshape.ProdShape(0, dimkeep),$/;"	l	language:C++
pshape_x_	include/mshadow/extension/spatial_unpool.h	/^  index_t pshape_x_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
pshape_y_	include/mshadow/extension/spatial_unpool.h	/^  index_t pshape_y_;$/;"	m	language:C++	struct:mshadow::expr::UnPoolingExp	access:public
psize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int ksize, kstride, psize;$/;"	m	language:C++	class:ConvNet	file:	access:private
psize	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  int psize = 2;$/;"	l	language:C++
psize_x	tags	/^mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
psize_x	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
psize_x_	include/mshadow/extension/pack_col2patch.h	/^  index_t psize_x_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
psize_x_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
psize_x_	include/mshadow/extension/unpack_patch2col.h	/^  index_t psize_x_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
psize_y	tags	/^mshadow::expr::UnpackPatchToColXExp::UnpackPatchToColXExp	include\/mshadow\/extension\/unpack_patch2col.h	\/^  UnpackPatchToColXExp(const SrcExp &img,$\/;"	f	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public	signature:(const SrcExp &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
psize_y	tags	/^mshadow::expr::unpack_patch2col	include\/mshadow\/extension\/unpack_patch2col.h	\/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$\/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)$/;"	m	language:C++	struct:__anon1::__anon2::Classifier::__anon3::__anon4::__anon5::Plan::__anon6::__anon7	file:	access:public
psize_y_	include/mshadow/extension/pack_col2patch.h	/^  index_t psize_y_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
psize_y_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
psize_y_	include/mshadow/extension/unpack_patch2col.h	/^  index_t psize_y_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
pstride_	include/mshadow/extension/pack_col2patch.h	/^  index_t pstride_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
pstride_	include/mshadow/extension/unpack_patch2col.h	/^  const index_t psize_y_, psize_x_, pstride_, i_channel_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
pstride_	include/mshadow/extension/unpack_patch2col.h	/^  index_t pstride_;$/;"	m	language:C++	struct:mshadow::expr::UnpackPatchToColXExp	access:public
ptrself	include/mshadow/expression.h	/^  inline SubType* ptrself(void) {$/;"	f	language:C++	struct:mshadow::expr::Exp	access:public	signature:(void)
pull_map	include/mshadow-ps/ps_local-inl.h	/^  utils::ThreadSafeMap<PullEntry> pull_map;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
pull_queues	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::ThreadPQueue<std::pair<int, int> > > pull_queues;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
pull_stream	include/mshadow-ps/ps_local-inl.h	/^  std::vector<Stream<xpu>*> pull_stream;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
push	include/mshadow-ps/thread_util.h	/^      fqueue_.push(data);$/;"	p	language:C++	signature:(data)
push_back	depparser/Config.cpp	/^				vHiddenType.push_back(pType);$/;"	p	language:C++	file:	signature:(pType)
push_back	depparser/DepTree.h	/^			nodes.push_back(node);$/;"	p	language:C++	signature:(node)
push_back	depparser/DepTree.h	/^		nodes.push_back(node);$/;"	p	language:C++	signature:(node)
push_back	depparser/DepTree.h	/^		nodes.push_back(rootnode);$/;"	p	language:C++	signature:(rootnode)
push_back	depparser/Depparser.cpp	/^			examples.push_back(example);$/;"	p	language:C++	file:	signature:(example)
push_back	depparser/Depparser.cpp	/^		featvecs.push_back(featvec);$/;"	p	language:C++	file:	signature:(featvec)
push_back	depparser/Depparser.cpp	/^	knowTags.push_back(null);$/;"	p	language:C++	file:	signature:(null)
push_back	depparser/Depparser.cpp	/^	knowTags.push_back(root);$/;"	p	language:C++	file:	signature:(root)
push_back	depparser/Depparser.cpp	/^	knowTags.push_back(unknow);$/;"	p	language:C++	file:	signature:(unknow)
push_back	depparser/Depparser.cpp	/^	knowWords.push_back(null);$/;"	p	language:C++	file:	signature:(null)
push_back	depparser/Depparser.cpp	/^	knowWords.push_back(root);$/;"	p	language:C++	file:	signature:(root)
push_back	depparser/Depparser.cpp	/^	knowWords.push_back(unknow);$/;"	p	language:C++	file:	signature:(unknow)
push_back	include/Pool.cpp	/^		m_listUsed.push_back (pCurBlock);$/;"	p	language:C++	file:	signature:(pCurBlock)
push_back	thirdparty/mshadow/guide/neuralnet/util.h	/^    rindex.push_back(i);$/;"	p	language:C++	signature:(i)
push_finish	include/mshadow-ps/ps_local-inl.h	/^        bool push_finish = e.num_copied >= static_cast<int>(devices.size());$/;"	l	language:C++
push_heap	depparser/Depparser.h	/^		      std::push_heap(beamTransitsint, beamTransitsint+ beamSize,$/;"	p	language:C++	class:Depparser::std	signature:(beamTransitsint, beamTransitsint+ beamSize, ScoredTransitionMore)
push_heap	depparser/Depparser.h	/^		std::push_heap(currentBeamSize,$/;"	p	language:C++	class:Depparser::std	signature:(currentBeamSize, currentBeamSize + currentBeamSize + 1, ScoredTransitionMore)
push_lock	include/mshadow-ps/ps_local-inl.h	/^  utils::Mutex push_lock;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
push_map	include/mshadow-ps/ps_local-inl.h	/^  utils::ThreadSafeMap<PushEntry> push_map;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
push_operation	include/mshadow-ps/ps_local-inl.h	/^  std::map<int, LocalOp> push_operation;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
push_queues	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::ThreadPQueue<PullTask> > push_queues;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
push_stream	include/mshadow-ps/ps_local-inl.h	/^  std::vector<Stream<xpu>*> push_stream;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
px	include/mshadow/extension/spatial_pool.h	/^    const index_t px = j;$/;"	l	language:C++
py	include/mshadow/extension/spatial_pool.h	/^    const index_t py = i % new_height_;$/;"	l	language:C++
q0	depparser/Depparser.cpp	/^	int q0 = state->m_nNextWord >= state->len_ ? -1 : state->m_nNextWord;$/;"	l	language:C++
q1	depparser/Depparser.cpp	/^	int q1 =$/;"	l	language:C++
q2	depparser/Depparser.cpp	/^	int q2 =$/;"	l	language:C++
r	include/mshadow-ps/ps_local-inl.h	/^          PullReqRecord &r = e.req[wid];$/;"	l	language:C++
r	include/mshadow-ps/ps_local-inl.h	/^    PullReqRecord &r = e.req[wid];$/;"	l	language:C++
rabit::Finalize	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  rabit::Finalize();$/;"	p	language:C++	class:rabit	signature:()
rabit::Init	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  rabit::Init(argc, argv);$/;"	p	language:C++	class:rabit	signature:(argc, argv)
rand_r	include/mshadow/random.h	15;"	d	language:C++
random_shuffle	depparser/Depparser.cpp	/^		std::random_shuffle ( gExamples.begin(), gExamples.end() );$/;"	p	language:C++	class:std	file:	signature:( gExamples.begin(), gExamples.end() )
ready	include/mshadow-ps/ps_local-inl.h	/^    bool ready;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullReqRecord	access:public
real_self	include/mshadow/expr_engine-inl.h	/^  inline const SubType& real_self(void) const{$/;"	f	language:C++	struct:mshadow::expr::MakeTensorExp	access:public	signature:(void) const
real_t	thirdparty/mshadow/guide/neuralnet/util.h	/^typedef float real_t;$/;"	t	language:C++
red	include/mshadow/base.h	/^namespace red {$/;"	n	language:C++	namespace:mshadow
reduce_queue_	include/mshadow-ps/ps_rabit-inl.h	/^  utils::ThreadPQueue<ReduceTask> reduce_queue_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
relu	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^struct relu{$/;"	s	language:C++	file:
relu::Map	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:relu	access:public	signature:(real_t a)
relu_grad	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^struct relu_grad {$/;"	s	language:C++	file:
relu_grad::Map	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:relu_grad	access:public	signature:(real_t a)
repeat	include/mshadow/cuda/tensor_gpu-inl.cuh	/^    int repeat = (num_block + kBaseGridNum-1) \/ kBaseGridNum;$/;"	l	language:C++
req	include/mshadow-ps/ps_local-inl.h	/^    std::vector<PullReqRecord> req;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public
request_lock	include/mshadow-ps/ps_local-inl.h	/^  utils::Mutex request_lock;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
rerr	include/mshadow-ps/ps_local-inl.h	/^    double rerr = diff \/ ssum;$/;"	l	language:C++
res	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType res; Reducer::SetInitValue(res);$/;"	l	language:C++
res	include/mshadow/extension/spatial_pool.h	/^    DType res; Reducer::SetInitValue(res);$/;"	l	language:C++
res	include/mshadow/sse-inl.h	/^  void *res = _aligned_malloc(pitch * num_line, 16);$/;"	l	language:C++
res	include/mshadow/sse-inl.h	/^  void *res = malloc(pitch * num_line);$/;"	l	language:C++
res	include/mshadow/sse-inl.h	/^  void *res = memalign(16, pitch * num_line);$/;"	l	language:C++
res	include/mshadow/tensor_cpu-inl.h	/^    DType res = splan.Eval(0, x);$/;"	l	language:C++
res	include/mshadow/tensor_cpu-inl.h	/^    DType res; Reducer::SetInitValue(res);$/;"	l	language:C++
res	thirdparty/mshadow/guide/basic_stream.cu	/^  Tensor<gpu, 2> res = NewTensor<gpu, float>(Shape2(2, 2), 0.0f);$/;"	l	language:C++
reshape	include/mshadow/extension/reshape.h	/^reshape(const Exp<SrcExp, DType, etype> &src, Shape<dimdst> oshape) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src, Shape<dimdst> oshape)
resize	depparser/Depparser.cpp	/^	gExamples.resize(inputs.size());  \/\/resize vector global examples$/;"	p	language:C++	file:	signature:(inputs.size())
resize	include/mshadow-ps/ps_local-inl.h	/^      copied.resize(ndevice, false);$/;"	p	language:C++	signature:(ndevice, false)
resize	include/mshadow-ps/ps_local-inl.h	/^      e.req.resize(devices.size(), PullReqRecord());$/;"	p	language:C++	signature:(devices.size(), PullReqRecord())
resize	include/mshadow-ps/ps_local-inl.h	/^      e.wait.resize(devices.size(), PullWaitRecord());$/;"	p	language:C++	signature:(devices.size(), PullWaitRecord())
resize	include/mshadow-ps/ps_local-inl.h	/^      pull_queues.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
resize	include/mshadow-ps/ps_local-inl.h	/^      push_queues.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
resize	include/mshadow-ps/ps_local-inl.h	/^      thread_pull_handler.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
resize	include/mshadow-ps/ps_local-inl.h	/^      thread_push_handler.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
resize	include/mshadow-ps/ps_local-inl.h	/^    pull_stream.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
resize	include/mshadow-ps/ps_local-inl.h	/^    push_stream.resize(devices.size());$/;"	p	language:C++	signature:(devices.size())
resize	thirdparty/mshadow/guide/neuralnet/util.h	/^  ylabel.resize(num_image);$/;"	p	language:C++	signature:(num_image)
ret	include/mshadow-ps/thread_util.h	/^    TValue *ret = this->Get(key);$/;"	l	language:C++
ret	include/mshadow-ps/thread_util.h	/^    TValue *ret;$/;"	l	language:C++
returnInput	depparser/Depparser.cpp	/^					fEmb.returnInput(featureVectors, input);$/;"	p	language:C++	file:	signature:(featureVectors, input)
returnInput	include/FeatureEmbedding.h	/^	void returnInput(std::vector< std::vector<int> >& featVecs, TensorContainer<xpu, 2>& input){$/;"	f	language:C++	class:FeatureEmbedding	access:public	signature:(std::vector< std::vector<int> >& featVecs, TensorContainer<xpu, 2>& input)
rhs_	include/mshadow/expr_engine-inl.h	/^  Plan<TB, DType> rhs_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
rhs_	include/mshadow/expression.h	/^  const TB &rhs_;$/;"	m	language:C++	struct:mshadow::expr::BinaryMapExp	access:public
rhs_	include/mshadow/expression.h	/^  const TB &rhs_;$/;"	m	language:C++	struct:mshadow::expr::DotExp	access:public
rhs_	include/mshadow/sse-inl.h	/^  SSEPlan<TB, DType> rhs_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
right	include/mshadow/base.h	/^struct right {$/;"	s	language:C++	namespace:mshadow::op
rindex	thirdparty/mshadow/guide/neuralnet/util.h	/^  std::vector<int> rindex;$/;"	l	language:C++
rnd	include/FeatureEmbedding.h	/^	Random<xpu> rnd;$/;"	m	language:C++	class:FeatureEmbedding	access:public
rnd	include/NNet.h	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:NNet	access:private
rnd	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:ConvNet	file:	access:private
rnd	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:NNet	file:	access:private
rnd	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  Random<xpu, real_t> rnd;$/;"	m	language:C++	class:NNet	file:	access:private
root	depparser/DepAction.h	/^static std::string root = "-ROOT-";$/;"	v	language:C++
rootLabel	depparser/State.h	/^	static std::string rootLabel = "root";$/;"	m	language:C++	class:State	access:public
rootLabelIndex	depparser/DepAction.h	/^static int rootLabelIndex = 1;$/;"	v	language:C++
rootnode	depparser/DepTree.h	/^		DepTreeNode rootnode(root, root);$/;"	p	language:C++	signature:(root, root)
round	depparser/Depparser.cpp	/^				int round = 0;$/;"	l	language:C++
routine	thirdparty/mshadow/guide/README.md	/^mshadow also provide explicit memory allocation routine, demonstrated shown by following code$/;"	v	language:C++
rseed_	include/mshadow/random.h	/^  unsigned rseed_;$/;"	m	language:C++	class:mshadow::Random	access:private
rst	include/mshadow/sse-inl.h	/^    DType rst  = _mm_add_ss(ans, _mm_shuffle_ps(ans, ans, 1));$/;"	l	language:C++
s	include/mshadow-ps/ps_local-inl.h	/^    Stream<xpu> s;$/;"	l	language:C++
s	include/mshadow/expr_engine-inl.h	/^    Shape<dim> s = ShapeCheck<dim, E>::Check(e.exp);$/;"	l	language:C++
s	include/mshadow/expr_engine-inl.h	/^    Shape<dim> s = ShapeCheck<dim, TA>::Check(t.src_);$/;"	l	language:C++
s	include/mshadow/random.h	/^    DType x, y, s;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^    Shape<1> s;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^    Shape<2> s;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^    Shape<dimend - dimstart> s;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^    Shape<dimension> s = this->shape_;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^    Shape<kSubdim> s;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^  Shape<1> s; s[0] = s0;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^  Shape<2> s; s[0] = s0; s[1] = s1;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^  Shape<3> s;$/;"	l	language:C++
s	include/mshadow/tensor.h	/^  Shape<4> s;$/;"	l	language:C++
s	include/mshadow/tensor_blob.h	/^    Shape<2> s;$/;"	l	language:C++
s	include/mshadow/tensor_blob.h	/^    Shape<dim> s;$/;"	l	language:C++
s0	depparser/Depparser.cpp	/^	int s0 = state->stacktop();$/;"	l	language:C++
s0l	depparser/Depparser.cpp	/^	int s0l, s0r, s0l2, s0r2, s0ll, s0rr;$/;"	l	language:C++
s0l2	depparser/Depparser.cpp	/^	int s0l, s0r, s0l2, s0r2, s0ll, s0rr;$/;"	l	language:C++
s0ll	depparser/Depparser.cpp	/^	int s0l, s0r, s0l2, s0r2, s0ll, s0rr;$/;"	l	language:C++
s0r	depparser/Depparser.cpp	/^	int s0l, s0r, s0l2, s0r2, s0ll, s0rr;$/;"	l	language:C++
s0r2	depparser/Depparser.cpp	/^	int s0l, s0r, s0l2, s0r2, s0ll, s0rr;$/;"	l	language:C++
s0rr	depparser/Depparser.cpp	/^	int s0l, s0r, s0l2, s0r2, s0ll, s0rr;$/;"	l	language:C++
s1	depparser/Depparser.cpp	/^	int s1 = state->stack2top();$/;"	l	language:C++
s1l	depparser/Depparser.cpp	/^	int s1l, s1r, s1l2, s1r2, s1ll, s1rr;$/;"	l	language:C++
s1l2	depparser/Depparser.cpp	/^	int s1l, s1r, s1l2, s1r2, s1ll, s1rr;$/;"	l	language:C++
s1ll	depparser/Depparser.cpp	/^	int s1l, s1r, s1l2, s1r2, s1ll, s1rr;$/;"	l	language:C++
s1r	depparser/Depparser.cpp	/^	int s1l, s1r, s1l2, s1r2, s1ll, s1rr;$/;"	l	language:C++
s1r2	depparser/Depparser.cpp	/^	int s1l, s1r, s1l2, s1r2, s1ll, s1rr;$/;"	l	language:C++
s1rr	depparser/Depparser.cpp	/^	int s1l, s1r, s1l2, s1r2, s1ll, s1rr;$/;"	l	language:C++
s2	depparser/Depparser.cpp	/^	int s2 = state->stack3top();$/;"	l	language:C++
s2	include/mshadow/tensor_container.h	/^    Shape<2> s2 = shape.FlatTo2D();$/;"	l	language:C++
s_rec	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  __shared__ DType s_rec[block_size];$/;"	l	language:C++
s_rec	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  __shared__ DType s_rec[x_size];  $/;"	l	language:C++
s_res	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  __shared__ DType s_res[warp_size][warp_size + 1];$/;"	l	language:C++
saveto	include/mshadow/base.h	/^struct saveto {$/;"	s	language:C++	namespace:mshadow::sv
scalar	include/mshadow/expression.h	/^inline ScalarExp<DType> scalar(DType s) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(DType s)
scalar_	include/mshadow/expr_engine-inl.h	/^  DType scalar_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
scalar_	include/mshadow/expression.h	/^  DType scalar_;$/;"	m	language:C++	struct:mshadow::expr::ScalarExp	access:public
scalar_	include/mshadow/sse-inl.h	/^  DType scalar_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
scale_	include/mshadow/expression.h	/^  DType scale_;$/;"	m	language:C++	struct:mshadow::expr::DotExp	access:public
scale_	include/mshadow/extension/reduceto1d.h	/^  DType scale_;$/;"	m	language:C++	struct:mshadow::expr::ReduceTo1DExp	access:public
score	depparser/State.h	/^	double score;$/;"	m	language:C++	class:State	access:public
see	thirdparty/mshadow/guide/README.md	/^As we can see, *no memory allocation* is happened in the translated code. For ```Tensor<gpu, k>```, the corresponding function will be translated into a CUDA kernel of same spirit.$/;"	v	language:C++
self	include/mshadow/expression.h	/^  inline const SubType& self(void) const {$/;"	f	language:C++	struct:mshadow::expr::Exp	access:public	signature:(void) const
sem	include/mshadow-ps/thread.h	/^  HANDLE sem;$/;"	m	language:C++	class:mshadow::utils::Semaphore	access:private
sendrecv	include/mshadow-ps/ps_dist-inl.h	/^    Tensor<cpu, 2> sendrecv = data[0];$/;"	l	language:C++
sentLen	depparser/Depparser.cpp	/^				const int sentLen = example->wordIdx.size();$/;"	l	language:C++
server	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum.cpp	/^  mshadow::ps::MShadowServerNode<float> server(argc, argv);$/;"	p	language:C++	file:	signature:(argc, argv)
setBeamIdx	depparser/Depparser.cpp	/^							target->setBeamIdx(i);$/;"	p	language:C++	file:	signature:(i)
setBeamIdx	depparser/State.h	/^	inline void setBeamIdx(int idx){$/;"	f	language:C++	class:State	access:public	signature:(int idx)
setHead	depparser/DepTree.h	/^	inline void setHead(int child, int head){ nodes[child].head = head; }$/;"	f	language:C++	class:DepTree	access:public	signature:(int child, int head)
setLabel	depparser/DepTree.h	/^	inline void setLabel(int child, std::string label){ nodes[child].label = label; }$/;"	f	language:C++	class:DepTree	access:public	signature:(int child, std::string label)
setParas	depparser/Depparser.cpp	/^		gExamples[i].setParas(examples, acts, wordIndexCache, tagIndexCache);$/;"	p	language:C++	file:	signature:(examples, acts, wordIndexCache, tagIndexCache)
setParas	depparser/GlobalExample.h	/^	inline void setParas(std::vector<Example> & es, std::vector<int>& acts,$/;"	f	language:C++	class:GlobalExample	access:public	signature:(std::vector<Example> & es, std::vector<int>& acts, std::vector<int> & wIdx, std::vector<int> & tIdx)
set_pad	include/mshadow/tensor_container.h	/^  inline void set_pad(bool pad) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(bool pad)
set_stream	include/NNet.h	/^    Wh2o.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    Wi2h.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    g_Wh2o.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    g_Wi2h.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    g_hbias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    g_obias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    hbias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    nhidden.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    ninput.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    nout.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/NNet.h	/^    obias.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	include/mshadow/random.h	/^  inline void set_stream(Stream<cpu> *stream) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Stream<cpu> *stream)
set_stream	include/mshadow/random.h	/^  inline void set_stream(Stream<gpu> *stream) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Stream<gpu> *stream)
set_stream	include/mshadow/tensor.h	/^  inline void set_stream(Stream<Device> *stream) {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(Stream<Device> *stream)
set_stream	thirdparty/mshadow/guide/mshadow-ps/README.md	/^  data.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  data.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  data.set_stream(stream);$/;"	p	language:C++	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Ki2h.set_stream(stream);  g_Ki2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Wh2o.set_stream(stream);   g_Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    hbias.set_stream(stream); g_hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nflat.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhidden.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    ninput.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    nout.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npool.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    npoolbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    obias.set_stream(stream);  g_obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_col.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    tmp_dst.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    g_obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhidden.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    ninput.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    nout.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      weight.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_Wh2o.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_Wi2h.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    g_obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    hbias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhidden.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nhiddenbak.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    ninput.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    nout.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    obias.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    rnd.set_stream(stream);$/;"	p	language:C++	file:	signature:(stream)
set_updater	include/mshadow-ps/ps_dist-inl.h	/^    shared_model_->set_updater(wrapper);$/;"	p	language:C++	signature:(wrapper)
shape	include/mshadow/expr_engine-inl.h	/^    Shape<dim> shape; shape[0] = 0;$/;"	l	language:C++
shape	include/mshadow/io.h	/^  Shape<dim> shape;$/;"	l	language:C++
shape	include/mshadow/tensor_cpu-inl.h	/^  Shape<2> shape = expr::ShapeCheck<dim, R>::Check(dst->self()).FlatTo2D();$/;"	l	language:C++
shape1	include/mshadow/expr_engine-inl.h	/^    Shape<dim> shape1 = ShapeCheck<dim, TA>::Check(t.lhs_);$/;"	l	language:C++
shape2	include/mshadow/expr_engine-inl.h	/^    Shape<dim> shape2 = ShapeCheck<dim, TB>::Check(t.rhs_);$/;"	l	language:C++
shape2	thirdparty/mshadow/guide/README.md	/^Shape<2> shape2;$/;"	v	language:C++
shape_	include/mshadow/expr_engine-inl.h	/^  Shape<dim> shape_;$/;"	m	language:C++	struct:mshadow::expr::MakeTensorExp	access:public
shape_	include/mshadow/extension/concat.h	/^  Shape<4> shape_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
shape_	include/mshadow/tensor.h	/^  Shape<1> shape_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
shape_	include/mshadow/tensor.h	/^  Shape<dimension> shape_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
shape_	include/mshadow/tensor.h	/^  index_t shape_[kDimension];$/;"	m	language:C++	struct:mshadow::Shape	access:public
shape_	include/mshadow/tensor_blob.h	/^  TShape shape_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
shape_	thirdparty/mshadow/guide/README.md	/^  Shape<2> shape_;$/;"	m	language:C++	struct:Tensor	file:	access:public
shape_	thirdparty/mshadow/guide/README.md	/^  Shape<dimension> shape_;$/;"	m	language:C++	struct:Tensor	file:	access:public
shape_	thirdparty/mshadow/guide/README.md	/^  index_t shape_[2];$/;"	m	language:C++	struct:Shape	file:	access:public
shape_	thirdparty/mshadow/guide/README.md	/^  index_t shape_[dimension];$/;"	m	language:C++	struct:Shape	file:	access:public
shapec_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shapen_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shapex_	include/mshadow/extension/swapaxis.h	/^  const index_t shapex_, shapey_, shapez_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shapey_	include/mshadow/extension/swapaxis.h	/^  const index_t shapex_, shapey_, shapez_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shapey_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shapez_	include/mshadow/extension/swapaxis.h	/^  const index_t shapex_, shapey_, shapez_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shapez_	include/mshadow/extension/swapaxis.h	/^  const index_t shapey_, shapez_, shapec_, shapen_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
shared_model_	include/mshadow-ps/ps_dist-inl.h	/^    PSServer *shared_model_ = new PSServer();$/;"	l	language:C++
shared_model_	include/mshadow-ps/ps_dist-inl.h	/^  ::ps::KVLayer<DType, UpdaterWrapper<DType> > shared_model_;$/;"	m	language:C++	class:mshadow::ps::DistModel	access:private
shuffle	thirdparty/mshadow/guide/neuralnet/util.h	/^inline void shuffle(T *data, size_t sz){$/;"	f	language:C++	signature:(T *data, size_t sz)
shuffle	thirdparty/mshadow/guide/neuralnet/util.h	/^inline void shuffle(std::vector<T> &data){$/;"	f	language:C++	signature:(std::vector<T> &data)
sigmoid	include/NNet.h	/^struct sigmoid{$/;"	s	language:C++
sigmoid	thirdparty/mshadow/guide/README.md	/^struct sigmoid {$/;"	s	language:C++	file:
sigmoid	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^struct sigmoid{$/;"	s	language:C++	file:
sigmoid	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^struct sigmoid {$/;"	s	language:C++	file:
sigmoid::Map	include/NNet.h	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(real_t a)
sigmoid::Map	thirdparty/mshadow/guide/README.md	/^  MSHADOW_XINLINE static float Map(float a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(float a)
sigmoid::Map	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(real_t a)
sigmoid::Map	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  MSHADOW_XINLINE static real_t Map(real_t a) {$/;"	f	language:C++	struct:sigmoid	access:public	signature:(real_t a)
size	depparser/DepTree.h	/^	int size;$/;"	m	language:C++	class:DepTree	access:public
size	include/mshadow/tensor.h	/^    size_t size = this->shape_[0];$/;"	l	language:C++
size	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t size(index_t i) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t i) const
size	include/mshadow/tensor.h	/^  MSHADOW_XINLINE index_t size(index_t idx) const {$/;"	f	language:C++	struct:mshadow::Tensor	access:public	signature:(index_t idx) const
size	include/mshadow/tensor_blob.h	/^    size_t size = 1;$/;"	l	language:C++
size	include/mshadow/tensor_blob.h	/^  inline index_t size(index_t idx) const {$/;"	f	language:C++	class:mshadow::TBlob	access:public	signature:(index_t idx) const
sleft	include/mshadow/dot_engine-inl.h	/^    Shape<2> sleft = GetShape(lhs.shape_, transpose_left);$/;"	l	language:C++
sm1	thirdparty/mshadow/guide/basic_stream.cu	/^  Stream<gpu> *sm1 = NewStream<gpu>();$/;"	l	language:C++
sm2	thirdparty/mshadow/guide/basic_stream.cu	/^  Stream<gpu> *sm2 = NewStream<gpu>();$/;"	l	language:C++
smax	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType smax = s_rec[0];$/;"	l	language:C++
sp	depparser/Depparser.cpp	/^		auto sp = gExamples.begin();$/;"	l	language:C++
splan	include/mshadow/tensor_cpu-inl.h	/^  expr::Plan<E, DType> splan = MakePlan(exp.self());$/;"	l	language:C++
splice	include/Pool.cpp	/^	m_listFree.splice (m_listFree.begin(),  m_listUsed);$/;"	p	language:C++	file:	signature:(m_listFree.begin(), m_listUsed)
src	include/mshadow-ps/ps_local-inl.h	/^    Tensor<cpu, 2, DType> src;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public
src	include/mshadow/io.h	/^  Tensor<cpu, 2, DType> src = src_.FlatTo2D();$/;"	l	language:C++
src	include/mshadow/tensor_blob.h	/^    const index_t *src = shape.data();$/;"	l	language:C++
src	include/mshadow/tensor_cpu-inl.h	/^  Tensor<cpu, 2, DType> src = _src.FlatTo2D();$/;"	l	language:C++
src	include/mshadow/tensor_gpu-inl.h	/^  Tensor<B, 2, DType> src = _src.FlatTo2D();$/;"	l	language:C++
src1_	include/mshadow/extension/concat.h	/^  Plan<LhsExp, DType> src1_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src1_	include/mshadow/extension/concat.h	/^  const LhsExp &src1_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
src2_	include/mshadow/extension/concat.h	/^  Plan<RhsExp, DType> src2_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src2_	include/mshadow/extension/concat.h	/^  const RhsExp &src2_;$/;"	m	language:C++	struct:mshadow::expr::ConcatExp	access:public
src_	include/mshadow/expr_engine-inl.h	/^  Plan<EType, DType> src_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
src_	include/mshadow/expr_engine-inl.h	/^  Plan<EType, SrcDType> src_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
src_	include/mshadow/expr_engine-inl.h	/^  Plan<SubType, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/expr_engine-inl.h	/^  Plan<TA, DType> src_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
src_	include/mshadow/expression.h	/^  const TA &src_;$/;"	m	language:C++	struct:mshadow::expr::UnaryMapExp	access:public
src_	include/mshadow/extension/broadcast.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::Broadcast1DExp	access:public
src_	include/mshadow/extension/channel_pool.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
src_	include/mshadow/extension/crop.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/extension/crop.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
src_	include/mshadow/extension/mirror.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/extension/mirror.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::MirroringExp	access:public
src_	include/mshadow/extension/pack_col2patch.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::PackColToPatchXExp	access:public
src_	include/mshadow/extension/pad.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/extension/pad.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
src_	include/mshadow/extension/reduceto1d.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::ReduceTo1DExp	access:public
src_	include/mshadow/extension/reshape.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/extension/reshape.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::ReshapeExp	access:public
src_	include/mshadow/extension/spatial_pool.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/extension/spatial_pool.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
src_	include/mshadow/extension/swapaxis.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/extension/swapaxis.h	/^  const SrcExp &src_;$/;"	m	language:C++	struct:mshadow::expr::SwapAxisExp	access:public
src_	include/mshadow/extension/unpack_patch2col.h	/^  Plan<SrcExp, DType> src_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_	include/mshadow/sse-inl.h	/^  SSEPlan<TA, DType> src_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
src_channel_	include/mshadow/extension/channel_pool.h	/^  index_t src_channel_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
src_height_	include/mshadow/extension/crop.h	/^  const index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_height_	include/mshadow/extension/crop.h	/^  index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::CroppingExp	access:public
src_height_	include/mshadow/extension/pad.h	/^  const index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_height_	include/mshadow/extension/pad.h	/^  index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
src_height_	include/mshadow/extension/spatial_pool.h	/^  const index_t src_height_, src_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_height_	include/mshadow/extension/spatial_pool.h	/^  index_t src_height_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
src_width_	include/mshadow/extension/pad.h	/^  const index_t src_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_width_	include/mshadow/extension/pad.h	/^  index_t src_width_;$/;"	m	language:C++	struct:mshadow::expr::PaddingExp	access:public
src_width_	include/mshadow/extension/spatial_pool.h	/^  const index_t src_height_, src_width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
src_width_	include/mshadow/extension/spatial_pool.h	/^  index_t src_width_;$/;"	m	language:C++	struct:mshadow::expr::PoolingExp	access:public
sright	include/mshadow/dot_engine-inl.h	/^    Shape<2> sright = GetShape(rhs.shape, transpose_right);$/;"	l	language:C++
sright	include/mshadow/dot_engine-inl.h	/^    Shape<2> sright = GetShape(rhs.shape_, transpose_right);$/;"	l	language:C++
ss	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^  std::stringstream ss;$/;"	l	language:C++
sse2	include/mshadow/sse-inl.h	/^namespace sse2 {$/;"	n	language:C++	namespace:mshadow
sshape	include/mshadow/extension/channel_unpool.h	/^    Shape<srcdim> sshape = ShapeCheck<srcdim, SrcExp>::Check(data_src);$/;"	l	language:C++
sshape	include/mshadow/extension/pack_col2patch.h	/^    Shape<2> sshape = ShapeCheck<2, SrcExp>::Check(src_);$/;"	l	language:C++
sshape	include/mshadow/extension/spatial_pool.h	/^    Shape<srcdim> sshape = ShapeCheck<srcdim, SrcExp>::Check(src_);$/;"	l	language:C++
sshape	include/mshadow/extension/spatial_unpool.h	/^    Shape<srcdim> sshape = ShapeCheck<srcdim, SrcExp>::Check(data_src);$/;"	l	language:C++
sshape1	include/mshadow/extension/concat.h	/^    Shape<srcdim> sshape1 = ShapeCheck<srcdim, LhsExp>::Check(src1_);$/;"	l	language:C++
sshape2	include/mshadow/extension/concat.h	/^    Shape<srcdim> sshape2 = ShapeCheck<srcdim, RhsExp>::Check(src2_);$/;"	l	language:C++
ssum	include/mshadow-ps/ps_local-inl.h	/^    double diff = 0.0, ssum = 0.0, maxdiff = 0.0;$/;"	l	language:C++
ssum	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  DType ssum = s_rec[0];$/;"	l	language:C++
st	include/mshadow/stream_gpu-inl.h	/^  Stream<gpu> *st = new Stream<gpu>();$/;"	l	language:C++
stack2top	depparser/State.h	/^	inline int stack2top() const {$/;"	f	language:C++	class:State	access:public	signature:() const
stack3top	depparser/State.h	/^	inline int stack3top() const {$/;"	f	language:C++	class:State	access:public	signature:() const
stackbottom	depparser/State.h	/^	inline int stackbottom() const {$/;"	f	language:C++	class:State	access:public	signature:() const
stackempty	depparser/State.h	/^	inline bool stackempty() const {$/;"	f	language:C++	class:State	access:public	signature:() const
stackitem	depparser/State.h	/^	inline int stackitem(const int & id) const {$/;"	f	language:C++	class:State	access:public	signature:(const int & id) const
stacksize	depparser/State.h	/^	inline int stacksize() const {$/;"	f	language:C++	class:State	access:public	signature:() const
stacktop	depparser/State.h	/^	inline int stacktop() const {$/;"	f	language:C++	class:State	access:public	signature:() const
state	depparser/Depparser.cpp	/^		State* state = new State();$/;"	l	language:C++
stateIdx	depparser/Depparser.cpp	/^					int stateIdx = 0;$/;"	l	language:C++
status	include/mshadow/random.h	/^    curandStatus_t status;$/;"	l	language:C++
status	include/mshadow/random.h	/^    int status = vdRngGaussian(0, vStream_, size, dptr, mu, sigma);$/;"	l	language:C++
status	include/mshadow/random.h	/^    int status = vdRngUniform(0, vStream_, size, dptr, a, b);$/;"	l	language:C++
status	include/mshadow/random.h	/^    int status = vsRngGaussian(0, vStream_, size, dptr, mu, sigma);$/;"	l	language:C++
status	include/mshadow/random.h	/^    int status = vsRngUniform(0, vStream_, size, dptr, a, b);$/;"	l	language:C++
status	include/mshadow/random.h	/^    int status = vslNewStream(&vStream_, VSL_BRNG_MT19937, seed);$/;"	l	language:C++
std::endl	depparser/Depparser.cpp	/^					std::cout<<"Processing sentence "<<inst<<std::endl;$/;"	m	language:C++	class:std	file:
std::endl	depparser/Depparser.cpp	/^	std::cout<<"Training Instance Num: "<<inputs.size()<<std::endl;$/;"	m	language:C++	class:std	file:
std::endl	depparser/Depparser.cpp	/^	std::cout<<"Training begin!"<<std::endl;$/;"	m	language:C++	class:std	file:
std::random_shuffle	depparser/Depparser.cpp	/^		std::random_shuffle ( gExamples.begin(), gExamples.end() );$/;"	p	language:C++	class:std	file:	signature:( gExamples.begin(), gExamples.end() )
std::swap	thirdparty/mshadow/guide/neuralnet/util.h	/^    std::swap(data[i], data[rand() % (i+1)]);$/;"	p	language:C++	class:std	signature:(data[i], data[rand() % (i+1)])
step	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    int step = batch_size \/ ndev;$/;"	l	language:C++
step	thirdparty/mshadow/guide/neuralnet/util.h	/^  int step = width * height;$/;"	l	language:C++
strCorpus	depparser/Config.cpp	/^			CConfig::strCorpus = pVal;$/;"	m	language:C++	class:CConfig	file:
strDBNPath	depparser/Config.cpp	/^			CConfig::strDBNPath = pVal;$/;"	m	language:C++	class:CConfig	file:
strEmbeddingPath	depparser/Config.cpp	/^			CConfig::strEmbeddingPath = pVal;$/;"	m	language:C++	class:CConfig	file:
strEmbeddingPath	depparser/Config.h	/^	static string strEmbeddingPath;$/;"	m	language:C++	class:CConfig	access:public
strErrorType	depparser/Config.cpp	/^			CConfig::strErrorType = pVal;$/;"	m	language:C++	class:CConfig	file:
strErrorType	depparser/Config.cpp	/^	path + "_err"+ CConfig::strErrorType;$/;"	m	language:C++	class:CConfig	file:
strLogPrefix	depparser/Config.cpp	/^			CConfig::strLogPrefix = pVal;$/;"	m	language:C++	class:CConfig	file:
strRBMPrefix	depparser/Config.cpp	/^			CConfig::strRBMPrefix = pVal;$/;"	m	language:C++	class:CConfig	file:
strTestPath	depparser/Config.cpp	/^			CConfig::strTestPath = pVal;$/;"	m	language:C++	class:CConfig	file:
strTestPath	depparser/Config.h	/^	static string strTestPath;$/;"	m	language:C++	class:CConfig	access:public
strTrainPath	depparser/Config.cpp	/^			CConfig::strTrainPath = pVal;$/;"	m	language:C++	class:CConfig	file:
strTrainPath	depparser/Config.h	/^	static string strTrainPath;$/;"	m	language:C++	class:CConfig	access:public
strdevPath	depparser/Config.h	/^	static string strdevPath;$/;"	m	language:C++	class:CConfig	access:public
stream	include/NNet.h	/^    Stream<xpu> *stream = NewStream<xpu>();$/;"	l	language:C++
stream	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  cudaStream_t stream = Stream<gpu>::GetStream(dst.stream_);$/;"	l	language:C++
stream	include/mshadow/io.h	/^  Stream<gpu> stream;$/;"	l	language:C++
stream	include/mshadow/tensor_container.h	/^    Stream<Device> stream;$/;"	l	language:C++
stream	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^  mshadow::Stream<xpu> *stream  = mshadow::NewStream<xpu>();$/;"	l	language:C++
stream	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::Stream<xpu> *stream  = mshadow::NewStream<xpu>();$/;"	l	language:C++
stream	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    Stream<xpu> *stream = NewStream<xpu>();$/;"	l	language:C++
stream	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    Stream<xpu> *stream = NewStream<xpu>();$/;"	l	language:C++
stream	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  mshadow::Stream<xpu> *stream;$/;"	m	language:C++	class:NNet	file:	access:private
stream_	include/mshadow/stream_gpu-inl.h	/^  cudaStream_t stream_;$/;"	m	language:C++	struct:mshadow::Stream	access:public
stream_	include/mshadow/tensor.h	/^  Stream<Device> *stream_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
stream_	thirdparty/mshadow/guide/README.md	/^  Stream<Device> stream_;$/;"	m	language:C++	struct:Tensor	file:	access:public
stream_	thirdparty/mshadow/guide/defop.cpp	/^  Stream<cpu> *stream_ = NewStream<cpu>();$/;"	l	language:C++
stride_	include/mshadow/expr_engine-inl.h	/^  index_t stride_;$/;"	m	language:C++	class:mshadow::expr::Plan	access:private
stride_	include/mshadow/extension/channel_pool.h	/^  index_t stride_;$/;"	m	language:C++	struct:mshadow::expr::ChannelPoolingExp	access:public
stride_	include/mshadow/sse-inl.h	/^  index_t stride_;$/;"	m	language:C++	class:mshadow::expr::SSEPlan	access:private
stride_	include/mshadow/tensor.h	/^  index_t stride_;$/;"	m	language:C++	struct:mshadow::Tensor	access:public
stride_	include/mshadow/tensor_blob.h	/^  index_t stride_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
stride_	thirdparty/mshadow/guide/README.md	/^  index_t stride_;$/;"	m	language:C++	struct:Tensor	file:	access:public
stride_	thirdparty/mshadow/guide/README.md	/^The result ts should be a 3 * 2 matrix, where data[2], data[5], data[8] are padding cells that are ignored. If you want a continuous memory, set ```stride_=shape_[1]```.$/;"	v	language:C++
string	include/mshadow-ps/ps_local-inl.h	/^                                    std::string(val)));$/;"	p	language:C++	class:mshadow::ps::LocalModel::std	signature:(val)
sum	depparser/Depparser.cpp	/^					double sum =0;$/;"	l	language:C++
sum	include/mshadow/base.h	/^struct sum {$/;"	s	language:C++	namespace:mshadow::red
sum	include/mshadow/tensor_cpu-inl.h	/^  DType sum = 0.0f;$/;"	l	language:C++
sum	include/mshadow/tensor_cpu-inl.h	/^  DType sum = static_cast<DType>(0);$/;"	l	language:C++
sum_rows	include/mshadow/extension/reduceto1d.h	/^sum_rows(const Exp<SrcExp, DType, etype> &exp) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &exp)
sumall_except_dim	include/mshadow/extension/reduceto1d.h	/^sumall_except_dim(const Exp<SrcExp, DType, etype> &exp) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &exp)
sv	include/mshadow/base.h	/^namespace sv {$/;"	n	language:C++	namespace:mshadow
swap	include/mshadow/expr_engine-inl.h	/^    std::swap(s[0], s[1]);$/;"	p	language:C++	class:mshadow::expr::ShapeCheck::std	signature:(s[0], s[1])
swap	include/mshadow/extension/swapaxis.h	/^    std::swap(this->shape_[a1], this->shape_[a2]);$/;"	p	language:C++	class:mshadow::expr::SwapAxisExp::std	signature:(this->shape_[a1], this->shape_[a2])
swap	thirdparty/mshadow/guide/neuralnet/util.h	/^    std::swap(data[i], data[rand() % (i+1)]);$/;"	p	language:C++	class:std	signature:(data[i], data[rand() % (i+1)])
swapaxis	include/mshadow/extension/swapaxis.h	/^swapaxis(const Exp<SrcExp, DType, etype> &src) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &src)
t	include/mshadow/random.h	/^    DType t = std::sqrt(-2.0f * std::log(s) \/ s);$/;"	l	language:C++
t_data	thirdparty/mshadow/guide/neuralnet/util.h	/^  unsigned char *t_data, *l_data;$/;"	l	language:C++
tag	depparser/DepTreeNode.h	/^	std::string tag;$/;"	m	language:C++	class:DepTreeNode	access:public
tagIdx	depparser/Depparser.cpp	/^			auto tagIdx = tagMap.find(iter->tag);$/;"	l	language:C++
tagIdx	depparser/GlobalExample.h	/^	std::vector<int> tagIdx;$/;"	m	language:C++	class:GlobalExample	access:public
tagIndexCache	depparser/Depparser.cpp	/^		std::vector<int> tagIndexCache(gTree.size);$/;"	p	language:C++	file:	signature:(gTree.size)
tagMap	depparser/Depparser.h	/^	std::unordered_map<std::string, int> tagMap;$/;"	m	language:C++	class:Depparser	access:private
tagNullIdx	depparser/Depparser.h	/^	static int tagNullIdx;$/;"	m	language:C++	class:Depparser	access:private
tagRootIdx	depparser/Depparser.h	/^	static int tagRootIdx;$/;"	m	language:C++	class:Depparser	access:private
tagSet	depparser/Depparser.cpp	/^	std::unordered_set tagSet;$/;"	l	language:C++
tagUnkIdx	depparser/Depparser.h	/^	static int tagUnkIdx;$/;"	m	language:C++	class:Depparser	access:private
target	depparser/Depparser.cpp	/^							State* target = lattice_index[round] + i;$/;"	l	language:C++
tcast	include/mshadow/expression.h	/^tcast(const Exp<EType, SrcDType, etype> &exp) {$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<EType, SrcDType, etype> &exp)
test_on_server	include/mshadow-ps/ps_local-inl.h	/^  int test_on_server;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
threadExampleNum	depparser/Depparser.cpp	/^		int threadExampleNum = CConfig::nBatchSize \/ CConfig::nThread;$/;"	l	language:C++
threadExamples	depparser/Depparser.cpp	/^			std::vector<GlobalExample*> threadExamples(sp, ep);$/;"	p	language:C++	file:	signature:(sp, ep)
thread_handle	include/mshadow-ps/thread.h	/^  HANDLE    thread_handle;$/;"	m	language:C++	class:mshadow::utils::Thread	access:private
thread_id	include/mshadow-ps/thread.h	/^  unsigned  thread_id;$/;"	m	language:C++	class:mshadow::utils::Thread	access:private
thread_pull_handler	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::Thread> thread_pull_handler;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
thread_push_handler	include/mshadow-ps/ps_local-inl.h	/^  std::vector<utils::Thread> thread_push_handler;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
thread_reduce_handler_	include/mshadow-ps/ps_rabit-inl.h	/^  utils::Thread thread_reduce_handler_;$/;"	m	language:C++	class:mshadow::ps::RabitModel	access:private
tid	include/mshadow/cuda/reduce.cuh	/^  int tid = threadIdx.x;$/;"	l	language:C++
tid	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const index_t tid = (block_idx << block_dim_bits) + threadIdx.x;$/;"	l	language:C++
tid	thirdparty/mshadow/guide/mshadow-ps/dist_async_sum-inl.h	/^    int tid = omp_get_thread_num();$/;"	l	language:C++
tid	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^    int tid = omp_get_thread_num();$/;"	l	language:C++
tid	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      int tid = omp_get_thread_num();$/;"	l	language:C++
tmp	include/mshadow-ps/ps_local-inl.h	/^    mshadow::TensorContainer<cpu, 2, DType> tmp(false);$/;"	p	language:C++	signature:(false)
tmp	include/mshadow/io.h	/^  Tensor<cpu, dim, DType> tmp(src.shape_);$/;"	p	language:C++	signature:(src.shape_)
tmp	include/mshadow/io.h	/^  Tensor<cpu, dim, DType> tmp;$/;"	l	language:C++
tmp	include/mshadow/sse-inl.h	/^    DType tmp =  _mm_add_sd(data_, _mm_unpackhi_pd(data_, data_));$/;"	l	language:C++
tmp	include/mshadow/tensor_container.h	/^    Tensor<cpu, dimension, DType> tmp;$/;"	l	language:C++
tmp	thirdparty/mshadow/guide/mshadow-ps/local_sum-inl.h	/^  mshadow::TensorContainer<mshadow::cpu, 2, float> tmp;$/;"	l	language:C++
tmp_col	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> tmp_col, tmp_dst;$/;"	m	language:C++	class:ConvNet	file:	access:private
tmp_dst	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<xpu, 2, real_t> tmp_col, tmp_dst;$/;"	m	language:C++	class:ConvNet	file:	access:private
tot	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const index_t tot = pshape[3] * pshape[2] * pshape[0];$/;"	l	language:C++
totalSize	include/Pool.h	/^	size_t   totalSize;$/;"	m	language:C++	class:CPool	access:private
train	depparser/Depparser.cpp	/^void Depparser::train(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees,$/;"	f	language:C++	class:Depparser	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees, std::vector<DepParseInput> devInputs, std::vector<DepTree> devTrees)
train	depparser/Depparser.h	/^	void train(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees,$/;"	p	language:C++	class:Depparser	access:public	signature:(std::vector<DepParseInput> inputs, std::vector<DepTree> goldTrees, std::vector<DepParseInput> devInputs, std::vector<DepTree> devTrees)
trainingDataSize	depparser/Depparser.cpp	/^					int trainingDataSize = trainingStates.size();$/;"	l	language:C++
trainingStates	depparser/Depparser.cpp	/^					std::vector<State> trainingStates(beamTransits, beamTransits + currentBeamSize);$/;"	p	language:C++	file:	signature:(beamTransits, beamTransits + currentBeamSize)
trans	depparser/Depparser.cpp	/^							CScoredTransition trans;$/;"	l	language:C++
transition	depparser/Depparser.cpp	/^							const CScoredTransition& transition = beamTransits[i];$/;"	l	language:C++
treeNode	depparser/Depparser.cpp	/^			auto treeNode = goldTrees[i].nodes[j];$/;"	l	language:C++
tres	include/mshadow/tensor_cpu-inl.h	/^      DType tres; Reducer::SetInitValue(tres);$/;"	l	language:C++
ts	include/mshadow-ps/ps_dist-inl.h	/^    int ts = shared_model_.Push($/;"	l	language:C++
ts	thirdparty/mshadow/guide/README.md	/^  Tensor<cpu, 3> ts(data, Shape3(2,5,2));$/;"	p	language:C++	file:	signature:(data, Shape3(2,5,2))
ts	thirdparty/mshadow/guide/README.md	/^Tensor<cpu, 2> ts;$/;"	v	language:C++
ts	thirdparty/mshadow/guide/basic.cpp	/^  Tensor<cpu, 3> ts(data, Shape3(2,5,2));$/;"	p	language:C++	file:	signature:(data, Shape3(2,5,2))
ts	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^      ss << ts[i][j] << " ";$/;"	l	language:C++
ts	thirdparty/mshadow/guide/mshadow-ps/dbstr.h	/^    ss << ts[i] << " ";$/;"	l	language:C++
ts1	thirdparty/mshadow/guide/basic_stream.cu	/^  Tensor<gpu, 2, float> ts1 = NewTensor<gpu, float>(Shape2(2, 5), 0.0f, sm1);$/;"	l	language:C++
ts2	thirdparty/mshadow/guide/README.md	/^AllocSpace(&ts2);$/;"	v	language:C++
ts2	thirdparty/mshadow/guide/README.md	/^FreeSpace(&ts2); FreeSpace(&ts3);$/;"	v	language:C++
ts2	thirdparty/mshadow/guide/README.md	/^Tensor<cpu, 2> ts2;$/;"	v	language:C++
ts2	thirdparty/mshadow/guide/basic_stream.cu	/^  Tensor<gpu, 2, float> ts2 = NewTensor<gpu, float>(Shape2(2, 5), 0.0f, sm2);$/;"	l	language:C++
ts3	thirdparty/mshadow/guide/README.md	/^FreeSpace(&ts2); FreeSpace(&ts3);$/;"	v	language:C++
ts3	thirdparty/mshadow/guide/README.md	/^Tensor<cpu, 3> ts3 = NewTensor<cpu>(Shape3(5,3,2), 0.0f);$/;"	v	language:C++
ts3	thirdparty/mshadow/guide/README.md	/^Tensor<gpu, 3, float> ts3;$/;"	v	language:C++
tsk	include/mshadow-ps/ps_local-inl.h	/^      PullTask tsk;$/;"	l	language:C++
tsk	include/mshadow-ps/ps_local-inl.h	/^      std::pair<int, int> tsk;$/;"	l	language:C++
tsk	include/mshadow-ps/ps_rabit-inl.h	/^      ReduceTask tsk;$/;"	l	language:C++
tsk	include/mshadow-ps/ps_rabit-inl.h	/^    ReduceTask tsk;$/;"	l	language:C++
type	include/mshadow/expression.h	/^namespace type {$/;"	n	language:C++	namespace:mshadow::expr
type_flag_	include/mshadow/tensor_blob.h	/^  int type_flag_;$/;"	m	language:C++	class:mshadow::TBlob	access:public
uniform	include/mshadow/random.h	/^  uniform(Shape<dim> shape) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(Shape<dim> shape)
unknow	depparser/DepAction.h	/^static std::string unknow = "-UNKNOW-";$/;"	v	language:C++
unpack_patch2col	include/mshadow/extension/unpack_patch2col.h	/^unpack_patch2col(const Exp<SrcExp, DType, etype> &img,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &img, index_t psize_y, index_t psize_x, index_t pstride)
unpool	include/mshadow/extension/spatial_unpool.h	/^unpool(const Exp<SrcExp, DType, etype> &data_src,$/;"	f	language:C++	namespace:mshadow::expr	signature:(const Exp<SrcExp, DType, etype> &data_src, const Exp<SrcExp, DType, etype> &data_pooled, const Exp<SrcExp, DType, etype> &grad_pooled, index_t ksize_y, index_t ksize_x, index_t kstride)
updateParas	depparser/Depparser.cpp	/^					std::vector<float> updateParas(trainingDataSize, 0); \/\/ updating parameter vector$/;"	p	language:C++	file:	signature:(trainingDataSize, 0)
update_on_server	include/mshadow-ps/ps_local-inl.h	/^  int update_on_server;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
updater	include/mshadow-ps/ps_dist-inl.h	/^    IModelUpdater<DType> *updater = CreateModelUpdater<DType>();$/;"	l	language:C++
updater_	include/mshadow-ps/ps_dist-inl.h	/^  IModelUpdater<DType> *updater_;$/;"	m	language:C++	class:mshadow::ps::UpdaterWrapper	access:private
use_fifo_	include/mshadow-ps/thread_util.h	/^  bool use_fifo_;$/;"	m	language:C++	class:mshadow::utils::ThreadPQueue	access:private
use_fifo_push_queue	include/mshadow-ps/ps_local-inl.h	/^  int use_fifo_push_queue;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:protected
use_pin_memory	include/mshadow-ps/ps_local-inl.h	/^  int use_pin_memory;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
utils	include/mshadow-ps/thread.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
utils	include/mshadow-ps/thread_util.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
utils	include/mshadow/io.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
utils	include/mshadow/utils.h	/^namespace utils {$/;"	n	language:C++	namespace:mshadow
vHiddenSize	depparser/Config.cpp	/^vector<int> CConfig::vHiddenSize;$/;"	m	language:C++	class:CConfig	file:
vHiddenSize	depparser/Config.h	/^	static vector<int>  vHiddenSize;$/;"	m	language:C++	class:CConfig	access:public
vHiddenType	depparser/Config.cpp	/^vector<string> CConfig::vHiddenType;$/;"	m	language:C++	class:CConfig	file:
vStream_	include/mshadow/random.h	/^  VSLStreamStatePtr vStream_;$/;"	m	language:C++	class:mshadow::Random	access:private
validActs	depparser/Depparser.cpp	/^						std::vector<int> validActs;$/;"	l	language:C++
vsrc	include/mshadow/extension/channel_unpool.h	/^    const DType vsrc = data_src_.Eval(i, j);$/;"	l	language:C++
vsrc	include/mshadow/extension/spatial_unpool.h	/^    const DType vsrc = data_src_.Eval(i, j);$/;"	l	language:C++
w	include/mshadow-ps/ps_local-inl.h	/^          PullWaitRecord &w = e.wait[wid];$/;"	l	language:C++
w	include/mshadow-ps/ps_local-inl.h	/^    PullWaitRecord &w = e.wait[wid];$/;"	l	language:C++
w	include/mshadow/extension/crop.h	/^    const index_t w = x + pad_width_;$/;"	l	language:C++
w	include/mshadow/extension/pad.h	/^    const index_t w = x - pad_x_;$/;"	l	language:C++
wait	include/mshadow-ps/ps_local-inl.h	/^    std::vector<PullWaitRecord> wait;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PullEntry	access:public
wait_cond	include/mshadow-ps/ps_local-inl.h	/^  utils::ConditionVariable wait_cond;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
wait_lock	include/mshadow-ps/ps_local-inl.h	/^  utils::Mutex wait_lock;$/;"	m	language:C++	class:mshadow::ps::LocalModel	access:private
warp_size	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const unsigned warp_size = 1 << warp_bits;$/;"	l	language:C++
wd	include/NNet.h	/^    const float wd = 0.00001;$/;"	l	language:C++
wd	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^    const float wd = 0.00001;$/;"	l	language:C++
wd	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^    const float wd = 0.00001;$/;"	l	language:C++
wd	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^      const float wd = 0.00001;$/;"	l	language:C++
weight	include/mshadow-ps/ps_local-inl.h	/^    Tensor<cpu, 2, DType> weight;$/;"	m	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public
weight	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^    mshadow::Tensor<xpu, 2> weight;$/;"	m	language:C++	struct:NNet::UpdateEntry	file:	access:public
wid	include/mshadow-ps/ps_local-inl.h	/^        const int wid = GetWorkIndex(devid);$/;"	l	language:C++
wid	include/mshadow-ps/ps_local-inl.h	/^        const int wid = GetWorkIndex(tsk.devid);$/;"	l	language:C++
wid	include/mshadow-ps/ps_local-inl.h	/^      int wid = GetWorkIndex(devid);$/;"	l	language:C++
wid	include/mshadow-ps/ps_local-inl.h	/^    const int wid = GetWorkIndex(devid);$/;"	l	language:C++
width	thirdparty/mshadow/guide/neuralnet/util.h	/^  int num_image, width, height, nlabel;            $/;"	l	language:C++
width_	include/mshadow/extension/mirror.h	/^  const index_t width_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
width_src1_	include/mshadow/extension/concat.h	/^  const index_t width_src1_;$/;"	m	language:C++	struct:mshadow::expr::Plan	access:private
word	depparser/DepTreeNode.h	/^	std::string word;$/;"	m	language:C++	class:DepTreeNode	access:public
wordIdx	depparser/Depparser.cpp	/^			auto wordIdx = wordMap.find(iter->word);$/;"	l	language:C++
wordIdx	depparser/GlobalExample.h	/^	std::vector<int> wordIdx;$/;"	m	language:C++	class:GlobalExample	access:public
wordIndexCache	depparser/Depparser.cpp	/^		std::vector<int> wordIndexCache(gTree.size);$/;"	p	language:C++	file:	signature:(gTree.size)
wordMap	depparser/Depparser.h	/^	std::unordered_map<std::string, int> wordMap;$/;"	m	language:C++	class:Depparser	access:private
wordNullIdx	depparser/Depparser.h	/^	static int wordNullIdx;$/;"	m	language:C++	class:Depparser	access:private
wordRootIdx	depparser/Depparser.h	/^	static int wordRootIdx;$/;"	m	language:C++	class:Depparser	access:private
wordSet	depparser/Depparser.cpp	/^	std::unordered_set wordSet;$/;"	l	language:C++
wordUnkIdx	depparser/Depparser.h	/^	static int wordUnkIdx;$/;"	m	language:C++	class:Depparser	access:private
words	include/Dict.h	/^	vector<string> words;$/;"	m	language:C++	class:Dict	access:private
wrapper	include/mshadow-ps/ps_dist-inl.h	/^    UpdaterWrapper<DType> *wrapper = new UpdaterWrapper<DType>(updater);$/;"	l	language:C++
x	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      const index_t x = i % pshape[3];$/;"	l	language:C++
x	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int x = tid % xstride;$/;"	l	language:C++
x	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const unsigned x = (blockIdx.x << warp_bits) + threadIdx.x;$/;"	l	language:C++
x	include/mshadow/extension/channel_pool.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/channel_unpool.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/concat.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/crop.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/pack_col2patch.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/pad.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/spatial_unpool.h	/^    const index_t x = j;$/;"	l	language:C++
x	include/mshadow/extension/unpack_patch2col.h	/^    const index_t x = (j % o_width_) * pstride_ + x_offset;$/;"	l	language:C++
x	include/mshadow/random.h	/^    DType x, y, s;$/;"	l	language:C++
x_end	include/mshadow/extension/spatial_pool.h	/^    const index_t x_end = min(x_start + ksize_x_, src_width_);$/;"	l	language:C++
x_offset	include/mshadow/extension/unpack_patch2col.h	/^    const index_t x_offset = i % psize_x_;$/;"	l	language:C++
x_size	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const unsigned x_size = 1 << x_bits;$/;"	l	language:C++
x_start	include/mshadow/extension/spatial_pool.h	/^    const index_t x_start = px * kstride_;$/;"	l	language:C++
xample	thirdparty/mshadow/guide/exp-template/README.md	/^    - This allows us to put less variables in Plan, for example, we do not need array length when we evaluate a data.$/;"	v	language:C++	typeref:class:
xlen	include/mshadow/sse-inl.h	/^  const index_t xlen = sse2::LowerAlign(dst.size(1), sizeof(DType));$/;"	l	language:C++
xstride	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const index_t xstride = GetAlignStride(dshape[1]);$/;"	l	language:C++
xtest	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<cpu,2> xtrain, xtest;$/;"	l	language:C++
xtest	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<cpu,2> xtrain, xtest;$/;"	l	language:C++
xtest_	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<cpu, 2, real_t> xtrain_, xtest_;$/;"	l	language:C++
xtrain	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  TensorContainer<cpu,2> xtrain, xtest;$/;"	l	language:C++
xtrain	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  TensorContainer<cpu,2> xtrain, xtest;$/;"	l	language:C++
xtrain_	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  TensorContainer<cpu, 2, real_t> xtrain_, xtest_;$/;"	l	language:C++
xx	include/mshadow/random.h	/^    DType &xx = *xx_, &yy = *yy_;$/;"	l	language:C++
y	include/mshadow/cuda/tensor_gpu-inl.cuh	/^      const index_t y = i % pshape[2];$/;"	l	language:C++
y	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int y = blockIdx.x;$/;"	l	language:C++
y	include/mshadow/cuda/tensor_gpu-inl.cuh	/^  const int y = tid \/ xstride;$/;"	l	language:C++
y	include/mshadow/extension/channel_pool.h	/^    const index_t y = i % height_;$/;"	l	language:C++
y	include/mshadow/extension/channel_unpool.h	/^    const index_t y = i % height_;$/;"	l	language:C++
y	include/mshadow/extension/concat.h	/^    const index_t y = i % height_;$/;"	l	language:C++
y	include/mshadow/extension/crop.h	/^    const index_t y = i % new_height_;$/;"	l	language:C++
y	include/mshadow/extension/pack_col2patch.h	/^    const index_t y = i % i_height_;$/;"	l	language:C++
y	include/mshadow/extension/pad.h	/^    const index_t y = i % new_height_;$/;"	l	language:C++
y	include/mshadow/extension/spatial_unpool.h	/^    const index_t y = i % sshape_y_;$/;"	l	language:C++
y	include/mshadow/extension/swapaxis.h	/^    const index_t y = i % shapey_;$/;"	l	language:C++
y	include/mshadow/extension/unpack_patch2col.h	/^    const index_t y = (jdivw % o_height_) * pstride_ + y_offset;$/;"	l	language:C++
y	include/mshadow/random.h	/^    DType x, y, s;$/;"	l	language:C++
y_end	include/mshadow/extension/spatial_pool.h	/^    const index_t y_end = min(y_start + ksize_y_, src_height_);$/;"	l	language:C++
y_offset	include/mshadow/extension/unpack_patch2col.h	/^    const index_t y_offset = idivp % psize_y_;$/;"	l	language:C++
y_start	include/mshadow/extension/spatial_pool.h	/^    const index_t y_start = py * kstride_;$/;"	l	language:C++
ymax	include/mshadow/tensor.h	/^    index_t ymax = 1;$/;"	l	language:C++
ymax	include/mshadow/tensor_blob.h	/^    index_t ymax = 1;$/;"	l	language:C++
ytest	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  std::vector<int> ytrain, ytest;$/;"	l	language:C++
ytest	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  std::vector<int> ytrain, ytest;$/;"	l	language:C++
ytest	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  std::vector<int> ytrain, ytest;$/;"	l	language:C++
ytrain	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  std::vector<int> ytrain, ytest;$/;"	l	language:C++
ytrain	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  std::vector<int> ytrain, ytest;$/;"	l	language:C++
ytrain	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  std::vector<int> ytrain, ytest;$/;"	l	language:C++
yy	include/mshadow/random.h	/^    DType &xx = *xx_, &yy = *yy_;$/;"	l	language:C++
z	include/mshadow/extension/swapaxis.h	/^    const index_t z = i % shapez_;$/;"	l	language:C++
zz	thirdparty/mshadow/guide/neuralnet/util.h	/^  unsigned char zz[4];$/;"	l	language:C++
~CPool	include/Pool.cpp	/^CPool::~CPool(void)$/;"	f	language:C++	class:CPool	signature:(void)
~CPool	include/Pool.h	/^	~CPool(void);$/;"	p	language:C++	class:CPool	access:public	signature:(void)
~Classifier	depparser/Classifier.cpp	/^Classifier::~Classifier() {$/;"	f	language:C++	class:Classifier	signature:()
~Classifier	depparser/Classifier.h	/^	virtual ~Classifier();$/;"	p	language:C++	class:Classifier	access:public	signature:()
~ConvNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual ~ConvNet() {}$/;"	f	language:C++	class:ConvNet	access:public	signature:()
~DepTree	depparser/DepTree.h	/^	~DepTree(){}$/;"	f	language:C++	class:DepTree	access:public	signature:()
~DepTreeNode	depparser/DepTreeNode.h	/^	virtual ~DepTreeNode(){}$/;"	f	language:C++	class:DepTreeNode	access:public	signature:()
~Depparser	depparser/Depparser.cpp	/^Depparser::~Depparser() {$/;"	f	language:C++	class:Depparser	signature:()
~Depparser	depparser/Depparser.h	/^	virtual ~Depparser();$/;"	p	language:C++	class:Depparser	access:public	signature:()
~Dict	include/Dict.h	/^	virtual ~Dict(){};$/;"	f	language:C++	class:Dict	access:public	signature:()
~DistModel	include/mshadow-ps/ps_dist-inl.h	/^  virtual ~DistModel(void) {$/;"	f	language:C++	class:mshadow::ps::DistModel	access:public	signature:(void)
~Example	depparser/Example.h	/^	virtual ~Example(){$/;"	f	language:C++	class:Example	access:public	signature:()
~FeatureEmbedding	include/FeatureEmbedding.h	/^	virtual ~FeatureEmbedding(){$/;"	f	language:C++	class:FeatureEmbedding	access:public	signature:()
~GlobalExample	depparser/GlobalExample.h	/^	virtual ~GlobalExample();$/;"	p	language:C++	class:GlobalExample	access:public	signature:()
~IModelUpdater	include/mshadow-ps/mshadow_ps.h	/^  virtual ~IModelUpdater(void) {}$/;"	f	language:C++	class:mshadow::ps::IModelUpdater	access:public	signature:(void)
~INNet	thirdparty/mshadow/guide/neuralnet/convnet.cu	/^  virtual ~INNet() {}$/;"	f	language:C++	class:INNet	access:public	signature:()
~INNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual ~INNet() {}$/;"	f	language:C++	class:INNet	access:public	signature:()
~INNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual ~INNet() {}$/;"	f	language:C++	class:INNet	access:public	signature:()
~ISharedModel	include/mshadow-ps/mshadow_ps.h	/^  virtual ~ISharedModel(void) {}$/;"	f	language:C++	class:mshadow::ps::ISharedModel	access:public	signature:(void)
~IStream	include/mshadow/io.h	/^  virtual ~IStream(void) {}$/;"	f	language:C++	class:mshadow::utils::IStream	access:public	signature:(void)
~LocalModel	include/mshadow-ps/ps_local-inl.h	/^  virtual ~LocalModel(void) {$/;"	f	language:C++	class:mshadow::ps::LocalModel	access:public	signature:(void)
~MShadowServerNode	include/mshadow-ps/ps_dist-inl.h	/^  virtual ~MShadowServerNode() { }$/;"	f	language:C++	class:mshadow::ps::MShadowServerNode	access:public	signature:()
~NNet	include/NNet.h	/^  virtual ~NNet() {}$/;"	f	language:C++	class:NNet	access:public	signature:()
~NNet	thirdparty/mshadow/guide/neuralnet/nnet.cu	/^  virtual ~NNet() {}$/;"	f	language:C++	class:NNet	access:public	signature:()
~NNet	thirdparty/mshadow/guide/neuralnet/nnet_ps.cu	/^  virtual ~NNet() {$/;"	f	language:C++	class:NNet	access:public	signature:()
~PushEntry	include/mshadow-ps/ps_local-inl.h	/^    ~PushEntry(void) {$/;"	f	language:C++	struct:mshadow::ps::LocalModel::PushEntry	access:public	signature:(void)
~RabitModel	include/mshadow-ps/ps_rabit-inl.h	/^  virtual ~RabitModel(void) {$/;"	f	language:C++	class:mshadow::ps::RabitModel	access:public	signature:(void)
~Random	include/mshadow/random.h	/^  ~Random(void) {$/;"	f	language:C++	class:mshadow::Random	access:public	signature:(void)
~State	depparser/State.h	/^	~State() {$/;"	f	language:C++	class:State	access:public	signature:()
~TShape	include/mshadow/tensor_blob.h	/^  ~TShape() {$/;"	f	language:C++	struct:mshadow::TShape	access:public	signature:()
~TensorContainer	include/mshadow/tensor_container.h	/^  ~TensorContainer(void) {$/;"	f	language:C++	class:mshadow::TensorContainer	access:public	signature:(void)
~UpdaterWrapper	include/mshadow-ps/ps_dist-inl.h	/^  ~UpdaterWrapper() { delete updater_; }$/;"	f	language:C++	class:mshadow::ps::UpdaterWrapper	access:public	signature:()
